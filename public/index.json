[{"categories":["分布式系统"],"content":"lab3B 实现的最轻松的lab ","date":"2023-12-29","objectID":"/mit6.824%E4%B9%8Blab3b/:1:0","tags":["mit6.824"],"title":"Mit6.824之lab3B","uri":"/mit6.824%E4%B9%8Blab3b/"},{"categories":["分布式系统"],"content":"论文总结 论文对于lab3B的实现提及较少，主要是以下几点 重新启动kvserver时，如果存在快照，则直接把快照里的数据放到状态机里 kvserver需要检测RaftStateSize是否接近maxraftstate，如果大于就快照 应用层从applyCh管道中接收到的follower快照需要替换当前状态机，以进行快速恢复 ","date":"2023-12-29","objectID":"/mit6.824%E4%B9%8Blab3b/:1:1","tags":["mit6.824"],"title":"Mit6.824之lab3B","uri":"/mit6.824%E4%B9%8Blab3b/"},{"categories":["分布式系统"],"content":"实现思路 快照 每个server都需要监控 func (kv *KVServer) snapshot() { if kv.maxraftstate == -1 { return } rate := float64(kv.persister.RaftStateSize()) / float64(kv.maxraftstate) if rate \u003e= 0.9 { snapshotStatus := \u0026SnapshotStatus{ LastApplied: kv.lastApplied, Data: kv.data, Duptable: kv.duptable, } w := new(bytes.Buffer) if err := labgob.NewEncoder(w).Encode(snapshotStatus); err != nil { Debug(dError, \"snapshot gob encode snapshotStatus err:%v\", err) return } kv.rf.Snapshot(snapshotStatus.LastApplied, w.Bytes()) } } apply中快照处理 func (kv *KVServer) apply() { for msg := range kv.applyCh { kv.mu.Lock() if msg.CommandValid { // todo 应用已提交的log kv.snapshot() } else if msg.SnapshotValid /*follower使用快照重置状态机*/ { snapshotStatus := \u0026SnapshotStatus{} if err := labgob.NewDecoder(bytes.NewBuffer(msg.Snapshot)).Decode(snapshotStatus); err != nil { Debug(dError, \"snapshot gob encode snapshotStatus err:%v\", err) return } kv.lastApplied = snapshotStatus.LastApplied kv.data = snapshotStatus.Data kv.duptable = snapshotStatus.Duptable Debug(dSnap, \"snapshot lastApplied:%d\", snapshotStatus.LastApplied) } kv.mu.Unlock() } } ","date":"2023-12-29","objectID":"/mit6.824%E4%B9%8Blab3b/:1:2","tags":["mit6.824"],"title":"Mit6.824之lab3B","uri":"/mit6.824%E4%B9%8Blab3b/"},{"categories":["分布式系统"],"content":"调试过程 花了差不多一个小时便实现了初版，但是测试偶尔能pass，偶尔只fail掉下面三个测试用例。 **Test: restarts, snapshots, many clients (3B) …**用例 该用例显示“duplicate element x 17 11 y in Append result”，表示重复log。 主要是还没有实现lab3B tips中的Your kvserver must be able to detect duplicated operations in the log across checkpoints, so any state you are using to detect them must be included in the snapshots. 我的实现是快照的时候，将kvdata和duplicate table一起快照，重放的时候duplicate table代替即可。 **Test: restarts, snapshots, many clients (3B) …**用例 较少出现的FAIL： get wrong value, key 8, wanted: x 8 0 yx 8 1 yx 8 2 yx 8 3 yx 8 4 yx 8 5 yx 8 6 yx 8 7 yx 8 8 yx 8 9 yx 8 10 yx 8 11 yx 8 12 yx 8 13 yx 8 14 yx 8 15 yx 8 16 y got: x 8 0 yx 8 1 yx 8 2 yx 8 3 yx 8 4 yx 8 5 yx 8 6 yx 8 7 yx 8 8 yx 8 9 yx 8 10 yx 8 11 yx 8 12 yx 8 13 yx 8 14 yx 8 15 y 初步猜测是自己在实现lab 2D残留的bug导致的，后面找时间解决解决一下。 不清楚问题出现在了哪里，参考了博客的说法 几个可能出现的错误与原因: get命令发现某一个value值缺了中间一个，如1，2，3，5，6 值最后缺了一个，如1，2，3，4 但应该是1，2，3，4，5 这两种情况很可能是接收了snapshot后修改了lastapplied，但是常规apply循环此时并没有结束，因而自增了lastapplied 所以，我这里就把apply和snapshot串行化了，不再并发协程处理了。 主要是把以前的定期快照和follower应用快照进行串行化处理，然后快照的时候，一定要先copy锁释放前的状态，然后新开协程执行锁前的快照。（qwq，后面运行了几百次算是解决了这个问题 但是这又会引起新的问题：因为只有从applyCh管道收到已提交的日志，才会让kvserver快照。如果在管道收到所有已提交的日志前，客户端请求速度较快较多，会导致日志不断堆积，从而使日志可能会超过测试用例给的限制。这种情况下目前还没有解决。 **Test: unreliable net, snapshots, many clients (3B) …**用例 偶尔出现test took longer than 120 seconds问题，主要是我在机子上并发运行很多个测试，导致cpu满负载运行，有时候测试用例会饥饿导致超时。 某些test可能会出现死锁问题 出现死锁的问题，大概是某些地方解锁或开锁不正确，或者chan一直阻塞没有发送或者接收，还有可能是channel+互斥锁错误混用的问题。后面把一些原来混用的情况，改了一下。 // 避免 chan+mutex 可能发生的死锁问题 kv.mu.Unlock() ch \u003c- term kv.mu.Lock() 但是这个解决方案又会导致下面的问题出现。 偶尔会出现panic: send on closed channel 客户端超时会直接返回并释放资源，这个时候可能由于下面代码锁释放过后，就被资源释放操作拿到锁了。也就是说，可能出现释放chan资源在向chan发送数据之前，所以就可能导致这个问题。 解决的方案有两种： 更强的线性化：保证释放chan资源一定在向chan发送数据之前，这个可能需要添加额外的保证才行了（例如channel）。 直接捕获，按照正常情况处理（我采用的这个，但是这个方案使用-race的话会测试失败，及时recover也会被race检测出来 if ch, ok := kv.wakeClient[index]; ok /*leader唤醒客户端reply*/ { Debug(dClient, \"S%d wakeup client\", kv.me) // 避免chan+mutex可能发生的死锁问题 kv.mu.Unlock() func() /*退栈，确保recover捕获nil chan*/ { d","date":"2023-12-29","objectID":"/mit6.824%E4%B9%8Blab3b/:1:3","tags":["mit6.824"],"title":"Mit6.824之lab3B","uri":"/mit6.824%E4%B9%8Blab3b/"},{"categories":["分布式系统"],"content":"结果 ➜ kvraft git:(main) time go test -race -run 3B Test: InstallSnapshot RPC (3B) ... ... Passed -- 4.2 3 725 63 Test: snapshot size is reasonable (3B) ... ... Passed -- 5.6 3 3036 800 Test: ops complete fast enough (3B) ... ... Passed -- 8.2 3 3422 0 Test: restarts, snapshots, one client (3B) ... ... Passed -- 19.2 5 7162 1066 Test: restarts, snapshots, many clients (3B) ... ... Passed -- 22.3 5 11811 1545 Test: unreliable net, snapshots, many clients (3B) ... ... Passed -- 16.2 5 7496 1070 Test: unreliable net, restarts, snapshots, many clients (3B) ... ... Passed -- 20.3 5 9681 1247 Test: unreliable net, restarts, partitions, snapshots, many clients (3B) ... ... Passed -- 27.9 5 7494 782 Test: unreliable net, restarts, partitions, snapshots, random keys, many clients (3B) ... ... Passed -- 29.1 7 18583 1424 PASS ok 6.5840/kvraft 154.159s go test -race -run 3B 140.72s user 4.55s system 93% cpu 2:34.80 total ","date":"2023-12-29","objectID":"/mit6.824%E4%B9%8Blab3b/:1:4","tags":["mit6.824"],"title":"Mit6.824之lab3B","uri":"/mit6.824%E4%B9%8Blab3b/"},{"categories":["分布式系统"],"content":"lab3A ","date":"2023-12-29","objectID":"/mit6.824%E4%B9%8Blab3a/:1:0","tags":["mit6.824"],"title":"Mit6.824之lab3A","uri":"/mit6.824%E4%B9%8Blab3a/"},{"categories":["分布式系统"],"content":"论文总结 论文里对于客户端的阐述主要集中在第八节，较为简短，提到了以下几点： 真正的实现在mit6.824的第八节课上给了tips，看我后续的翻译 client如何与leader通信的 只有leader才会处理client的请求，如果不是leader的服务器接收到了client的请求，将会把请求进行重定向到leader来处理。（在实现的时候，并没有采取这种策略，主要实现没有实现成功，就直接客户端暴力挨个请求了 需要额外处理leader reply超时 实现线性化语义 线性化语义可以通过前面已经实现的raft底层保证，但是raft并不保证command的不重复，需要在应用层额外保证command（即client Get/Put/Append重复发送的RPC）的不重复性。引入duplicate table实现。 只读操作不记录日志（不要求实现） ","date":"2023-12-29","objectID":"/mit6.824%E4%B9%8Blab3a/:1:1","tags":["mit6.824"],"title":"Mit6.824之lab3A","uri":"/mit6.824%E4%B9%8Blab3a/"},{"categories":["分布式系统"],"content":"实现思路 LEC 8中Lab3A提示的翻译 lab3A交互草图 image-20231212150951790 如果Get或PutRPC timeout了(也就是Call() return false)，client应该怎么处理？ 如果服务端dead或者请求丢失，client re-send即可 如果服务器已经执行了请求，但是reply在网络中丢失了，re-send是有危险的 不好区分上面的两种情况。上面两种情况对于client而言，看起来是一样的(no reply)。如果请求已经被执行过了，那么client仍然需要这个reply 让kvserver 检测重复client的请求。client每次请求都会携带一个唯一ID，并在re-send一个rpc时，携带与上次RPC相同的id。kvserver 维护一个按id索引的\"duplicate table\"，在执行后为每个rpc创建一个条目，用以在\"duplicate table\" 中记录reply。如果第二个rpc以相同的id到达，则它是重复的，可以根据\"duplicate table\"来生成reply。 新的领导者如何获得\"duplicate table\"？ 将 id 放入传递给 Raft 的记录操作中，所有副本都应在执行时更新其table，以便如果它们成为领导者后这些信息依然保留。 如果服务器崩溃，它如何恢复\"duplicate table\"？ 如果没有快照，日志重播将填充\"duplicate table\" 如果有快照，快照必须包含\"duplicate table\"的副本 如果重复请求在原始请求执行之前到达怎么办？ 再次调用Start()，会导致它可能在log中两次。当cmd出现在applyCh上时，如果table里已经有了，就没有必要执行了。 保持table较小的idea 每个client一个条目，而不是每次 RPC 一个条目 每个client只有一次 RPC 没有完成 每个客户端一次只能有一个未完成的RPC，这意味着客户端在发送一个RPC请求之后，必须等待服务器对该请求的响应，才能发送下一个RPC请求。这样可以确保每个客户端一次只有一个RPC请求在处理中，简化了并发控制。 每个client按顺序对 RPC 进行编号 当服务器收到client 第10个RPC 时，它可以忽略client的较低条目，因为这意味着client永远不会重新发送旧的 RPC 一些细节 每个client都需要一个唯一的client id（64位随机数字即可） client需要在每次rpc中发送client id和seq，如果需要re-send，client就携带相同的seq kvserver中按client id索引的table仅包含 seq 和value（如果已执行） RPC 处理程序首先检查table，只有 seq 大于 table 条目的seq才能执行Start() 每个log条目必须包含client id和seq 当operation出现在 applyCh 上时，更新client table条目中的 seq 和 value，唤醒正在等待的 RPC 处理程序（如果有） kvserver可能会返回table中的旧值，但是返回的确实是当前值，没有问题。 C1 C2 -- – put(x,10) first send of get(x), reply(10) dropped put(x,20) re-sends get(x), server gets 10 from table, not 20 get(x) and put(x,20) run concurrently, so could run before or after; so, returning the remembered value 10 is correct client call实现 客户端没啥好说，不断轮询server，直到请求到leader，当然为了区分重复rpc，需要携带客户端标识和rpc重复标识 func (ck *Clerk) Get(key string) string { defer func() { Debug(dGet, \"C%d(Seq %d) -\u003e S%d Get {key:%s}\", ck.clientId, ck.sequenceId, ck.leader, key) }() args := \u0026GetArgs{ Key: key, ClientId: ck.clientId, SequenceId: ck.sequenceId, } ck.sequenceId++ server := ck.leader for { reply := \u0026GetReply{} if ok := ck.servers[server","date":"2023-12-29","objectID":"/mit6.824%E4%B9%8Blab3a/:1:2","tags":["mit6.824"],"title":"Mit6.824之lab3A","uri":"/mit6.824%E4%B9%8Blab3a/"},{"categories":["分布式系统"],"content":"调试过程 labgob warning: Decoding into a non-default variable/field Err may not work问题 这个问题的出现意思是，多个rpc调用了相同的reply。解决方案就是每次发起rpc的时候，新分配一个reply Test: ops complete fast enough (3A) ...用例 该用例测试结果显示Operations completed too slowly 100.000356ms/op \u003e 33.333333ms/op 表示每次操作花费时间过多，其实这个问题刚开始出现我就猜到是哪出现问题了。主要是我在实现底层raft的时候，应用层调用Start后，需要等待到下一次心跳（100ms）才能发送日志同步。所以，应用层调用Start过后不能立即同步日志。解决方案就是在Start中立即开启一致性协议 在Start中加入下面的代码，用以唤醒log replicate go func() { rf.replicateSignal \u003c- struct{}{} }() raft实例启动的时候注册并监听下面的事件驱动 func (rf *Raft) logReplicateEvent() { for rf.killed() == false { select { case \u003c-rf.replicateSignal: rf.mu.Lock() if rf.role == leader { rf.heartbeatBroadcast() rf.electionTimer.Reset(withRandomElectionDuration()) } rf.mu.Unlock() } } } **Test: partitions, one client (3A) …**用例 发现分区过后，rpc一直卡住没有reply，导致整个raft底层和kvserver上层都卡死了9分钟。后面也参考了一些博客，应该引入超时机制避免rpc没有reply，一直卡死的情况。 select { case \u003c-time.After(rpcTimeout): case msgTerm := \u003c-ch /*阻塞等待rpc reply*/ : // todo } ","date":"2023-12-29","objectID":"/mit6.824%E4%B9%8Blab3a/:1:3","tags":["mit6.824"],"title":"Mit6.824之lab3A","uri":"/mit6.824%E4%B9%8Blab3a/"},{"categories":["分布式系统"],"content":"结果 脚本测试过100次，无报错 ➜ kvraft git:(main) go test -race -run 3A Test: one client (3A) ... ... Passed -- 15.2 5 4331 666 Test: ops complete fast enough (3A) ... ... Passed -- 25.1 3 3997 0 Test: many clients (3A) ... ... Passed -- 15.8 5 6663 838 Test: unreliable net, many clients (3A) ... ... Passed -- 16.5 5 5576 751 Test: concurrent append to same key, unreliable (3A) ... ... Passed -- 1.1 3 233 52 Test: progress in majority (3A) ... ... Passed -- 0.4 5 58 2 Test: no progress in minority (3A) ... ... Passed -- 1.0 5 111 3 Test: completion after heal (3A) ... ... Passed -- 1.0 5 67 3 Test: partitions, one client (3A) ... ... Passed -- 22.4 5 4432 541 Test: partitions, many clients (3A) ... ... Passed -- 23.4 5 7680 762 Test: restarts, one client (3A) ... ... Passed -- 19.6 5 6127 693 Test: restarts, many clients (3A) ... ... Passed -- 20.3 5 11905 879 Test: unreliable net, restarts, many clients (3A) ... ... Passed -- 21.1 5 6442 762 Test: restarts, partitions, many clients (3A) ... ... Passed -- 27.5 5 11506 737 Test: unreliable net, restarts, partitions, many clients (3A) ... ... Passed -- 28.4 5 6395 673 Test: unreliable net, restarts, partitions, random keys, many clients (3A) ... ... Passed -- 30.6 7 11251 680 PASS ok 6.5840/kvraft 270.706s ","date":"2023-12-29","objectID":"/mit6.824%E4%B9%8Blab3a/:1:4","tags":["mit6.824"],"title":"Mit6.824之lab3A","uri":"/mit6.824%E4%B9%8Blab3a/"},{"categories":["分布式系统"],"content":"lab2D 到现在实现的最艰难的一个lab ","date":"2023-12-29","objectID":"/mit6.824%E4%B9%8Blab2d/:1:0","tags":["mit6.824"],"title":"Mit6.824之lab2D","uri":"/mit6.824%E4%B9%8Blab2d/"},{"categories":["分布式系统"],"content":"论文总结 直接看论文, 论文算是精华了. ","date":"2023-12-29","objectID":"/mit6.824%E4%B9%8Blab2d/:1:1","tags":["mit6.824"],"title":"Mit6.824之lab2D","uri":"/mit6.824%E4%B9%8Blab2d/"},{"categories":["分布式系统"],"content":"实现思路 lab2D中需要我们实现的东西如下： 实现Snapshot()方法 注意点1：快照点不能超过应用点 该方法由应用层调用，应用层来决定何时对节点进行快照，而测试脚本中是每隔10条日志就进行一次快照。快照时需要注意，在lab2D前面的实现中，是把已提交和已应用的两个阶段通过条件变量分开的，中间这个间隙可能会被快照然后裁减掉未应用未提交甚至已提交的日志，这样可能会少了一些日志。为了保证在快照时，论文中的“已提交的日志一定会被应用到状态机”的特性，在快照时需要判断当前快照点是否超过了应用点，如果没有超过，说明可以快照；如果超过了应用点，就不能裁减log，防止前面提到的问题发生。 注意点2：如果当前快照点小于等于上一次快照点，没有必要快照了 注意点3：持久化的过程中，需要保证最新的快照和最新的raft持久化状态，一起持久化，保证原子性. 这点在persist()方法的注释中有提到。为此我给raft添加了snapshot字段用来表示raft持有的最新快照，调用persist()方法的时候，将快照一并持久化，从而保证原子性。 func (rf *Raft) Snapshot(index int, snapshot []byte) { // Your code here (2D). rf.mu.Lock() defer rf.mu.Unlock() if rf.commitIndex \u003c index /*commit过后才能快照*/ || rf.lastIncludedIndex \u003e= index /*快照点如果小于前一次快照点，没有必要快照*/ { return } // 丢弃被快照了的日志，同时修改其他状态 // last: snap{nil,1,2,3} {nil} // now: snap{nil,1,2,3,4,5} {nil,4,5} split := rf.logIndex(index) rf.lastIncludedIndex = index rf.log = append([]Logt{{Term: rf.log[split].Term}}, rf.log[split+1:]...) rf.snapshot = snapshot rf.persist() } 我在后面修改lab2D bug时，修改了applier的实现，所以这里需要把rf.lastApplied \u003c index修改为rf.commitIndex \u003c index 实现InstallSnapshot()方法 这个方法的时候，论文已经说的很明白了，实现起来问题不大。只是有些coner case可能在实现的时候会与论文说的有差别（这种只有debug了）。lab2D的要求我们去除安装快照的分片实现，只需要单次发送就可以了。这里总结一下实现步骤： 如果term \u003c currentTerm就立即回复（过期leader请求没必要处理） 创建一个新的快照 保存快照文件，丢弃具有较小索引的任何现有或部分快照 这句话的意思是: 比较对等点的快照和leader发过来的安装快照. 要丢弃较小的快照点, 保留最大的快照点. 如果现存的日志条目与快照中最后包含的日志条目具有相同的索引值和任期号，则保留其后的日志条目并进行回复 这句话的意思是: 可能包含了leader的安装快照之后的新的状态变化，我们需要保留这些, 并且return.（中文翻译的bug…qwq，不注意看可能会理解错误） 丢弃整个日志 如果在第4步没有return的话, 说明现存的日志条目与快照中最后不包含的日志条目具有相同的索引值和任期号, 也就是说, 当前log是过期的. 没有必要留存,直接删除掉 使用快照重置状态机（并加载快照的集群配置） 除了论文和lab tips中的实现点以外，还有一些小的coner case需要注意： leader安装快照的过程请求了对等点, 算是一次ping/pong, 可以刷新选举计时器以及重新置为follower 如果对等点任期落后, 那么依然可以继续后面的步骤, 但是需要重置旧任期的选票和更新任期 使用Copy-on-Write的技术优化 注意lastIncludedIndex一定要在使用旧的lastIncludedIndex过后更新 func (rf *Raft) InstallSnapshot(args *InstallSnapshotArgs, reply *InstallSnapshotReply) { rf.mu.Lock() defer rf.mu.Unlock() //1. 如果`term \u003c currentTerm`就立即回复 if args.Term \u003c rf.currentTerm /*请求的领导者过期了，不能安装过期leader的快照*/ { reply.T","date":"2023-12-29","objectID":"/mit6.824%E4%B9%8Blab2d/:1:2","tags":["mit6.824"],"title":"Mit6.824之lab2D","uri":"/mit6.824%E4%B9%8Blab2d/"},{"categories":["分布式系统"],"content":"调试过程 调试test 1 我把初版代码写完的时候，所有测试用例都没有过（偶尔会有一次过test 1）。后面改了日志打印信息，主要减少了一些不要信息的输出，例如对于日志我们不关心具体是什么，只关心复制到哪了，所以只需要打印相关索引信息即可。 当然，后面也封装了对下标的操作，这样问题也好排查，代码也更好修改。然后，在日志中看到了：当集群所有节点的日志全部快照了，也就是说快照裁减的日志没有剩下的特殊情况，nextIndex出现了回退现象。 034063 LOG1 before sendAppendEntries S0, nextIndex:190 matchIndex:189 034064 LOG1 after sendAppendEntries S0, nextIndex:189 matchIndex:189 034071 LOG1 before sendAppendEntries S1, nextIndex:190 matchIndex:189 034072 LOG1 after sendAppendEntries S1, nextIndex:189 matchIndex:189 非常令人匪夷所思的bug，然后我在前面的日志中发现，leader发送日志复制rpc，但是follower并没有复制成功，至此问题定位到了：应该是有个地方的边界情况没有考虑到。下面是关键代码，优化nextIndex定位的部分逻辑。 /*冲突：该条目的任期在 prevLogIndex，上不能和 prevLogTerm 匹配上，则返回假*/ index := rf.logIndex(args.PrevLogIndex) if rf.log[index].Term != args.PrevLogTerm { // 从后往前找冲突条目，返回最小冲突条目的索引 conflictIndex, conflictTerm := -1, rf.log[index].Term for i := args.PrevLogIndex; i \u003e rf.commitIndex; i-- { if rf.log[rf.logIndex(i)].Term != conflictTerm { break } conflictIndex = i } reply.XTerm, reply.XIndex, reply.XLen = conflictTerm, conflictIndex, rf.realLogLen() reply.Term, reply.Success = rf.currentTerm, false return } 因为集群中所有节点的情况一致，也就是PrevLogIndex和lastIncludedIndex的值是一样的， 所以就会出现rf.log[0].Term != args.PrevLogTerm的情况，进而日志复制失败，nextIndex回退的问题。 修复的方式有两种：一种是额外处理相等情况；还有一种方法就是，每次快照的时候初始化rf.log[0].Term为lastIncludedTerm即可。我采用的是第二种。采用第二种方案就不需要raft中暂存lastIncludedTerm了 调试test 2 经过好几天的debug，终于把前面的test 1测试通过，但是在test 2的时候，总是遇到另一个比较奇怪的问题。 1: log map[0:\u003cnil\u003e 1:5926928346377738245 2:5899418714642564734 3:2523416114670145493 4:2645763998966155741 5:8669075945120996169 6:7089836692553293889 7:4329587389170088629 8:2003073101149869281 9:3121819971269749612]; server map[1:5926928346377738245 2:5899418714642564734 3:2523416114670145493 4:2645763998966155741 5:8669075945120996169 6:7089836692553293889 7:4329587389170088629 8:2003073101149869281 9:3121819971269749612 10:651793884186508261 11:6297140580147973579 12:7722938942633659376 13:4482676451686048456 14:2481212667518606188] apply error: commit index=10 server=1 592","date":"2023-12-29","objectID":"/mit6.824%E4%B9%8Blab2d/:1:3","tags":["mit6.824"],"title":"Mit6.824之lab2D","uri":"/mit6.824%E4%B9%8Blab2d/"},{"categories":["分布式系统"],"content":"结果 ➜ raft git:(main) VERBOSE=0 go test -race -run 2D Test (2D): snapshots basic ... Passed -- real time: 4.1 number of Raft peers:3 number of RPC sends: 148 number of bytes: 51216 number of Raft agreements reported: 211 Test (2D): install snapshots (disconnect) ... Passed -- real time:40.5 number of Raft peers:3 number of RPC sends:1752 number of bytes: 653103 number of Raft agreements reported: 351 Test (2D): install snapshots (disconnect+unreliable) ... Passed -- real time:44.5 number of Raft peers:3 number of RPC sends:1926 number of bytes: 694404 number of Raft agreements reported: 318 Test (2D): install snapshots (crash) ... Passed -- real time:29.1 number of Raft peers:3 number of RPC sends:1048 number of bytes: 403904 number of Raft agreements reported: 271 Test (2D): install snapshots (unreliable+crash) ... Passed -- real time:32.9 number of Raft peers:3 number of RPC sends:1162 number of bytes: 515722 number of Raft agreements reported: 345 Test (2D): crash and restart all servers ... Passed -- real time: 7.4 number of Raft peers:3 number of RPC sends: 240 number of bytes: 69192 number of Raft agreements reported: 49 Test (2D): snapshot initialization after crash ... Passed -- real time: 2.5 number of Raft peers:3 number of RPC sends: 78 number of bytes: 21956 number of Raft agreements reported: 14 PASS ok 6.5840/raft 162.070s Lab2的运行结果 目前测试过百次，没有任何报错。 ➜ raft git:(main) time VERBOSE=0 go test -race -run 2 Test (2A): initial election ... Passed -- real time: 3.1 number of Raft peers:3 number of RPC sends: 60 number of bytes: 16534 number of Raft agreements reported: 0 Test (2A): election after network failure ... Passed -- real time: 4.4 number of Raft peers:3 number of RPC sends: 120 number of bytes: 24380 number of Raft agreements reported: 0 Test (2A): multiple elections ... Passed -- real time: 5.5 number of Raft peers:7 number of RPC sends: 612 number of bytes: 122330 number of Raft agreements reported: 0 Test (2B): basic agreement ... Passed -- real ti","date":"2023-12-29","objectID":"/mit6.824%E4%B9%8Blab2d/:1:4","tags":["mit6.824"],"title":"Mit6.824之lab2D","uri":"/mit6.824%E4%B9%8Blab2d/"},{"categories":["分布式系统"],"content":"lab2C ","date":"2023-12-29","objectID":"/mit6.824%E4%B9%8Blab2c/:1:0","tags":["mit6.824"],"title":"Mit6.824之lab2C","uri":"/mit6.824%E4%B9%8Blab2c/"},{"categories":["分布式系统"],"content":"论文总结 见前文lab2B ","date":"2023-12-29","objectID":"/mit6.824%E4%B9%8Blab2c/:1:1","tags":["mit6.824"],"title":"Mit6.824之lab2C","uri":"/mit6.824%E4%B9%8Blab2c/"},{"categories":["分布式系统"],"content":"实现思路 lab2C的实现较为简单，会出现问题大多数便是lab2A或者lab2B某些地方实现的可能有问题而导致。这一点在lab2C的指引里也说得很明确。 只需要在raft实例任期、日志或投票发生变化时，才需要持久化。重启的时候，在将以前的状态重新读取出来即可。 当然，lab2C还要求了优化lab2B中nextIndex的定位方法，但是lab2C给了如何做这件事情的方法，实现起来也不难。如下： AppendEntries RPC的额外处理 if len(rf.log) \u003c= args.PrevLogIndex /*可能rf过期，领导者已经应用了很多日志*/ { //这种情况下，该raft实例断网一段时间过后，日志落后。所以直接返回 XLen即可。 //leader更新nextIndex为XLen即可，表示当前raft实例缺少XLen及后面的日志，leader在下次广播时带上这些日志 // leader 0{0} 1{101 102 103} 5{104} PrevLogIndex=3 nextIndex=4 // follower 0{0} 1{101 102 103} 5{104} PrevLogIndex=3 nextIndex=4 // follower 0{0} 1{101} 5 PrevLogIndex=1 nextIndex=1 reply.XTerm, reply.XIndex, reply.XLen = -1, -1, len(rf.log) reply.Term, reply.Success = rf.currentTerm, false return } if rf.log[args.PrevLogIndex].Term != args.PrevLogTerm /*冲突：该条目的任期在 prevLogIndex，上不能和 prevLogTerm 匹配上，则返回假*/ { // 从后往前找冲突条目，返回最小冲突条目的索引 // 这种情况较为复杂了，可以参考论文figure 7中的日志情况，对照看便知道为什么是返回最小冲突条目的索引了 conflictIndex, conflictTerm := -1, rf.log[args.PrevLogIndex].Term for i := args.PrevLogIndex; i \u003e rf.commitIndex; i-- { if rf.log[i].Term != conflictTerm { break } conflictIndex = i } reply.XTerm, reply.XIndex, reply.XLen = conflictTerm, conflictIndex, len(rf.log) reply.Term, reply.Success = rf.currentTerm, false return } leader定时发送心跳后请求失败的处理 // 快速定位nextIndex if reply.XTerm == -1 \u0026\u0026 reply.XIndex == -1 { /*Case 3: follower's log is too short*/ rf.nextIndex[peer] = reply.XLen return } ok := false for i, entry := range rf.log { /*Case 2: leader has XTerm*/ if i == 0 /*skip 0 index*/ { continue } if entry.Term == reply.XTerm { ok = true rf.nextIndex[peer] = rf.realIndex(i) + 1 } } if !ok { /*Case 1: leader doesn't have XTerm*/ rf.nextIndex[peer] = reply.XIndex } ","date":"2023-12-29","objectID":"/mit6.824%E4%B9%8Blab2c/:1:2","tags":["mit6.824"],"title":"Mit6.824之lab2C","uri":"/mit6.824%E4%B9%8Blab2c/"},{"categories":["分布式系统"],"content":"调试过程 某些地方由于没有做索引检测，导致有些地方在lab2C测试的时候会发生索引越界。下面是心跳请求AppendEntriesRPC参数的索引校验与矫正 /*解决高并发场景下lab2C里索引越界的问题*/ if args.PrevLogIndex \u003e= 0 \u0026\u0026 args.PrevLogIndex \u003c len(rf.log) { args.PrevLogTerm = rf.log[args.PrevLogIndex].Term } else { args.PrevLogIndex = 0 } if rf.nextIndex[peer] \u003c 1 { rf.nextIndex[peer] = 1 } ","date":"2023-12-29","objectID":"/mit6.824%E4%B9%8Blab2c/:1:3","tags":["mit6.824"],"title":"Mit6.824之lab2C","uri":"/mit6.824%E4%B9%8Blab2c/"},{"categories":["分布式系统"],"content":"结果 测试总数大于100次，没有出现错误 ➜ raft git:(main) VERBOSE=0 go test -race -run 2C Test (2C): basic persistence ... Passed -- real time: 3.7 number of Raft peers:3 number of RPC sends: 130 number of bytes: 33758 number of Raft agreements reported: 6 Test (2C): more persistence ... Passed -- real time:15.6 number of Raft peers:5 number of RPC sends:1504 number of bytes: 345974 number of Raft agreements reported: 16 Test (2C): partitioned leader and one follower crash, leader restarts ... Passed -- real time: 1.9 number of Raft peers:3 number of RPC sends: 50 number of bytes: 13015 number of Raft agreements reported: 4 Test (2C): Figure 8 ... Passed -- real time:31.3 number of Raft peers:5 number of RPC sends:1404 number of bytes: 304750 number of Raft agreements reported: 32 Test (2C): unreliable agreement ... Passed -- real time: 3.4 number of Raft peers:5 number of RPC sends: 240 number of bytes: 82111 number of Raft agreements reported: 246 Test (2C): Figure 8 (unreliable) ... Passed -- real time:40.8 number of Raft peers:5 number of RPC sends:6528 number of bytes:10275196 number of Raft agreements reported: 112 Test (2C): churn ... Passed -- real time:16.3 number of Raft peers:5 number of RPC sends:1276 number of bytes:1078803 number of Raft agreements reported: 717 Test (2C): unreliable churn ... Passed -- real time:16.2 number of Raft peers:5 number of RPC sends:1092 number of bytes:1240526 number of Raft agreements reported: 290 PASS ok 6.5840/raft 130.406s ","date":"2023-12-29","objectID":"/mit6.824%E4%B9%8Blab2c/:1:4","tags":["mit6.824"],"title":"Mit6.824之lab2C","uri":"/mit6.824%E4%B9%8Blab2c/"},{"categories":["分布式系统"],"content":"lab2B ","date":"2023-12-29","objectID":"/mit6.824%E4%B9%8Blab2b/:1:0","tags":["mit6.824"],"title":"Mit6.824之lab2B","uri":"/mit6.824%E4%B9%8Blab2b/"},{"categories":["分布式系统"],"content":"论文回顾与总结 原论文比较晦涩，有些地方没有读懂，这里摘抄的B战某up主视频的进一步解释。解读共识算法Raft（3）日志复制 客户端如何定位leader leader被选举出来后，开始为客户端提供服务，而其他节点接收到客户端请求时需要将请求转向leader。客户端如何如何请求leader呢？ 第一种情况，请求的节点刚好是leader，则直接成功请求然后进入日志复制和提交状态机的后续工作 第二种情况，请求的节点是follower，follower可以通过心跳得知leader节点的id，然后告知客户端 第三种情况，请求的节点处于宕机，无法产生响应，那么客户端再去请求其他节点 日志结构 leader接收到客户端的指令后，会把指令作为一个新的条目追加到日志里去。一条日志含有三个信息： 状态机指令 leader任期号 任期号是raft状态机的逻辑时钟，用于判定节点状态和校验日志是否过期 日志索引 单调递增。如果leader宕机了，那么可能存在日志号相同的情况下，内容不同 需要任期号和日志索引才能唯一确定一条日志 日志复制 leader并行发送AppendEntriesRPC给follower，让它们复制该条目，当该条目被超过半数以上的follower复制过后，leader就可以在本地执行该指令并把结果返回给客户端。 本地执行指令，也就是leader应用日志到状态机这一步，被称为提交 上面的机制，在leader和follower都能正常运行的情况下，raft能正常工作。但是在分布式场景下，难免会发生一些故障问题，raft需要保证在有宕机的情况下继续支持日志复制，并且保证每个副本日志顺序的一致性。具体有三种可能： 如果有follower因为某些原因没有给leader响应，那么leader会不断地重发追加条目请求（AppendEntries RPC），哪怕leader已经没有了响应 如果有follower崩溃后恢复，这是raft追加条目的一致性检查生效，保证follower能按顺序恢复崩溃后缺失的日志 raft的一致性检查：leader在每一个发往follower的追加条目RPC中，会放入前一个日志条目的索引位置和任期号，如果follower在它的日志中找不到前一个日志，那么它就会拒绝此日志，leader收到follower的拒接后，会发送前一个日志条目，从而逐渐向前定位到follower第一个缺失的日志，然后按照顺序补齐follower缺失的所有日志 当附加日志 RPC 的请求被拒绝的时候，跟随者可以(返回)冲突条目的任期号和该任期号对应的最小索引地址。 如果leader崩溃，那么崩溃的leader可能已经复制了日志到部分follower但还没有提交而被选出的新leader又可能不具备这些日志，这样就有部分follower中的日志和新leader的日志不相同。 raft会在这种情况下，leader通过强制follower复制它的日志来解决不一致的问题，这意味着follower中跟leader冲突的日志条目会被新leader的日志条目覆盖。 当然，由于这些日志没有提交，也就是没有应用到raft状态机里，不违背一致性。 总结 通过这种机制，leader在当权之后就不需要任何特殊的操作来使日志恢复一致性 leader只需要进行正常的操作，然后日志就能在回复AppendEntries一致性检查失败的时候自动趋于一致 leader从来不会覆盖或删除自己的日志条目 只要过半的节点能正常运行，raft就能接受、复制并应用新的日志条目 在正常情况下，新的日志条目可以在一个RPC来回中被复制给集群中过半的机器 单个运行慢的follower不会影响整体的性能（超过半数就可以提交日志并返回客户端了） ","date":"2023-12-29","objectID":"/mit6.824%E4%B9%8Blab2b/:1:1","tags":["mit6.824"],"title":"Mit6.824之lab2B","uri":"/mit6.824%E4%B9%8Blab2b/"},{"categories":["分布式系统"],"content":"实现思路 最主要实现几个关键的地方： 选举限制 投票时一定只能投给日志至少和自己一样新的。当集群中超过半数的节点复制了日志，被称为已提交，已提交的日志一定会被应用到状态机里。因为没有获得最新日志的节点无法获得超过半数节点的投票，也就无法成为领导者，所以，领导者的日志只要已经提交，那么就算当前领导者退位，重新选举的领导者一定具备最新的日志。 // 论文里安全性的保证：参数的日志是否至少和自己一样新 func (rf *Raft) isLogUpToDate(lastLogTerm, lastLogIndex int) bool { return lastLogTerm \u003e rf.lastLogTerm() || (lastLogTerm == rf.lastLogTerm() \u0026\u0026 lastLogIndex \u003e= rf.lastLogIndex()) } 心跳和日志复制应该是同一个实现 最开始的时候，我是在Start方法里添加一致性协议的额外操作：开启额外的协程去做日志复制。但是我后面发现日志复制和心跳的实现逻辑差不多，而且就算含有日志的AppendEntriesRPC其实也可以算上一次心跳。而且周期地心跳的发送也有助于日志尽快地被复制到其他节点（看了一些网上的实现过后，便将心跳和日志复制整合到一起了。） func (rf *Raft) heartbeatBroadcast() { Debug(dTimer, \"S%d start broadcast\", rf.me) n := len(rf.peers) for peer := 0; peer \u003c n; peer++ { if peer == rf.me { continue } args := \u0026AppendEntriesArgs{ Term: rf.currentTerm, LeaderId: rf.me, Entries: make([]Logt, 0), PrevLogIndex: rf.nextIndex[peer] - 1, PrevLogTerm: rf.log[rf.nextIndex[peer]-1].Term, LeaderCommit: rf.commitIndex, } args.Entries = append(args.Entries, rf.log[rf.nextIndex[peer]:]...) go func(peer int) { reply := \u0026AppendEntriesReply{} Debug(dLog, `sendAppendEntries S%d -\u003e S%d, args %+v`, rf.me, peer, args) if ok := rf.sendAppendEntries(peer, args, reply); ok { rf.mu.Lock() defer rf.mu.Unlock() defer func() { Debug(dLog, `after sendAppendEntries S%d, nextIndex:%d matchIndex:%d`, peer, rf.nextIndex[peer], rf.matchIndex[peer]) }() Debug(dLog, `before sendAppendEntries S%d, nextIndex:%d matchIndex:%d`, peer, rf.nextIndex[peer], rf.matchIndex[peer]) if rf.role != leader { /*不是leader，没有必要在进行广播*/ return } if reply.Term \u003e rf.currentTerm { /*过期该返回*/ rf.changeRole(follower) rf.currentTerm = reply.Term return } if reply.Success { /*心跳成功或日志复制成功*/ rf.matchIndex[peer] = args.PrevLogIndex + len(args.Entries) rf.nextIndex[peer] = rf.matchIndex[peer] + 1 /*超过半数节点追加成功，也就是已提交，并且还是leader，那么就可以应用当前任期里的日志到状态机里。找到共识N：遍历对等点，找到相同的N*/ N := rf.commitIndex for _N := rf.commitIndex + 1; _N \u003c len(rf.log); _N++ { succeedNum := 0 for peer := 0; peer \u003c n; peer++ { if _N \u003c= rf.matchIndex[peer]","date":"2023-12-29","objectID":"/mit6.824%E4%B9%8Blab2b/:1:2","tags":["mit6.824"],"title":"Mit6.824之lab2B","uri":"/mit6.824%E4%B9%8Blab2b/"},{"categories":["分布式系统"],"content":"调试过程 调试过程中遇到了一些问题。 集群某节点断网一段时间后恢复网络，并且选举出新的leader时，集群中的新日志明明已经复制到了超过半数节点，但是还是无法提交日志。 通过排查日志发现，重新选举过后，我是按照论文里的把所有节点的nextIndex和matchIndex重新初始化为领导人最后的日志条目的索引+1和0。但是，由于领导者AppendEntriesRPC广播时，并不会对自己广播，所以只会去更新跟随者的nextIndex和matchIndex。所以，就导致了集群中节点matchIndex无法在commitIndex上达成大多数，所以就迟迟无法提交。而且，领导者持有最新日志，nextIndex和matchIndex应该初始化为len(rf.log)和len(rf.log) - 1 only 2 decided for index 6; wanted 3表示在索引3处，只有两个server apply，还差一个server没有apply。 在做lab4A前大量测试测出来的bug 为什么会出现这种情况呢？思考在极端并发下，下面代码会出现什么情况 // 将已提交的日志应用到状态机里。 // 注意：防止日志被应用状态机之前被裁减掉，也就是说，一定要等日志被应用过后才能被裁减掉。 func (rf *Raft) applierEvent() { for rf.killed() == false { rf.mu.Lock() rf.cond.Wait() // 等待signal唤醒 msgs := make([]ApplyMsg, 0, rf.commitIndex-rf.lastApplied) for i := rf.lastApplied + 1; i \u003c= rf.commitIndex; i++ { msgs = append(msgs, ApplyMsg{ CommandValid: true, Command: rf.log[rf.logIndex(i)].Command, CommandIndex: i, CommandTerm: rf.log[rf.logIndex(i)].Term, }) rf.lastApplied++ } rf.mu.Unlock() for _, msg := range msgs { rf.applyMsg \u003c- msg } } } 上面的代码在极高并发下，会有这样一个bug：在我们唤醒等待并且释放锁过后，如果此时还有日志提交并调用signal那么这个时候会丢掉这次唤醒（唤醒失败），所以上面的写法在极高并发下是有问题的。因为必须在下一次唤醒才能把上一次丢掉的唤醒恢复。 解决方案： 不再使用applier协程。需要提交的时候直接调用apply及时应用日志，避免唤醒的丢失（不那么优雅 按照条件变量正确用法使用，可以避免丢失唤醒和虚假唤醒问题 // 将已提交的日志应用到状态机里。 // 注意：防止日志被应用状态机之前被裁减掉，也就是说，一定要等日志被应用过后才能被裁减掉。 func (rf *Raft) applierEvent() { for rf.killed() == false { rf.mu.Lock() for rf.commitIndex \u003c= rf.lastApplied /*防止虚假唤醒*/ { rf.cond.Wait() } msgs := make([]ApplyMsg, 0, rf.commitIndex-rf.lastApplied) for i := rf.lastApplied + 1; i \u003c= rf.commitIndex; i++ { msgs = append(msgs, ApplyMsg{ CommandValid: true, Command: rf.log[rf.logIndex(i)].Command, CommandIndex: i, CommandTerm: rf.log[rf.logIndex(i)].Term, }) rf.lastApplied++ } rf.mu.Unlock() for _, msg := range msgs { rf.applyMsg \u003c- msg } } } ","date":"2023-12-29","objectID":"/mit6.824%E4%B9%8Blab2b/:1:3","tags":["mit6.824"],"title":"Mit6.824之lab2B","uri":"/mit6.824%E4%B9%8Blab2b/"},{"categories":["分布式系统"],"content":"结果 脚本测试了3000次 ➜ raft git:(main) VERBOSE=0 go test -race -run 2B Test (2B): basic agreement ... Passed -- real time: 1.1 number of Raft peers:3 number of RPC sends: 16 number of bytes: 4028 number of Raft agreements reported: 3 Test (2B): RPC byte count ... Passed -- real time: 2.6 number of Raft peers:3 number of RPC sends: 50 number of bytes: 113152 number of Raft agreements reported: 11 Test (2B): test progressive failure of followers ... Passed -- real time: 4.9 number of Raft peers:3 number of RPC sends: 124 number of bytes: 25386 number of Raft agreements reported: 3 Test (2B): test failure of leaders ... Passed -- real time: 5.4 number of Raft peers:3 number of RPC sends: 191 number of bytes: 40897 number of Raft agreements reported: 3 Test (2B): agreement after follower reconnects ... Passed -- real time: 6.2 number of Raft peers:3 number of RPC sends: 129 number of bytes: 31350 number of Raft agreements reported: 8 Test (2B): no agreement if too many followers disconnect ... Passed -- real time: 3.9 number of Raft peers:5 number of RPC sends: 218 number of bytes: 43500 number of Raft agreements reported: 3 Test (2B): concurrent Start()s ... Passed -- real time: 0.6 number of Raft peers:3 number of RPC sends: 8 number of bytes: 2012 number of Raft agreements reported: 6 Test (2B): rejoin of partitioned leader ... Passed -- real time: 6.2 number of Raft peers:3 number of RPC sends: 180 number of bytes: 41682 number of Raft agreements reported: 4 Test (2B): leader backs up quickly over incorrect follower logs ... Passed -- real time:33.3 number of Raft peers:5 number of RPC sends:3500 number of bytes:2111589 number of Raft agreements reported: 104 Test (2B): RPC counts aren't too high ... Passed -- real time: 2.4 number of Raft peers:3 number of RPC sends: 44 number of bytes: 11512 number of Raft agreements reported: 12 PASS ok 6.5840/raft 67.725s ","date":"2023-12-29","objectID":"/mit6.824%E4%B9%8Blab2b/:1:4","tags":["mit6.824"],"title":"Mit6.824之lab2B","uri":"/mit6.824%E4%B9%8Blab2b/"},{"categories":["分布式系统"],"content":"lab2A ","date":"2023-12-29","objectID":"/mit6.824%E4%B9%8Blab2a/:1:0","tags":["mit6.824"],"title":"Mit6.824之lab2A","uri":"/mit6.824%E4%B9%8Blab2a/"},{"categories":["分布式系统"],"content":"论文回顾 去除原论文中不是lab2A描述 Raft 是一种用来管理章节 2 中描述的复制日志的算法。图 2 为了参考之用，总结这个算法的简略版本，图 3列举了这个算法的一些关键特性。图中的这些元素会在剩下的章节逐一介绍。 Raft 通过选举一个杰出的领导人，然后给予他全部的管理复制日志的责任来实现一致性。领导人从客户端接收日志条目（log entries），把日志条目复制到其他服务器上，并告诉其他的服务器什么时候可以安全地将日志条目应用到他们的状态机中。拥有一个领导人大大简化了对复制日志的管理。例如，领导人可以决定新的日志条目需要放在日志中的什么位置而不需要和其他服务器商议，并且数据都从领导人流向其他服务器。一个领导人可能会发生故障，或者和其他服务器失去连接，在这种情况下一个新的领导人会被选举出来。 通过领导人的方式，Raft 将一致性问题分解成了三个相对独立的子问题，这些问题会在接下来的子章节中进行讨论： 领导选举：当现存的领导人发生故障的时候, 一个新的领导人需要被选举出来（章节 5.2） 日志复制：领导人必须从客户端接收日志条目（log entries）然后复制到集群中的其他节点，并强制要求其他节点的日志和自己保持一致。 安全性：在 Raft 中安全性的关键是在图 3 中展示的状态机安全：如果有任何的服务器节点已经应用了一个确定的日志条目到它的状态机中，那么其他服务器节点不能在同一个日志索引位置应用一个不同的指令。章节 5.4 阐述了 Raft 算法是如何保证这个特性的；这个解决方案涉及到选举机制（5.2 节）上的一个额外限制。 状态： 所有服务器上的持久性状态 (在响应 RPC 请求之前，已经更新到了稳定的存储设备) 参数 解释 currentTerm 服务器已知最新的任期（在服务器首次启动时初始化为0，单调递增） votedFor 当前任期内收到选票的 candidateId，如果没有投给任何候选人 则为空 log[] 日志条目；每个条目包含了用于状态机的命令，以及领导人接收到该条目时的任期（初始索引为1） 所有服务器上的易失性状态 参数 解释 commitIndex 已知已提交的最高的日志条目的索引（初始值为0，单调递增） lastApplied 已经被应用到状态机的最高的日志条目的索引（初始值为0，单调递增） 领导人（服务器）上的易失性状态 (选举后已经重新初始化) 参数 解释 nextIndex[] 对于每一台服务器，发送到该服务器的下一个日志条目的索引（初始值为领导人最后的日志条目的索引+1） matchIndex[] 对于每一台服务器，已知的已经复制到该服务器的最高日志条目的索引（初始值为0，单调递增） 追加条目（AppendEntries）RPC： 由领导人调用，用于日志条目的复制，同时也被当做心跳使用 参数 解释 term 领导人的任期 leaderId 领导人 ID 因此跟随者可以对客户端进行重定向（译者注：跟随者根据领导人 ID 把客户端的请求重定向到领导人，比如有时客户端把请求发给了跟随者而不是领导人） prevLogIndex 紧邻新日志条目之前的那个日志条目的索引 prevLogTerm 紧邻新日志条目之前的那个日志条目的任期 entries[] 需要被保存的日志条目（被当做心跳使用时，则日志条目内容为空；为了提高效率可能一次性发送多个） leaderCommit 领导人的已知已提交的最高的日志条目的索引 返回值 解释 term 当前任期，对于领导人而言 它会更新自己的任期 success 如果跟随者所含有的条目和 prevLogIndex 以及 prevLogTerm 匹配上了，则为 true 接收者的实现： 返回假 如果领导人的任期小于接收者的当前任期（译者注：这里的接收者是指跟随者或者候选人）（5.1 节） 请求投票（RequestVote）RPC： 由候选人负责调用用来征集选票（5.2 节） 参数 解释 term 候选人的任期号 candidateId 请求选票的候选人的 ID lastLogIndex 候选人的最后日志条目的索引值 lastLogTerm 候选人最后日志条目的任期号 返回值 解释 term 当前任期号，以便于候选人去更新自己的任期号 voteGranted 候选人赢得了此张选票时为真 接收者实现： 如果term \u003c currentTerm返回 false （5.2 节） 如果 votedFor 为空或者为 candidateId，并且候选人的日志至少和自己一样新，那么就投票给他（5.2 节，5.4 节） 所有服务器需遵守的规则： 所有服务器： 如果接收到的 RPC 请求或响应中，任期号T \u003e currentTerm，则令 currentTerm = T，并切换为跟随者","date":"2023-12-29","objectID":"/mit6.824%E4%B9%8Blab2a/:1:1","tags":["mit6.824"],"title":"Mit6.824之lab2A","uri":"/mit6.824%E4%B9%8Blab2a/"},{"categories":["分布式系统"],"content":"实现思路 Lab2A只需要实现心跳、请求投票、定时任务。 心跳 领导人任期内需要向其他所有对等点（候选者和跟随者）发送AppendEntriesRPC以重置选举超时器，维护自己的权威，以防止其他节点进入选举。 除了任期内，领导人需要周期性地对所有对等点广播心跳以外，在领导人被选举出来的一刻也应该对所有对等点发送广播（这里就不等待定时任务到来才进行广播了，可能存在一定的时延导致某些节点无法收到，从而延长多次选举周期） 实现 接受者（可能是跟随者，也可能是候选者）收到心跳后，首先判断是否可以接收请求，如果可以更换为跟随者并刷新选举超时计时器。 // rf是跟随者或者候选人 func (rf *Raft) AppendEntries(args *AppendEntriesArgs, reply *AppendEntriesReply) { rf.mu.Lock() defer rf.mu.Unlock() defer func() { Debug(dInfo, \"after called AppendEntries S%d status{currentTerm:%d,role:%s,log:%v,lastApplied:%d,commitIndex:%d}\", rf.me, rf.currentTerm, rf.role.String(), rf.log, rf.lastApplied, rf.commitIndex) }() Debug(dInfo, \"before called AppendEntries S%d status{currentTerm:%d,role:%s,log:%v,lastApplied:%d,commitIndex:%d}\", rf.me, rf.currentTerm, rf.role.String(), rf.log, rf.lastApplied, rf.commitIndex) if args.Term \u003c rf.currentTerm { /*请求的leader任期落后了，leader会变成follower，应该拒绝请求*/ reply.Term, reply.Success = rf.currentTerm, false return } // 刷新选举超时器 rf.changeRole(follower) rf.electionTimer.Reset(withRandomElectionDuration()) Debug(dInfo, \"S%d -\u003e S%d heartbeat, S%d reset election timer\", args.LeaderId, rf.me, rf.me) } 请求者异步并发发送请求RPC即可 论文中提到：如果对等点没有响应，那就一直请求直到响应，但是这在某些情况可能会造成内存泄漏，例如集群中某个follower一直处于下线状态，那么这段时期的所有RPC都存在并且随着任期增加，而GC赶不上内存分配的速度，那么可能会存在内存泄漏的问题 可以酌情考虑配置一定的重试次数，超过次数过后报警 func (rf *Raft) heartbeatBroadcast() { Debug(dInfo, \"S%d start heartbeat broadcast\", rf.me) n := len(rf.peers) for i := 0; i \u003c n; i++ { if i == rf.me { /*skip self*/ continue } args := \u0026AppendEntriesArgs{ Term: rf.currentTerm, LeaderId: rf.me, PrevLogIndex: len(rf.log) - 1, PrevLogTerm: rf.log[len(rf.log)-1].Term, LeaderCommit: rf.commitIndex, } // 异步发送 go func(peer int) { reply := \u0026AppendEntriesReply{} if ok := rf.sendAppendEntries(peer, args, reply); !ok { return } rf.mu.Lock() defer rf.mu.Unlock() if reply.Term \u003e rf.currentTerm { rf.currentTerm = reply.Term rf.changeRole(follower) } }(i) } } 请求投票 成为候选者，就会广播投票请求 如果是广播到候选者时，不会收到选票，因为i候选者已经给自己投票了 接收者 如果接受者任期较大时，请求无效 如果接收者任期较小时，接收者切换为follower，","date":"2023-12-29","objectID":"/mit6.824%E4%B9%8Blab2a/:1:2","tags":["mit6.824"],"title":"Mit6.824之lab2A","uri":"/mit6.824%E4%B9%8Blab2a/"},{"categories":["分布式系统"],"content":"结果 ➜ raft git:(main) VERBOSE=0 go test -race -run 2A Test (2A): initial election ... Passed -- real time: 3.1 number of Raft peers:3 number of RPC sends: 60 number of bytes: 15050 number of Raft agreements reported: 0 Test (2A): election after network failure ... Passed -- real time: 4.6 number of Raft peers:3 number of RPC sends: 139 number of bytes: 26141 number of Raft agreements reported: 0 Test (2A): multiple elections ... Passed -- real time: 5.5 number of Raft peers:7 number of RPC sends: 675 number of bytes: 123169 number of Raft agreements reported: 0 PASS ok 6.5840/raft 14.281s ","date":"2023-12-29","objectID":"/mit6.824%E4%B9%8Blab2a/:1:3","tags":["mit6.824"],"title":"Mit6.824之lab2A","uri":"/mit6.824%E4%B9%8Blab2a/"},{"categories":["折腾日记"],"content":"使用github action构建自动交付与持续集成，algolia构建全文搜索引擎 ","date":"2023-12-28","objectID":"/%E4%B8%BB%E9%A2%98%E8%BF%81%E7%A7%BB-2023-12-28/:0:0","tags":[],"title":"主题迁移 2023-12-28","uri":"/%E4%B8%BB%E9%A2%98%E8%BF%81%E7%A7%BB-2023-12-28/"},{"categories":["折腾日记"],"content":"主题shortcodes报错未找到 本地部署生效，但是vercel部署失效，主要原因是vercel的hugo默认版本太老了，需要手动指定HUGO_VERSION环境变量，启用支持shortcodes等的版本。 ","date":"2023-12-28","objectID":"/%E4%B8%BB%E9%A2%98%E8%BF%81%E7%A7%BB-2023-12-28/:0:1","tags":[],"title":"主题迁移 2023-12-28","uri":"/%E4%B8%BB%E9%A2%98%E8%BF%81%E7%A7%BB-2023-12-28/"},{"categories":["折腾日记"],"content":"画廊失效 Note 针对markdown，需要严格使用下面的语法，不能取空，否则无效了。 ![name](${url} \"description\") ","date":"2023-12-28","objectID":"/%E4%B8%BB%E9%A2%98%E8%BF%81%E7%A7%BB-2023-12-28/:0:2","tags":[],"title":"主题迁移 2023-12-28","uri":"/%E4%B8%BB%E9%A2%98%E8%BF%81%E7%A7%BB-2023-12-28/"},{"categories":["折腾日记"],"content":"修复public部署可能存在的路由冲突 原先主题是直接把文件名生成到public目录部署的，如果有篇文章的名字刚好和源码或者其他文件相同，可能会在执行hugo的时候报错。下面通过约定archive-作为前缀，来防止文件名冲突的问题。 title: {{ replace (replace .TranslationBaseName \"archive-\" \"\") \"-\" \" \" | title }} ","date":"2023-12-28","objectID":"/%E4%B8%BB%E9%A2%98%E8%BF%81%E7%A7%BB-2023-12-28/:0:3","tags":[],"title":"主题迁移 2023-12-28","uri":"/%E4%B8%BB%E9%A2%98%E8%BF%81%E7%A7%BB-2023-12-28/"},{"categories":["折腾日记"],"content":"切换algolia搜索 原先博客是使用的lunr作为搜索实现，但是只能搜索英文，对于中文不能很好的检索，于是便使用了algolia全文搜索引擎。 Info Algolia 是一个托管搜索引擎，提供全文、数字和分面搜索，能够通过第一次击键提供实时结果。Algolia 强大的 API 可让您在网站和移动应用程序中快速、无缝地实施搜索。我们的搜索 API 每月为数千家公司提供数十亿次查询，在世界任何地方在 100 毫秒内提供相关结果。 在本站点所使用主题LoveIt已经集成了algolia，原作者认为配置algolia的索引文件比较麻烦，于是便自己想实现一个，最初是使用的官方的algolia cli，但是会出现bufio.Reader: token is too long的源码错误。于是乎，在网上冲浪看到了使用github action自动上传索引文件的项目，便采用之。 最后，workflows依然会出现一点问题，主要是我的索引文件比较大，需要裁减一下conten-length ","date":"2023-12-28","objectID":"/%E4%B8%BB%E9%A2%98%E8%BF%81%E7%A7%BB-2023-12-28/:0:4","tags":[],"title":"主题迁移 2023-12-28","uri":"/%E4%B8%BB%E9%A2%98%E8%BF%81%E7%A7%BB-2023-12-28/"},{"categories":["杂"],"content":"记一次picgo+github图床上传失败的过程 ","date":"2023-08-22","objectID":"/%E8%AE%B0%E4%B8%80%E6%AC%A1github%E5%9B%BE%E5%BA%8A%E4%B8%8A%E4%BC%A0%E5%BC%82%E5%B8%B8%E7%9A%84bug/:1:0","tags":[],"title":"记一次github图床上传异常的bug","uri":"/%E8%AE%B0%E4%B8%80%E6%AC%A1github%E5%9B%BE%E5%BA%8A%E4%B8%8A%E4%BC%A0%E5%BC%82%E5%B8%B8%E7%9A%84bug/"},{"categories":["杂"],"content":"问题 这次遇到一个非常非常奇怪的问题。我和往常一样使用picgo在github上上传图片。但是突然没有预兆的给我报了err: connected etimedout的错误（指连接超时）。 我ping了一下api.github.com，发现链路不通，数据包送不过去，但是浏览器还可以请求api.github.com。 上网冲浪后得知：应该是服务端设置了相关策略对网络层icmp回显请求报文进行了限制；而访问网页用的是http协议，因此会出现此现象。 所以这个现象聊胜于无。 后来看到picgo的issue中，有不少人都提了这个问题。 ","date":"2023-08-22","objectID":"/%E8%AE%B0%E4%B8%80%E6%AC%A1github%E5%9B%BE%E5%BA%8A%E4%B8%8A%E4%BC%A0%E5%BC%82%E5%B8%B8%E7%9A%84bug/:1:1","tags":[],"title":"记一次github图床上传异常的bug","uri":"/%E8%AE%B0%E4%B8%80%E6%AC%A1github%E5%9B%BE%E5%BA%8A%E4%B8%8A%E4%BC%A0%E5%BC%82%E5%B8%B8%E7%9A%84bug/"},{"categories":["杂"],"content":"解决 其实这个就是系统代理本身的问题了：并不是所有软件或工具的网络请求都会走系统代理，有些应用的网络请求可能绕过代理，直接与网络通信。 所以，我们需要给picgo手动设置代理，让picgo的所有请求一定要经过代理。如下图： 我们在picgo中设置了vpn的服务端口。这样所有请求就可以转发到这里，包括一些外网的请求。 image-20230822163253429 因此，解决了代理问题。 ","date":"2023-08-22","objectID":"/%E8%AE%B0%E4%B8%80%E6%AC%A1github%E5%9B%BE%E5%BA%8A%E4%B8%8A%E4%BC%A0%E5%BC%82%E5%B8%B8%E7%9A%84bug/:2:0","tags":[],"title":"记一次github图床上传异常的bug","uri":"/%E8%AE%B0%E4%B8%80%E6%AC%A1github%E5%9B%BE%E5%BA%8A%E4%B8%8A%E4%BC%A0%E5%BC%82%E5%B8%B8%E7%9A%84bug/"},{"categories":["杂"],"content":"意外惊喜 我最近一直遇到这样问题：我明明已经开了梯子，但为什么我在bash中git pull或git push时总是报这个两个错： fatal: unable to access 'https://github.com/cold-bin/cold-bin.github.io.git/': OpenSSL SSL_read: Connection was reset, errno 10054 or fatal: unable to access 'https://github.com/cold-bin/cold-bin.github.io.git/': Failed to connect to github.com port 443 after 21109 ms: Timed out 其实和上面的问题一样，有些软件不走你的系统代理，直接走网络通信。解决方案也和上面一样：给git设置vpn代理的端口。 git config --global http.proxy http://127.0.0.1:7890 git config --global https.proxy http://127.0.0.1:7890 # 我的clash在7890上系统代理 ","date":"2023-08-22","objectID":"/%E8%AE%B0%E4%B8%80%E6%AC%A1github%E5%9B%BE%E5%BA%8A%E4%B8%8A%E4%BC%A0%E5%BC%82%E5%B8%B8%E7%9A%84bug/:3:0","tags":[],"title":"记一次github图床上传异常的bug","uri":"/%E8%AE%B0%E4%B8%80%E6%AC%A1github%E5%9B%BE%E5%BA%8A%E4%B8%8A%E4%BC%A0%E5%BC%82%E5%B8%B8%E7%9A%84bug/"},{"categories":["分布式系统"],"content":"lab1——实现简易版的mapreduce框架 ","date":"2023-08-10","objectID":"/mit6.824%E4%B9%8Blab1/:1:0","tags":["mit6.824"],"title":"Mit6.824之lab1","uri":"/mit6.824%E4%B9%8Blab1/"},{"categories":["分布式系统"],"content":"论文回顾 mapreduce架构 严格来讲，MapReduce是一种分布式计算模型，用于解决大于1TB数据量的大数据计算处理。著名的开源项目Hadoop和Spark在计算方面都实现的是MapReduce模型。从论文中可以看到花了不少篇幅在讲解这个模型的原理和运行过程，但同时也花了一点篇幅来讲解处理分布式系统实现中可能遇到的问题。 MapReduce的模型设计很容易进行水平横向扩展以加强系统的能力，基本分为两种任务：map和reduce，通过map任务完成程序逻辑的并发，通过reduce任务完成并发结果的归约和收集，使用这个框架的开发者的任务就是把自己的业务逻辑先分为这两种任务，然后丢给MapReduce模型去运行。设计上，执行这两种任务的worker可以运行在普通的PC机器上，不需要使用太多资源。当系统整体能力不足时，通过增加worker即可解决。 性能瓶颈 那么什么更容易导致系统性能扩展的瓶颈？CPU？内存？磁盘？还是网络？在2004年这篇文章问世的时候回答还是”网络带宽“最受限，论文想方设法的减少数据在系统内的搬运与传输，而到如今数据中心的内网速度要比当时快多了，因此如今更可能的答案恐怕就是磁盘了，新的架构会减少数据持久化到磁盘的次数，更多的利用内存甚至网络（这正是Spark的设计理念） 如何处理较慢的网络？参考论文3.4节减少网络带宽资源的浪费，都尽量让输入数据保存在构成集群机器的本地硬盘上，并通过使用分布式文件系统GFS进行本地磁盘的管理。尝试分配map任务到尽量靠近这个任务的输入数据库的机器上执行，这样从GFS读时大部分还是在本地磁盘读出来。中间数据传输（map到reduce）经过网络一次，但是分多个key并行执行 负载均衡 某个task运行时间比较其他N-1个都长，大家都必须等其结束那就尴尬了，因此参考论文3.5节、3.6节系统设计保证task比worker数量要多，做的快的worker可以继续先执行其他task，减少等待。（框架的任务调度后来发现更值得研究） 容错 参考论文3.3节重新执行那些失败的MR任务即可，因此需要保证MR任务本身是幂等且无状态的。 更特别一些，worker失效如何处理？将失败任务调配到其他worker重新执行，保证最后输出到GFS上的中间结果过程是原子性操作即可。（减少写错数据的可能） Master失效如何处理？因为master是单点，只能人工干预，系统干脆直接终止，让用户重启重新执行这个计算 其他 其实还有部分工程问题，这篇文章中并没有讨论，可能因为这些更偏重工程实践，比如：task任务的状态如何监控、数据如何移动、worker故障后如何恢复等。 ","date":"2023-08-10","objectID":"/mit6.824%E4%B9%8Blab1/:1:1","tags":["mit6.824"],"title":"Mit6.824之lab1","uri":"/mit6.824%E4%B9%8Blab1/"},{"categories":["分布式系统"],"content":"实现思路 lec1中讲到，mapreduce隐藏的细节，我们需要实现下面的这些： 将应用程序代码发送到服务器 跟踪哪些任务已完成 将中间数据从 Maps“移到” Reduces 平衡服务器负载 从失败中恢复 coordinator 在lab1中，coordinator类似于论文中提到的master，是集群的管理者，负责分配job的task给worker进程。 task分两种： 一种是map任务，负责将给定分区文件的数据处理成中间结果，然后将中间结果输出到本地磁盘。输出时，就进行分区。（分区映射函数hash(key) mod R） 另一种是reduce任务，负责将中间结果收集合并，输出到文件里。 一般来说，lab1中的一个reduce任务就对应一个输出文件，在map任务输出时，就已经在map worker磁盘本地分好区了。后面reduce任务就会从所有map worker里去取自己分区的中间结果集。 // TaskType 任务类型，worker会承担map任务或者reduce任务 type TaskType uint8 const ( Map TaskType = iota + 1 Reduce Done ) coordinator管理过程 首先将map任务分配给worker，直到所有map任务完成为止 所有map任务完成后，coordinator才开始分发reduce任务 coordinator数据结构 在上面谈到，lab里并没有要求我们实现一个工业级别的mapreduce，仅仅要求我们实现简易版的demo 所有的map任务完成时，才能分配reduce任务 这也就意味着，如果只是部分map任务执行完毕时，我们需要等待其他map任务都执行完毕，才能执行reduce任务。怎么实现呢？在lab的hints里，给出了提示:使用sync.Cond条件变量实现 当所有的task没有完成时，我们需要调用`sync.Cond`的`Wait`方法等待`Boradcast`唤醒 \u003e 这样做的好处是只需要满足所有map worker都执行完毕才唤醒当前线程，使其执行下一步，也就是分配reduce任务，这条可以避免轮询cpu带来的性能消耗 上面的点提到”当所有task没有完成“这句话，显然，我们还需要记录map任务和reduce任务分别的完成情况。 以前google内部的mapreduce（2004）实现在输入前，还会分区。但是lab里只需要将不同文件直接当作不同分区，不再细分为64m的block了，而且一个分区对应一个文件，一个文件对应一个map任务。所以，需要给出分区列表（也就是文件名列表）。 lab里还要求解决”落伍者“问题。”落伍者“的大概意思就是，如果worker执行太久（lab里规定为10s）而没有finished，那么就认为这个worker寄掉了，此时，我们需要将task重新分配给其他的worker。 lab中提到，我们需要探测集群中的所有worker是否存活。这里我们是否有必要给worker额外起一个协程来Ping/Pong吗？ 其实我们可以减少这个网络成本。 worker首先会从coordinator拿task去执行，执行完毕后又会返回task的完成信息。我们认为只要在10s内，worker没有返回了完成信息，那么这个worker就寄掉了。 如果10s过后，完成信息返回到了coordinator，又该怎么办呢？ 我们保证确认完成信息是幂等性的就可以了。例如我要在coodinator中更新map任务的完成情况mapTasksFinished的核心代码就是 mapTasksFinished[task_id] = true 我们可以看到，这段代码是幂等的。 所以，我们需要记录worker的完成时间点和拿取任务时间点的差值是否超过了10s，就代表worker是否寄掉。 还有其他数据也需要附带，例如：锁、当前map和reduce任务的数目，job状态 type Coordinator struct { // Your definitions here. mu sync.Mutex cond *sync.Cond mapFiles []string // map任务的输入文件 nMapTasks int // map任务数，lab里规定的一个map任务对应一个worker。len(mapFiles) = nMapTasks nReduceTasks int // 记录任务的完成情况和何时分配，用以跟踪worker的处理进度 mapTasksFinished []bool // 记录map任务完成情况 mapTasksWhenAssigned []time.Time // 记录map任务何时分配 reduceTasksFinished []bo","date":"2023-08-10","objectID":"/mit6.824%E4%B9%8Blab1/:1:2","tags":["mit6.824"],"title":"Mit6.824之lab1","uri":"/mit6.824%E4%B9%8Blab1/"},{"categories":["分布式系统"],"content":"感言 论文其实大部分还是看得懂，最初的时候实现起来毫无头绪，论文给的是一个参考的、极其模糊的实现，而且还是分布式下的。但是lab里没有要求我们需要通过网络来把map worker的中间结果集输送到reduce worker机子里，仅仅只是实现一个单机多进程版本的mapreduce。 这里的实现也是参考了一下lab1 Q\u0026A 才知道我们仅仅只是做一个单机多进程版本的mapreduce，不需要考虑在网络传输map worker的中间结果集。 实现上有很多有意思的地方： 中间任务的输出结果，我们写入临时文件里，处理完毕过后，我们再重命名为最终结果文件；如果中途失败，那么我们得不到这个中间文件，因为该文件是临时文件。这样可以保证我们的map任务或reduce任务要么失败没有输出，要么成功有输出，从而保证了原子性 lab并不像论文中描述的：一旦map任务有一个执行完毕了，那么reduce任务就可以开始启动了。而是采取更简单的实现策略：所有map任务都完成了，才可以启动reduce任务。所以，这里需要有一个等待机制，满足“所有map任务执行完毕”的条件时，我们才能分配reduce任务。所以，这里使用sync.Cond来实现。 如何实现“落伍者”的检测呢？我们可以记录分配任务时和完成任务时的时间差，太长就认为worker超时了。 代码传输门 ","date":"2023-08-10","objectID":"/mit6.824%E4%B9%8Blab1/:2:0","tags":["mit6.824"],"title":"Mit6.824之lab1","uri":"/mit6.824%E4%B9%8Blab1/"},{"categories":["计算机网络"],"content":"cs144 lab的思路与实现 lab0 ","date":"2023-07-31","objectID":"/cs144-lab/:0:0","tags":["cs144"],"title":"Cs144 Lab","uri":"/cs144-lab/"},{"categories":["计算机网络"],"content":"reference link lab0实验手册 ","date":"2023-07-31","objectID":"/cs144-lab/:1:0","tags":["cs144"],"title":"Cs144 Lab","uri":"/cs144-lab/"},{"categories":["计算机网络"],"content":"implementation ","date":"2023-07-31","objectID":"/cs144-lab/:2:0","tags":["cs144"],"title":"Cs144 Lab","uri":"/cs144-lab/"},{"categories":["计算机网络"],"content":"Set up GNU/Linux on your computer 简单地安装CS144 VirtualBox和c++环境，以方便后续地测试。 ","date":"2023-07-31","objectID":"/cs144-lab/:2:1","tags":["cs144"],"title":"Cs144 Lab","uri":"/cs144-lab/"},{"categories":["计算机网络"],"content":"Networking by hand 接下来就是使用简单地telnet来构造HTTP请求和SMTP请求，并得到对应的响应。 （亲手写出一部分报文 ","date":"2023-07-31","objectID":"/cs144-lab/:2:2","tags":["cs144"],"title":"Cs144 Lab","uri":"/cs144-lab/"},{"categories":["计算机网络"],"content":"Listening and connecting 通过netcat建立一个全双工通信的服务端，感受netcat的使用。 （类似于即时通讯服务 ","date":"2023-07-31","objectID":"/cs144-lab/:2:3","tags":["cs144"],"title":"Cs144 Lab","uri":"/cs144-lab/"},{"categories":["计算机网络"],"content":"Writing a network program by using an OS stream socket part 1 lab0的最后一项任务就是使用原生的tcp socket来编写http报文结构，从而在socket的基础上发起一次http请求 详见lab0/minow/apps/webget.cc代码实现。 part2 part2实现可靠字节流，使用一个普通string来存储字节流 lab1 ","date":"2023-07-31","objectID":"/cs144-lab/:2:4","tags":["cs144"],"title":"Cs144 Lab","uri":"/cs144-lab/"},{"categories":["计算机网络"],"content":"reference link lab1实验手册 博客 ","date":"2023-07-31","objectID":"/cs144-lab/:3:0","tags":["cs144"],"title":"Cs144 Lab","uri":"/cs144-lab/"},{"categories":["计算机网络"],"content":"implementation 在tcp/ip协议栈中，数据传输的可靠性不是网络来承担的，而是交由端系统来承担的。网络中的有序字节流从一端发送到另一端，跨越了诸多网络的路由器 ，期间难免出现字节流传输的乱序、重复、重叠等。而lab1就是需要在这样不可靠字节流中去建立可靠的字节流。 ","date":"2023-07-31","objectID":"/cs144-lab/:4:0","tags":["cs144"],"title":"Cs144 Lab","uri":"/cs144-lab/"},{"categories":["计算机网络"],"content":"具体实现 这里参考了上面的博客 lab2 ","date":"2023-07-31","objectID":"/cs144-lab/:4:1","tags":["cs144"],"title":"Cs144 Lab","uri":"/cs144-lab/"},{"categories":["计算机网络"],"content":"reference link lab2实验手册 ","date":"2023-07-31","objectID":"/cs144-lab/:5:0","tags":["cs144"],"title":"Cs144 Lab","uri":"/cs144-lab/"},{"categories":["计算机网络"],"content":"implementation ","date":"2023-07-31","objectID":"/cs144-lab/:6:0","tags":["cs144"],"title":"Cs144 Lab","uri":"/cs144-lab/"},{"categories":["计算机网络"],"content":"wrap与unwrap wrap是将absolute seqno转化为seqno 由于absolute seqno是非循环序号，seqno是循环序号，所以需要取模转化。（当然也可以直接截断。 unwrap是将seqno转化为absolute seqno checkpoint其实就是first_unassembled_index 这里的处理比较麻烦。我最开始的想法是，循环找出最小的checkpoint - (seqno+x * 2^32)，也就是离得最近的x。 但是复杂度比较高，看了大佬的博客，利用位运算，可以将O(x)的时间复杂度降低为O(1). 官方让我们找到离checkpoint最近的absolute seqno，因为给出seqno，会有多个absolute seqno与之对应， ","date":"2023-07-31","objectID":"/cs144-lab/:6:1","tags":["cs144"],"title":"Cs144 Lab","uri":"/cs144-lab/"},{"categories":["计算机网络"],"content":"TCP Receiver 参考上面seqno、absolute seqno与stream index的对应关系图 receive时，直接在reassembler中插入absolute seqno，显然不是期待的stream_index； send时，需要考虑到available_capacity不能超过UINT_MAX以及close时，发送的fin报文也要占据一个序号 lab3 ","date":"2023-07-31","objectID":"/cs144-lab/:6:2","tags":["cs144"],"title":"Cs144 Lab","uri":"/cs144-lab/"},{"categories":["计算机网络"],"content":"reference link lab3实验手册 博客 ","date":"2023-07-31","objectID":"/cs144-lab/:7:0","tags":["cs144"],"title":"Cs144 Lab","uri":"/cs144-lab/"},{"categories":["计算机网络"],"content":"implementation 这里参考了博客实现 实现ARQ重传机制 lab4 ","date":"2023-07-31","objectID":"/cs144-lab/:8:0","tags":["cs144"],"title":"Cs144 Lab","uri":"/cs144-lab/"},{"categories":["计算机网络"],"content":"reference link lab4实验手册 博客 ","date":"2023-07-31","objectID":"/cs144-lab/:9:0","tags":["cs144"],"title":"Cs144 Lab","uri":"/cs144-lab/"},{"categories":["计算机网络"],"content":"implementation Lab4 要求实现网络接口部分， 打通网络数据报 （Internet datagrams） 和链路层的以太网帧（link-layer Ethernet frames） 之间的桥梁。 也就是，实现ip数据报转化为mac帧。ip数据报在转化为mac帧时，最重要的就是要知道目的mac地址，而mac地址我们可以通过arp协议来学习到。 所以，这里就牵扯到了arp协议的实现： 目的ip地址与mac地址的缓存映射。最多保存30s； 端系统可以组装ip报文和arp请求与响应报文，也能解析之； 不论是arp请求还是arp响应，端系统拿到过后都可以学习到对等端的ip的其mac地址的映射关系 而且，我们并不能任性发送arp请求，我们只能等待相同的arp请求发出去5秒后没有收到arp响应才再次发送，这是为了防止频繁地arp广播导致链路阻塞 端系统在接收报文时，收到ip数据报自然不用说，该怎么处理就怎么处理，但是收到arp报文时，需要进一步处理： 如果是arp请求报文 那么我们在校验合法性通过后，还需要学习arp请求的来源ip地址和来源mac地址的映射关系，并且构造arp响应，返回自己的ip与mac地址的映射关系，以供arp请求方学习 如果是arp响应报文 那么我们在校验合法性通过后，再从arp响应报文中学习到目的ip地址和目的mac地址的映射关系。除了mac地址学习外，我们还需要将arp请求等待列表清空 总之，我们通过arp协议拿到了目的mac地址过后，剩下的事情就非常简单了（将ip数据报组装成mac帧，以方便发送到数据链路上 实验手册给的实现已经很详细了，翻译成代码即可。 lab5 ","date":"2023-07-31","objectID":"/cs144-lab/:10:0","tags":["cs144"],"title":"Cs144 Lab","uri":"/cs144-lab/"},{"categories":["计算机网络"],"content":"reference link lab5实验手册 博客 ","date":"2023-07-31","objectID":"/cs144-lab/:11:0","tags":["cs144"],"title":"Cs144 Lab","uri":"/cs144-lab/"},{"categories":["计算机网络"],"content":"implementation lab5的要求是在lab4实现的网络接口上，实现ip router.路由器有多个网络接口，可以在其中任何一个接口上接收 Internet 数据报。 路由器的工作是根据路由表转发它获得的数据报：路由表是一个规则列表，告诉路由器对于任何给定的数据报: 在哪个network interface发出去 确定next hop 实验手册的Q \u0026 A中对route table的数据结构要求很低，允许实现O(N)时间复杂度。所以，这里直接使用std:list\u003ctype\u003e。 lab5的要求其实很简单了。我们只需要实现路由最长前缀匹配即可，并不需要实现动态路由的一些协议（RIP、OSPF、BGP 或 SDN 控制器） 当然除了这些，我们还需要注意： 每次路由转发ip数据报时，ttl需要减一，直至ttl等于0时，路由器会自动丢弃它 如果路由表里没有找到next hop，也会丢弃ip数据报 如果路由的数据报缓存已满，也会丢弃掉（lab5里并没有说 lab6 no code 使用以前的所有实现的lab来创建一个真实的网络，其中包括网络堆栈（主机和路由器），与另一台主机上实现的网络堆栈进行通信。 ","date":"2023-07-31","objectID":"/cs144-lab/:12:0","tags":["cs144"],"title":"Cs144 Lab","uri":"/cs144-lab/"},{"categories":["计算机网络"],"content":"how to do lab6实验手册 ","date":"2023-07-31","objectID":"/cs144-lab/:13:0","tags":["cs144"],"title":"Cs144 Lab","uri":"/cs144-lab/"},{"categories":["数据结构与算法"],"content":"leetcode每日一题","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"Leetcode刷题笔记 [toc] ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:0:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day01 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:1:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"移除元素 题目 给你一个数组 nums 和一个值val，你需要 原地 移除所有数值等于val的元素，并返回移除后数组的新长度。 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。 暴力题解 这个题目暴力的解法就是两层for循环，一个for循环遍历数组元素 ，第二个for循环更新数组。 class Solution { public int removeElement(int[] nums, int val) { int j=0; int i=0; int len=nums.length; for(i=0;i\u003clen;i++){ if(val==nums[i]){ //将之后的元素全部往前挪移覆盖一位 for(j=i+1;j\u003clen;j++){ nums[j-1]=nums[j]; } //将数组索引也往前挪 i--; len--; } } return len; } } 双指针法求解 由于题目要求删除数组中等于val的元素，因此输出数组的长度一定小于等于输入数组的长度，我们可以把输出的数组直接写在输入数组上。可以使用双指针：右指针right 指向当前将要处理的元素，左指针 left 指向下一个将要赋值的位置。 如果右指针指向的元素不等于 val，它一定是输出数组的一个元素，我们就将右指针指向的元素复制到左指针位置，然后将左右指针同时右移； 如果右指针指向的元素等于 val，它不能在输出数组里，此时左指针不动，右指针右移一位。 整个过程保持不变的性质是：区间 [0,left)中的元素都不等于 val。当左右指针遍历完输入数组以后，left 的值就是输出数组的长度。 class Solution { public int removeElement(int[] nums, int val) { int n = nums.length; int left = 0;//指输出元素索引 for (int right = 0; right \u003c n; right++){ if (nums[right] != val) { //不等于删除值，则将这个元素添加至输出元素 nums[left] = nums[right]; left++; } } return left; } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:1:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day02 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:2:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"最大子数组和 题目 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。子数组 是数组中的一个连续部分。 暴力破解 找规律 对于含有正数的序列而言,最大子序列肯定是正数,所以头尾肯定都是正数.我们可以从第一个正数开始算起,每往后加一个数便更新一次和的最大值;当当前和成为负数时,则表明此前序列无法为后面提供最大子序列和,因此必须重新确定序列首项 class Solution { public int maxSubArray(int[] nums) { int maxSum = Integer.MIN_VALUE;//最大和 int thisSum = 0;//当前和 int len = nums.length; for(int i = 0; i \u003c len; i++) { thisSum += nums[i]; if(maxSum \u003c thisSum) { maxSum = thisSum; } //如果当前和小于0则归零，因为对于后面的元素来说这些是减小的。于是归零，意即从此处算开始最大和 if(thisSum \u003c 0) { thisSum = 0; } } return maxSum; } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:2:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"加一 题目 给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。 找规律 将这个看作是两个数组相加，辅助数组始终要比给定数组多一位，用来承载可能两数之和比给定数组多一位。两数相加，先从末尾相加，依次往前，满十进一 class Solution { public int[] plusOne(int[] digits) { int len1=digits.length; int len2=len1+1; int i,j; int[] arr=new int[len2]; arr[len2-1]=1; for(i=len1-1,j=len2-1;;i--,j--){ int sum=digits[i]+arr[j]; if(sum\u003e9){ //进1 arr[j-1]++; //取余 arr[j]=(sum)%10; }else{ arr[j]=sum; } //跳出条件放到此处，防止少算一次 if (i==0){ break; } } //根据首位判断是否输出首位 if (arr[0]==0){ for (i=1,j=0;i\u003clen2;){ digits[j++]=arr[i++]; } return digits; } return arr; } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:2:2","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day03 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:3:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"合并两个有序数组 题目 给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。 注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。 方法一：先合并再排序（缺点，没有利用两数组已经排序的条件） class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { //先合并末尾数据 for (int i = m, j = 0; i \u003c nums1.length \u0026\u0026 j \u003c n; i++, j++) { nums1[i] = nums2[j]; } //按递增排序(希尔排序) for (int gap = nums1.length / 2; gap \u003e 0; gap /= 2) {//步长 //对每组进行直接插入排序 for (int i = gap; i \u003c nums1.length; i++) { int index = i; int value = nums1[i]; while (index - gap \u003e= 0 \u0026\u0026 nums1[index - gap] \u003e value) { nums1[index] = nums1[index - gap]; index -= gap; } nums1[index] = value; } } } } 方法二：双指针 方法一没有利用数组nums1与 nums2已经被排序的性质。为了利用这一性质，我们可以使用双指针方法。这一方法将两个数组看作队列，每次从两个数组头部取出比较小的数字放到结果中。如下面的动画所示： 我们为两个数组分别设置一个指针p1与p2来作为队列的头部指针。代码实现如下： class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { int p1 = 0, p2 = 0; int[] sorted = new int[m + n]; int cur; while (p1 \u003c m || p2 \u003c n) { if (p1 == m) { cur = nums2[p2++]; } else if (p2 == n) { cur = nums1[p1++]; } else if (nums1[p1] \u003c nums2[p2]) { cur = nums1[p1++]; } else { cur = nums2[p2++]; } sorted[p1 + p2 - 1] = cur; } for (int i = 0; i != m + n; ++i) { nums1[i] = sorted[i]; } } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:3:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day04 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:4:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"59. 螺旋矩阵 II 题目 给你一个正整数 n ，生成一个包含 1 到 n2 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。 示例 1： 输入：n = 3 输出：[[1,2,3],[8,9,4],[7,6,5]] 示例 2： 输入：n = 1 输出：[[1]] 提示： 1 \u003c= n \u003c= 20 方法一：暴力破解，环形遍历–\u003e也即按层模拟 package other; import java.util.Arrays; class Solution5 { public static void main(String[] args) { System.out.println(Arrays.deepToString(generateMatrix(4))); } public static int[][] generateMatrix(int n) { int[][] arr = new int[n][n]; int val = 1;//表示填入值 int i = 0, j = 0;//arr数组索引，i为行标，j列标 int tempN1 = n;//表示每列或每行在某环的行走最大值 int tempN2 = 0;//表示每列或每行在某环的行走最小值 for (int l = 0; l \u003c n - n / 2; l++) {//环数 while (j \u003c tempN1) { arr[i][j] = val++; j++; } j--;//还原j值 i++;//下一个数 while (i \u003c tempN1) { arr[i][j] = val++; i++; } i--;//还原i值 j--;//下一个数 while (j \u003e= tempN2) { arr[i][j] = val++; j--; } j++;//还原j值 i--;//下一个数 while (i \u003e tempN2) { arr[i][j] = val++; i--; } i++;//还原i数 j++;//指向下一个数字 tempN1--; tempN2++; } return arr; } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:4:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day05 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:5:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"209. 长度最小的子数组 题目 给定一个含有 n 个正整数的数组和一个正整数 target 。 找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, …, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。 方法一：暴力破解（超时） 题目要求求出和大于等于target的长度最小的连续子数组，于是乎，就使用一个“窗口”从长度最小的1开始到整个数组的长度遍历，每次遍历都要“框出”子数组的和并比较，满足要求就返回。 public int minSubArrayLen(int target, int[] nums) { int left=0;//每个窗口的左索引 int sum=0; for(int cap=1;cap\u003c=nums.length;cap++){//滑动窗口大小 for(left=0;left\u003cnums.length-cap+1;left++){//左索引位置 sum=0; //计算窗口内的和 for(int i=left;i\u003cleft+cap;i++){ sum+=nums[i]; } if (sum\u003e=target) return cap; } } return 0; } 方法二：滑动窗口 使用左右指针 left 和 right，left 和 right 之间的长度即为滑动窗口的大小（即连续数组的大小）。如果滑动窗口内的值 sum \u003e= target，维护连续数组最短长度，left 向右移动，缩小滑动窗口。如果滑动窗口内的值 sum \u003c target，则 right 向有移动，扩大滑动窗口。 public int minSubArrayLen(int target, int[] nums) { int left=0; int right=0; int sum=0; int len=Integer.MAX_VALUE; while(right\u003cnums.length){ sum+=nums[right]; while(sum\u003e=target){ if(len\u003eright-left+1) len=right-left+1;//与上次的进行比较，保留最短结果 sum-=nums[left++]; } right++; } if (len==Integer.MAX_VALUE) return 0; return len; } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:5:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day06 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:6:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"977. 有序数组的平方 题目 给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。 示例 1： 输入：nums = [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100] 排序后，数组变为 [0,1,9,16,100] 示例2： 输入：nums = [-7,-3,2,3,11] 输出：[4,9,9,49,121] 方法一：直接排序 最简单的方法就是将数组nums中的数平方后直接排序。 class Solution { public int[] sortedSquares(int[] nums) { int[] ans = new int[nums.length]; for (int i = 0; i \u003c nums.length; ++i) { ans[i] = nums[i] * nums[i]; } Arrays.sort(ans); return ans; } } 方法二：双指针 同样地，我们可以使用两个指针分别指向位置 0 和 n-1，每次比较两个指针对应的数，选择较大的那个逆序放入答案并移动指针。这种方法无需处理某一指针移动至边界的情况，读者可以仔细思考其精髓所在。 class Solution { public int[] sortedSquares(int[] nums) { int n = nums.length; int[] ans = new int[n]; for (int i = 0, j = n - 1, pos = n - 1; i \u003c= j;) { if (nums[i] * nums[i] \u003e nums[j] * nums[j]) { ans[pos] = nums[i] * nums[i]; ++i; } else { ans[pos] = nums[j] * nums[j]; --j; } --pos; } return ans; } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:6:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day07 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:7:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"19. 删除链表的倒数第 N 个结点 题目 给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。 示例 1： 输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5] 示例 2： 输入：head = [1], n = 1 输出：[] 示例 3： 输入：head = [1,2], n = 1 输出：[1] 提示： 链表中结点的数目为 sz 1 \u003c= sz \u003c= 30 0 \u003c= Node.val \u003c= 100 1 \u003c= n \u003c= sz **进阶：**你能尝试使用一趟扫描实现吗？ 解决思路 前言 在对链表进行操作时，一种常用的技巧是添加一个哑节点（dummy node），它的 next 指针指向链表的头节点。这样一来，我们就不需要对头节点进行特殊的判断了。 例如，在本题中，如果我们要删除节点 y，我们需要知道节点 y 的前驱节点 x，并将 x 的指针指向 y 的后继节点。但由于头节点不存在前驱节点，因此我们需要在删除头节点时进行特殊判断。但如果我们添加了哑节点，那么头节点的前驱节点就是哑节点本身，此时我们就只需要考虑通用的情况即可。（注意：此处头节点存放了有意义的数据） 特别地，在某些语言中，由于需要自行对内存进行管理。因此在实际的面试中，对于「是否需要释放被删除节点对应的空间」这一问题，我们需要和面试官进行积极的沟通以达成一致。下面的代码中默认不释放空间。 方法一：计算链表长度 思路与算法 一种容易想到的方法是，我们首先从头节点开始对链表进行一次遍历，得到链表的长度 LL。随后我们再从头节点开始对链表进行一次遍历，当遍历到第 L-n+1个节点时，它就是我们需要删除的节点。 为了与题目中的 n 保持一致，节点的编号从 1 开始，头节点为编号 1 的节点。 为了方便删除操作，我们可以从哑节点开始遍历 L-n+1个节点。当遍历到第 L-n+1 个节点时，它的下一个节点就是我们需要删除的节点，这样我们只需要修改一次指针，就能完成删除操作。 代码 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(0, head); int length = getLength(head); ListNode cur = dummy; for (int i = 1; i \u003c length - n + 1; ++i) { cur = cur.next; } cur.next = cur.next.next; ListNode ans = dummy.next; return ans; } public int getLength(ListNode head) { int length = 0; while (head != null) { ++length; head = head.next; } return length; } } /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeNthFromEnd(head *ListNode, n int) *ListNode { l:=0 heads:=\u0026ListNode{Next:head} tmp:=heads for tmp!=nil{ l++ tmp=tmp.Next } tmp = heads no:=0 for tmp!=nil { // 找到了n节点 if no==l-n-1 { if tmp.Next!=nil{ tmp.Next = tmp.Next.Next }else{ tmp.Next = nil } } no++ tmp=tmp.Next } return heads.Next } 复杂度分析 时间复杂度：O(L)，其中 L是链表的长度。 空间复杂度：O(1)。 方法二：栈 思路与算法 我们也可以在遍历链表的同时将所有节点依次入栈。根据栈「先进后出」的原则，我们弹出栈的第 n 个节点就是需要删除的节点，并且目前栈顶的节点就是待删除节点的前驱节点。这样一来，删除操作就变得十分方便了。 代码 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(0, head); Deque\u003cListNode\u003e stack = new LinkedList\u003cListNode\u003e(); ListNo","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:7:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day08 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:8:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"24. 两两交换链表中的节点 题目 给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。 示例 1： 输入：head = [1,2,3,4] 输出：[2,1,4,3] 示例 2： 输入：head = [] 输出：[] 示例 3： 输入：head = [1] 输出：[1] 提示： 链表中节点的数目在范围 [0, 100] 内 0 \u003c= Node.val \u003c= 100 方法 方法一：递归 思路与算法 可以通过递归的方式实现两两交换链表中的节点。 递归的终止条件是链表中没有节点，或者链表中只有一个节点，此时无法进行交换。 如果链表中至少有两个节点，则在两两交换链表中的节点之后，原始链表的头节点变成新的链表的第二个节点，原始链表的第二个节点变成新的链表的头节点。链表中的其余节点的两两交换可以递归地实现。在对链表中的其余节点递归地两两交换之后，更新节点之间的指针关系，即可完成整个链表的两两交换。 用 head 表示原始链表的头节点，新的链表的第二个节点，用 newHead 表示新的链表的头节点，原始链表的第二个节点，则原始链表中的其余节点的头节点是 newHead.next。令 head.next = swapPairs(newHead.next)，表示将其余节点进行两两交换，交换后的新的头节点为 head 的下一个节点。然后令 newHead.next = head，即完成了所有节点的交换。最后返回新的链表的头节点 newHead。 代码 class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) { return head; } ListNode newHead = head.next; head.next = swapPairs(newHead.next); newHead.next = head; return newHead; } } 复杂度分析 时间复杂度：O(n)，其中 n 是链表的节点数量。需要对每个节点进行更新指针的操作。 空间复杂度：O(n)，其中 n 是链表的节点数量。空间复杂度主要取决于递归调用的栈空间。 方法二：迭代 思路与算法 也可以通过迭代的方式实现两两交换链表中的节点。 创建哑结点 dummyHead，令 dummyHead.next = head。令 temp 表示当前到达的节点，初始时 temp = dummyHead。每次需要交换 temp 后面的两个节点。 如果 temp 的后面没有节点或者只有一个节点，则没有更多的节点需要交换，因此结束交换。否则，获得 temp 后面的两个节点 node1 和 node2，通过更新节点的指针关系实现两两交换节点。 具体而言，交换之前的节点关系是 temp -\u003e node1 -\u003e node2，交换之后的节点关系要变成 temp -\u003e node2 -\u003e node1，因此需要进行如下操作。 temp.next = node2 node1.next = node2.next node2.next = node1 完成上述操作之后，节点关系即变成 temp -\u003e node2 -\u003e node1。再令 temp = node1，对链表中的其余节点进行两两交换，直到全部节点都被两两交换。 两两交换链表中的节点之后，新的链表的头节点是 dummyHead.next，返回新的链表的头节点即可。 代码 class Solution { public ListNode swapPairs(ListNode head) { ListNode dummyHead = new ListNode(0); dummyHead.next = head; ListNode temp = dummyHead; while (temp.next != null \u0026\u0026 temp.next.next != null) { ListNode node1 = temp.next; ListNode node2 = temp.next.next; temp.next = node2; node1.next = node2.next; node2.next = node1; temp = node1; } return dummyHead.next; } } //the other /** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode() {} ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:8:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day09 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:9:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"25. K 个一组翻转链表 题目 给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。 k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。 示例 1： 输入：head = [1,2,3,4,5], k = 2 输出：[2,1,4,3,5] 示例 2： 输入：head = [1,2,3,4,5], k = 3 输出：[3,2,1,4,5] 提示： 链表中的节点数目为 n 1 \u003c= k \u003c= n \u003c= 5000 0 \u003c= Node.val \u003c= 1000 **进阶：**你可以设计一个只用 O(1) 额外内存空间的算法解决此问题吗？ 方法 方法一：模拟 思路与算法 本题的目标非常清晰易懂，不涉及复杂的算法，但是实现过程中需要考虑的细节比较多，容易写出冗长的代码。主要考查面试者设计的能力。 我们需要把链表节点按照 k 个一组分组，所以可以使用一个指针 head 依次指向每组的头节点。这个指针每次向前移动 k 步，直至链表结尾。对于每个分组，我们先判断它的长度是否大于等于 k。若是，我们就翻转这部分链表，否则不需要翻转。 接下来的问题就是如何翻转一个分组内的子链表。翻转一个链表并不难，过程可以参考「206. 反转链表」。但是对于一个子链表，除了翻转其本身之外，还需要将子链表的头部与上一个子链表连接，以及子链表的尾部与下一个子链表连接。如下图所示： 因此，在翻转子链表的时候，我们不仅需要子链表头节点 head，还需要有 head 的上一个节点 pre，以便翻转完后把子链表再接回 pre。 但是对于第一个子链表，它的头节点 head 前面是没有节点 pre 的。太麻烦了！难道只能特判了吗？答案是否定的。没有条件，我们就创造条件；没有节点，我们就创建一个节点。我们新建一个节点（哑节点），把它接到链表的头部，让它作为 pre 的初始值，这样 head 前面就有了一个节点，我们就可以避开链表头部的边界条件。这么做还有一个好处，下面我们会看到。 反复移动指针 head 与 pre，对 head 所指向的子链表进行翻转，直到结尾，我们就得到了答案。下面我们该返回函数值了。 有的同学可能发现这又是一件麻烦事：链表翻转之后，链表的头节点发生了变化，那么应该返回哪个节点呢？照理来说，前 k 个节点翻转之后，链表的头节点应该是第 k 个节点。那么要在遍历过程中记录第 k 个节点吗？但是如果链表里面没有 k 个节点，答案又还是原来的头节点。我们又多了一大堆循环和判断要写，太崩溃了！ 等等！还记得我们创建了节点 pre 吗？这个节点一开始被连接到了头节点的前面，而无论之后链表有没有翻转，它的 next 指针都会指向正确的头节点。那么我们只要返回它的下一个节点就好了。至此，问题解决。 class Solution { public ListNode reverseKGroup(ListNode head, int k) { ListNode hair = new ListNode(0); hair.next = head; ListNode pre = hair; while (head != null) { ListNode tail = pre; // 查看剩余部分长度是否大于等于 k for (int i = 0; i \u003c k; ++i) { tail = tail.next; if (tail == null) { return hair.next; } } ListNode nex = tail.next; ListNode[] reverse = myReverse(head, tail); head = reverse[0]; tail = reverse[1]; // 把子链表重新接回原链表 pre.next = head; tail.next = nex; pre = tail; head = tail.next; } return hair.next; } public ListNode[] myReverse(ListNode head, ListNode tail) { ListNode prev = tail.next; ListNode p = head; while (prev != tail) { ListNode nex = p.next; p.next = prev; prev = p; p = nex; } return new ListNode[]{tail, head}; } } 复杂度分析 时间复杂度：O(n)，其中 n 为链表的长度。head 指针会在 $O(\\lfl","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:9:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day10 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:10:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"141. 环形链表 题目 给你一个链表的头节点 head ，判断链表中是否有环。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。注意：pos 不作为参数进行传递 。仅仅是为了标识链表的实际情况。 如果链表中存在环 ，则返回 true 。 否则，返回 false 。 示例 1： 输入：head = [3,2,0,-4], pos = 1 输出：true 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0 输出：true 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1 输出：false 解释：链表中没有环。 提示： 链表中节点的数目范围是 [0, 104] -105 \u003c= Node.val \u003c= 105 pos 为 -1 或者链表中的一个 有效索引 。 **进阶：**你能用 O(1)（即，常量）内存解决此问题吗？ 解法 方法一：哈希表 思路及算法 最容易想到的方法是遍历所有节点，每次遍历到一个节点时，判断该节点此前是否被访问过。 具体地，我们可以使用哈希表来存储所有已经访问过的节点。每次我们到达一个节点，如果该节点已经存在于哈希表中，则说明该链表是环形链表，否则就将该节点加入哈希表中。重复这一过程，直到我们遍历完整个链表即可。 代码 public class Solution { public boolean hasCycle(ListNode head) { Set\u003cListNode\u003e seen = new HashSet\u003cListNode\u003e(); while (head != null) { if (!seen.add(head)) { return true; } head = head.next; } return false; } } 复杂度分析 时间复杂度：O(N)，其中 N 是链表中的节点数。最坏情况下我们需要遍历每个节点一次。 空间复杂度：O(N)，其中 N 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。 方法二：快慢指针 思路及算法 本方法需要读者对「Floyd 判圈算法」（又称龟兔赛跑算法）有所了解。 假想「乌龟」和「兔子」在链表上移动，「兔子」跑得快，「乌龟」跑得慢。当「乌龟」和「兔子」从链表上的同一个节点开始移动时，如果该链表中没有环，那么「兔子」将一直处于「乌龟」的前方；如果该链表中有环，那么「兔子」会先于「乌龟」进入环，并且一直在环内移动。等到「乌龟」进入环时，由于「兔子」的速度快，它一定会在某个时刻与乌龟相遇，即套了「乌龟」若干圈。 我们可以根据上述思路来解决本题。具体地，我们定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。 细节 为什么我们要规定初始时慢指针在位置 head，快指针在位置 head.next，而不是两个指针都在位置 head（即与「乌龟」和「兔子」中的叙述相同）？ 观察下面的代码，我们使用的是 while 循环，循环条件先于循环体。由于循环条件一定是判断快慢指针是否重合，如果我们将两个指针初始都置于 head，那么 while 循环就不会执行。因此，我们可以假想一个在 head 之前的虚拟节点，慢指针从虚拟节点移动一步到达 head，快指针从虚拟节点移动两步到达 head.next，这样我们就可以使用 while 循环了。 当然，我们也可以使用 do-while 循环。此时，我们就可以把快慢指针的初始值都置为 head。 代码 public class Solution { public boolean hasCycle(ListNode head) { if (head == null || head.next == null) { return false; } ListNode slow = head; ListNode fast = head.next; while (slow != fast) { if (fast == null || fast.next == null) { return false; } slow = slow.next; fast = fast.next.next; } return true; } } 复杂度分析 时间复杂度：O(N)，其中 N ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:10:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day11 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:11:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"142. 环形链表 II 题目 给定一个链表的头节点 head ，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。 不允许修改 链表。 示例 1： 输入：head = [3,2,0,-4], pos = 1 输出：返回索引为 1 的链表节点 解释：链表中有一个环，其尾部连接到第二个节点。 示例 2： 输入：head = [1,2], pos = 0 输出：返回索引为 0 的链表节点 解释：链表中有一个环，其尾部连接到第一个节点。 示例 3： 输入：head = [1], pos = -1 输出：返回 null 解释：链表中没有环。 提示： 链表中节点的数目范围在范围 [0, 104] 内 -105 \u003c= Node.val \u003c= 105 pos 的值为 -1 或者链表中的一个有效索引 **进阶：**你是否可以使用 O(1) 空间解决此题？ 方法 方法一：哈希表 思路与算法 一个非常直观的思路是：我们遍历链表中的每个节点，并将它记录下来；一旦遇到了此前遍历过的节点，就可以判定链表中存在环。借助哈希表可以很方便地实现。 代码 public class Solution { public ListNode detectCycle(ListNode head) { ListNode pos = head; Set\u003cListNode\u003e visited = new HashSet\u003cListNode\u003e(); while (pos != null) { if (visited.contains(pos)) { return pos; } else { visited.add(pos); } pos = pos.next; } return null; } } 复杂度分析 时间复杂度：O(N)，其中 N 为链表中节点的数目。我们恰好需要访问链表中的每一个节点。 空间复杂度：O(N)，其中 N 为链表中节点的数目。我们需要将链表中的每个节点都保存在哈希表当中。 方法二：快慢指针 思路与算法 我们使用两个指针，fast 与 slow。它们起始都位于链表的头部。随后，slow 指针每次向后移动一个位置，而 fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与 slow 指针在环中相遇。 如下图所示，设链表中环外部分的长度为 a。slow 指针进入环后，又走了 b 的距离与 fast 相遇。此时，fast 指针已经走完了环的 n 圈，因此它走过的总距离为 a+n*(b+c)+b = a+(n+1)*b+n*c。 根据题意，任意时刻，fast 指针走过的距离都为 slow 指针的 2 倍。因此，我们有 `a+(n+1)*b+n*c = 2*(a+b) ==\u003e a = c+(n-1)*(b+c)` 有了 a=c+(n-1)(b+c) 的等量关系，我们会发现：从相遇点到入环点的距离加上 n-1 圈的环长，恰好等于从链表头部到入环点的距离。 因此，当发现 slow 与 fast 相遇时，我们再额外使用一个指针 ptr。起始，它指向链表头部；随后，它和 slow 每次向后移动一个位置。最终，它们会在入环点相遇。 public class Solution { public ListNode detectCycle(ListNode head) { if (head == null) { return null; } ListNode slow = head, fast = head; while (fast != null) { slow = slow.next; if (fast.next != null) { fast = fast.next.next; } else { return null; } if (fast == slow) { ListNode ptr = head; while (ptr != slow) { ptr = ptr.next; slow = slow.next; } return ptr; } } return null; } } 复杂度分析 时间复杂度：O(N)，其中 N 为链表中节点的数目。在最初判断快慢指针是否相遇时，slow 指针走过的距离不会超过链表的总长度；随后寻找入环点时，走过的距离也不会超过链表的总长度。因此，总的执行时间为 O(N)+O(N)=O(N)。 空间复杂度：O(1)。","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:11:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day12 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:12:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"160. 相交链表 题目 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。 图示两个链表在节点 c1 开始相交**：** 题目数据 保证 整个链式结构中不存在环。 注意，函数返回结果后，链表必须 保持其原始结构 。 自定义评测： 评测系统 的输入如下（你设计的程序 不适用 此输入）： intersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0 listA - 第一个链表 listB - 第二个链表 skipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数 skipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数 评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被 视作正确答案 。 示例 1： 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3 输出：Intersected at '8' 解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 示例 2： 输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 输出：Intersected at '2' 解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。 从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。 在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。 示例 3： 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 输出：null 解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。 由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。 这两个链表不相交，因此返回 null 。 提示： listA 中节点数目为 m listB 中节点数目为 n 1 \u003c= m, n \u003c= 3 * 104 1 \u003c= Node.val \u003c= 105 0 \u003c= skipA \u003c= m 0 \u003c= skipB \u003c= n 如果 listA 和 listB 没有交点，intersectVal 为 0 如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB] **进阶：**你能否设计一个时间复杂度 O(m + n) 、仅用 O(1) 内存的解决方案？ 方法 方法一：哈希集合 思路和算法 判断两个链表是否相交，可以使用哈希集合存储链表节点。 首先遍历链表 headA，并将链表 headA 中的每个节点加入哈希集合中。然后遍历链表 headB，对于遍历到的每个节点，判断该节点是否在哈希集合中： 如果当前节点不在哈希集合中，则继续遍历下一个节点； 如果当前节点在哈希集合中，则后面的节点都在哈希集合中，即从当前节点开始的所有节点都在两个链表的相交部分，因此在链表 headB 中遍历到的第一个在哈希集合中的节点就是两个链表相交的节点，返回该节点。 如果链表 headB 中的所有节点都不在哈希集合中，则两个链表不相交，返回 null。 代码 public class Solution { public ListNode getIntersectionNode(ListNode headA, ListNode headB) { Set\u003cListNode\u003e visited = new HashSet\u003cListNode\u003e(); ListNode temp = headA; while (temp != null) { visited.add(temp); temp = temp.next; } temp = headB; while (temp != null) { if (visited.contains(temp)) { return temp; } temp = temp.next; } return null; } } 复杂度分析 时","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:12:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day13 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:13:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"206. 反转链表 题目 给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。 示例 1： 输入：head = [1,2,3,4,5] 输出：[5,4,3,2,1] 示例 2： 输入：head = [1,2] 输出：[2,1] 示例 3： 输入：head = [] 输出：[] 提示： 链表中节点的数目范围是 [0, 5000] -5000 \u003c= Node.val \u003c= 5000 解法 方法一：迭代 假设存在链表 1–\u003e2–\u003e3–\u003e∅，我们想要把它改成 ∅\u003c–1\u003c–2\u003c–3。 在遍历列表时，将当前节点的 next 指针改为指向前一个元素。由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。在更改引用之前，还需要另一个指针来存储下一个节点。不要忘记在最后返回新的头引用！ class Solution { public ListNode reverseList(ListNode head) { ListNode prev = null; ListNode curr = head; while (curr != null) { ListNode nextTemp = curr.next; curr.next = prev; prev = curr; curr = nextTemp; } return prev; } } 复杂度分析 时间复杂度：O(n)，假设 n 是列表的长度，时间复杂度是 O(n)。 空间复杂度：O(1)。 方法二：递归 递归版本稍微复杂一些，其关键在于反向工作。假设列表的其余部分已经被反转，现在我们应该如何反转它前面的部分？ 假设列表为： n~1~--\u003e…--\u003en~k−1~--\u003en~k~--\u003en~k+1~--\u003e…--\u003en~m~--\u003e∅ 若从节点 n~k+1~ 到 n~k~ n~1~--\u003e…--\u003en~k−1~--\u003en~k~--\u003en~k+1~\u003c--…\u003c--n~m~ 我们希望 n~k+1~ 的下一个节点指向 n~k~ 所以，n~k~.next.next*=*n~k~ 要小心的是 n~1~ 的下一个必须指向 ∅ 。如果你忽略了这一点，你的链表中可能会产生循环。如果使用大小为 22 的链表测试代码，则可能会捕获此错误。 class Solution { public ListNode reverseList(ListNode head) { if (head == null || head.next == null) { return head; } ListNode p = reverseList(head.next); head.next.next = head; head.next = null; return p; } } 复杂度分析 时间复杂度：O(n)，假设 n 是列表的长度，那么时间复杂度为 O(n)。 空间复杂度：O(n)，由于使用递归，将会使用隐式栈空间。递归深度可能会达到 n 层。 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:13:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day14 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:14:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"20. 有效的括号 题目 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。 左括号必须以正确的顺序闭合。 示例 1： 输入：s = \"()\" 输出：true 示例 2： 输入：s = \"()[]{}\" 输出：true 示例 3： 输入：s = \"(]\" 输出：false 示例 4： 输入：s = \"([)]\" 输出：false 示例 5： 输入：s = \"{[]}\" 输出：true 提示： 1 \u003c= s.length \u003c= 104 s 仅由括号 '()[]{}' 组成 题解 方法一：栈 判断括号的有效性可以使用「栈」这一数据结构来解决。 我们遍历给定的字符串 s。当我们遇到一个左括号时，我们会期望在后续的遍历中，有一个相同类型的右括号将其闭合。由于后遇到的左括号要先闭合，因此我们可以将这个左括号放入栈顶。 当我们遇到一个右括号时，我们需要将一个相同类型的左括号闭合。此时，我们可以取出栈顶的左括号并判断它们是否是相同类型的括号。如果不是相同的类型，或者栈中并没有左括号，那么字符串 s 无效，返回 False。为了快速判断括号的类型，我们可以使用哈希表存储每一种括号。哈希表的键为右括号，值为相同类型的左括号。 在遍历结束后，如果栈中没有左括号，说明我们将字符串 s 中的所有左括号闭合，返回 True，否则返回 False。 注意到有效字符串的长度一定为偶数，因此如果字符串的长度为奇数，我们可以直接返回 False，省去后续的遍历判断过程。 class Solution { public boolean isValid(String s) { int n = s.length(); if (n % 2 == 1) { return false; } Map\u003cCharacter, Character\u003e pairs = new HashMap\u003cCharacter, Character\u003e() {{ put(')', '('); put(']', '['); put('}', '{'); }}; Deque\u003cCharacter\u003e stack = new LinkedList\u003cCharacter\u003e(); for (int i = 0; i \u003c n; i++) { char ch = s.charAt(i); if (pairs.containsKey(ch)) { if (stack.isEmpty() || stack.peek() != pairs.get(ch)) { return false; } stack.pop(); } else { stack.push(ch); } } return stack.isEmpty(); } } func isValid(s string) bool { stack := []byte{} leftOk:=func(ch byte) bool{ return ch=='('||ch=='['||ch=='{' } check :=func(topc,c byte) bool { return (c==')'\u0026\u0026topc=='(')||(c==']'\u0026\u0026topc=='[')||(c=='}'\u0026\u0026topc=='{') } // 遇到左括号就压入栈中，遇到右括号就从栈顶取出括号是否配对，如果不配对就返回false，配对继续遍历 for i:=0;i\u003clen(s);i++{ if leftOk(s[i]){ stack = append(stack,s[i]) }else{ if len(stack)!=0\u0026\u0026check(stack[len(stack)-1],s[i]){ stack = stack[:len(stack)-1] }else{ return false } } } // fmt.Println(string(stack)) return len(stack)==0 } 复杂度分析 时间复杂度：O(n)，其中 n 是字符串 s 的长度。 空间复杂度：O*(*n+∣Σ∣)，其中 Σ 表示字符集，本题中字符串只包含 66 种括号，∣Σ∣=6。栈中的字符数量为 O(n)，而哈希表使用的空间为 O(∣Σ∣)，相加即可得到总空间复杂度。 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:14:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day15 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:15:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"225. 用队列实现栈 题目 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。 实现 MyStack 类： void push(int x) 将元素 x 压入栈顶。 int pop() 移除并返回栈顶元素。 int top() 返回栈顶元素。 boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。 注意： 你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。 示例： 输入： [\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"] [[], [1], [2], [], [], []] 输出： [null, null, null, 2, 2, false] 解释： MyStack myStack = new MyStack(); myStack.push(1); myStack.push(2); myStack.top(); // 返回 2 myStack.pop(); // 返回 2 myStack.empty(); // 返回 False 提示： 1 \u003c= x \u003c= 9 最多调用100 次 push、pop、top 和 empty 每次调用 pop 和 top 都保证栈不为空 **进阶：**你能否仅用一个队列来实现栈。 方法 方法一：两个队列 为了满足栈的特性，即最后入栈的元素最先出栈，在使用队列实现栈时，应满足队列前端的元素是最后入栈的元素。可以使用两个队列实现栈的操作，其中 queue1 用于存储栈内的元素，queue2 作为入栈操作的辅助队列。 入栈操作时，首先将元素入队到 queue2，然后将 queue1 的全部元素依次出队并入队到 queue2，此时 queue2 的前端的元素即为新入栈的元素，再将 queue1 和 queue2 互换，则 queue1 的元素即为栈内的元素，queue1 的前端和后端分别对应栈顶和栈底。 由于每次入栈操作都确保 queue1 的前端元素为栈顶元素，因此出栈操作和获得栈顶元素操作都可以简单实现。出栈操作只需要移除 queue1 的前端元素并返回即可，获得栈顶元素操作只需要获得 queue1 的前端元素并返回即可（不移除元素）。 由于 queue1 用于存储栈内的元素，判断栈是否为空时，只需要判断 queue1 是否为空即可。 class MyStack { Queue\u003cInteger\u003e queue1; Queue\u003cInteger\u003e queue2; /** Initialize your data structure here. */ public MyStack() { queue1 = new LinkedList\u003cInteger\u003e(); queue2 = new LinkedList\u003cInteger\u003e(); } /** Push element x onto stack. */ public void push(int x) { queue2.offer(x); while (!queue1.isEmpty()) { queue2.offer(queue1.poll()); } Queue\u003cInteger\u003e temp = queue1; queue1 = queue2; queue2 = temp; } /** Removes the element on top of the stack and returns that element. */ public int pop() { return queue1.poll(); } /** Get the top element. */ public int top() { return queue1.peek(); } /** Returns whether the stack is empty. */ public boolean empty() { return queue1.isEmpty(); } } 复杂度分析 时间复杂度：入栈操作 O(n)，其余操作都是 O(1)，其中 n 是栈内的元素个数。 入栈操作需要将 queue1 中的 n 个元素出队，并入队 n+1 个元素到 queue2，共有 2n+1 次操作，每次出队和入队操作的时间复杂度都是 O(1)，因此入栈操作的时间复杂度是 O(n)。 出栈操作对应将 queue1 的前端元","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:15:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day16 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:16:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"232. 用栈实现队列 题目 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）： 实现 MyQueue 类： void push(int x) 将元素 x 推到队列的末尾 int pop() 从队列的开头移除并返回元素 int peek() 返回队列开头的元素 boolean empty() 如果队列为空，返回 true ；否则，返回 false 说明： 你 只能 使用标准的栈操作 —— 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。 示例 1： 输入： [\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"] [[], [1], [2], [], [], []] 输出： [null, null, null, 1, 1, false] 解释： MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.peek(); // return 1 myQueue.pop(); // return 1, queue is [2] myQueue.empty(); // return false 提示： 1 \u003c= x \u003c= 9 最多调用 100 次 push、pop、peek 和 empty 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作） 进阶： 你能否实现每个操作均摊时间复杂度为 O(1) 的队列？换句话说，执行 n 个操作的总时间复杂度为 O(n) ，即使其中一个操作可能花费较长时间。 方法 https://leetcode.cn/problems/implement-queue-using-stacks/solution/yong-zhan-shi-xian-dui-lie-by-leetcode/ 代码 class MyQueue { Stack\u003cInteger\u003e s1; Stack\u003cInteger\u003e s2; public MyQueue() { this.s1=new Stack\u003c\u003e(); this.s2=new Stack\u003c\u003e(); } public void push(int x) { s1.push(x); } public int pop() { while(s1.size()!=0){ s2.push(s1.pop()); } int res=s2.pop(); while(s2.size()!=0){ s1.push(s2.pop()); } return res; } public int peek() { while(s1.size()!=0){ s2.push(s1.pop()); } int res=s2.peek(); while(s2.size()!=0){ s1.push(s2.pop()); } return res; } public boolean empty() { return s1.empty(); } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:16:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day17 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:17:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"239. 滑动窗口最大值 题目 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。 返回 滑动窗口中的最大值 。 示例 1： 输入：nums = [1,3,-1,-3,5,3,6,7], k = 3 输出：[3,3,5,5,6,7] 解释： 滑动窗口的位置 最大值 --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 示例 2： 输入：nums = [1], k = 1 输出：[1] 提示： 1 \u003c= nums.length \u003c= 105 -104 \u003c= nums[i] \u003c= 104 1 \u003c= k \u003c= nums.length 方法一（超时） 暴力解法，依次移动窗口，不断寻找最大值，当然可以取巧：每一次只滑动一个索引位置，因此，每一次滑动窗口内的数已经知道了最大的数。如果最大的数还在下一次滑动窗口内，那么就可以利用这个属性，只需要比较上次滑动窗口的最大值和这次滑动窗口的末尾索引处的值，就可以得出下一次滑动窗口的最大值了，而不用傻乎乎的重复比较。当然，还是超时了… class Solution { public int[] maxSlidingWindow(int[] nums, int k) { int len=nums.length; int max=Integer.MIN_VALUE; int index=-1; int[] arr = new int[len-k+1]; for(int i=0;i\u003clen-k+1;i++){ if(index!=0){ if(max\u003cnums[i+k-1]){ max=nums[i+k-1]; } } max=Integer.MIN_VALUE; index=-1; for(int j=i;j\u003ci+k;j++){ if(max\u003cnums[j]){ max=nums[j]; index=j; } } arr[i]=max; } return arr; } } /** 已经知道上一个最大的数了， 记录这个最大的数的位置如果不是窗口的第一位，显然具有利用价值： 无需比较上次窗口的最后一位，只需要比较窗口的下一位即可。 */ 其他方法 优先队列、单调队列（双端队列的特殊情况） https://leetcode.cn/problems/sliding-window-maximum/solution/hua-dong-chuang-kou-zui-da-zhi-by-leetco-ki6m/ ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:17:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day18 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:18:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"1047. 删除字符串中的所有相邻重复项 题目 给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。 在 S 上反复执行重复项删除操作，直到无法继续删除。 在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。 示例： 输入：\"abbaca\" 输出：\"ca\" 解释： 例如，在 \"abbaca\" 中，我们可以删除 \"bb\" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 \"aaca\"，其中又只有 \"aa\" 可以执行重复项删除操作，所以最后的字符串为 \"ca\"。 提示： 1 \u003c= S.length \u003c= 20000 S 仅由小写英文字母组成。 解法 方法一：栈 充分理解题意后，我们可以发现，当字符串中同时有多组相邻重复项时，我们无论是先删除哪一个，都不会影响最终的结果。因此我们可以从左向右顺次处理该字符串。 而消除一对相邻重复项可能会导致新的相邻重复项出现，如从字符串 abba 中删除 bb 会导致出现新的相邻重复项 aa 出现。因此我们需要保存当前还未被删除的字符。一种显而易见的数据结构呼之欲出：栈。我们只需要遍历该字符串，如果当前字符和栈顶字符相同，我们就贪心地将其消去，否则就将其入栈即可。 代码 class Solution { public String removeDuplicates(String s) { StringBuffer stack = new StringBuffer(); int top = -1; for (int i = 0; i \u003c s.length(); ++i) { char ch = s.charAt(i); if (top \u003e= 0 \u0026\u0026 stack.charAt(top) == ch) { stack.deleteCharAt(top); --top; } else { stack.append(ch); ++top; } } return stack.toString(); } } 复杂度分析 时间复杂度：O(n)，其中 n 是字符串的长度。我们只需要遍历该字符串一次。 空间复杂度：O(n) 或 O(1))，取决于使用的语言提供的字符串类是否提供了类似「入栈」和「出栈」的接口。注意返回值不计入空间复杂度。 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:18:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day19 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:19:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"151. 颠倒字符串中的单词 题目 给你一个字符串 s ，颠倒字符串中 单词 的顺序。 单词 是由非空格字符组成的字符串。s 中使用至少一个空格将字符串中的 单词 分隔开。 返回 单词 顺序颠倒且 单词 之间用单个空格连接的结果字符串。 **注意：**输入字符串 s中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。 示例 1： 输入：s = \"the sky is blue\" 输出：\"blue is sky the\" 示例 2： 输入：s = \" hello world \" 输出：\"world hello\" 解释：颠倒后的字符串中不能存在前导空格和尾随空格。 示例 3： 输入：s = \"a good example\" 输出：\"example good a\" 解释：如果两个单词间有多余的空格，颠倒后的字符串需要将单词间的空格减少到仅有一个。 提示： 1 \u003c= s.length \u003c= 104 s 包含英文大小写字母、数字和空格 ' ' s 中 至少存在一个 单词 方法一 思路： 去除首部空格 将空格之间的子串追加到字符串累加器并附带一个空格 追加完过后，再以空格分隔字符串 倒序数组，追加空格即可 代码：（空间复杂度较高） class Solution { public String reverseWords(String s) { char[] chs = s.toCharArray(); char prev = 0; StringBuilder stringBuilder = new StringBuilder(); int index=-1; for (int i = 0; i \u003c s.length(); i++) { if (chs[i]!=' '){ index=i; break; } } for (int i = index; i \u003c chs.length; i++) { if (chs[i] == ' ' \u0026\u0026 prev == ' ') {//如果当前字符和上一个字符为' ', continue; } stringBuilder.append(chs[i]); prev = chs[i]; } String str = stringBuilder.toString(); String[] split = str.split(\" \"); stringBuilder = new StringBuilder(); for (int i = split.length - 1; i \u003e 0; i--) { stringBuilder.append(split[i]).append(' '); } stringBuilder.append(split[0]); return stringBuilder.toString(); } } 方法二 https://leetcode.cn/problems/reverse-words-in-a-string/solution/fan-zhuan-zi-fu-chuan-li-de-dan-ci-by-leetcode-sol/ ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:19:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day20 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:20:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"541. 反转字符串 II 题目 给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。 如果剩余字符少于 k 个，则将剩余字符全部反转。 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。 示例 1： 输入：s = \"abcdefg\", k = 2 输出：\"bacdfeg\" 示例 2： 输入：s = \"abcd\", k = 2 输出：\"bacd\" 提示： 1 \u003c= s.length \u003c= 104 s 仅由小写英文组成 1 \u003c= k \u003c= 104 方法 方法一：模拟 我们直接按题意进行模拟：反转每个下标从 2k2k 的倍数开始的，长度为 kk 的子串。若该子串长度不足 kk，则反转整个子串。 class Solution { public String reverseStr(String s, int k) { int n = s.length(); char[] arr = s.toCharArray(); for (int i = 0; i \u003c n; i += 2 * k) { reverse(arr, i, Math.min(i + k, n) - 1); } return new String(arr); } public void reverse(char[] arr, int left, int right) { while (left \u003c right) { char temp = arr[left]; arr[left] = arr[right]; arr[right] = temp; left++; right--; } } } 复杂度分析 时间复杂度：O(n)，其中 n 是字符串 s 的长度。 空间复杂度：O(1) 或 O(n)，取决于使用的语言中字符串类型的性质。如果字符串是可修改的，那么我们可以直接在原字符串上修改，空间复杂度为 O(1)，否则需要使用 O(n) 的空间将字符串临时转换为可以修改的数据结构（例如数组），空间复杂度为 O(n)。 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:20:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day21 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:21:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"1. 两数之和 题目 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1： 输入：nums = [2,7,11,15], target = 9 输出：[0,1] 解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。 示例 2： 输入：nums = [3,2,4], target = 6 输出：[1,2] 示例 3： 输入：nums = [3,3], target = 6 输出：[0,1] 提示： 2 \u003c= nums.length \u003c= 104 -109 \u003c= nums[i] \u003c= 109 -109 \u003c= target \u003c= 109 只会存在一个有效答案 **进阶：**你可以想出一个时间复杂度小于 O(n2) 的算法吗？ 方法 方法一：暴力枚举 思路及算法 最容易想到的方法是枚举数组中的每一个数 x，寻找数组中是否存在 target - x。当我们使用遍历整个数组的方式寻找 target - x 时，需要注意到每一个位于 x 之前的元素都已经和 x 匹配过，因此不需要再进行匹配。而每一个元素不能被使用两次，所以我们只需要在 x 后面的元素中寻找 target - x。 代码 class Solution { public int[] twoSum(int[] nums, int target) { int n = nums.length; for (int i = 0; i \u003c n; ++i) { for (int j = i + 1; j \u003c n; ++j) { if (nums[i] + nums[j] == target) { return new int[]{i, j}; } } } return new int[0]; } } 复杂度分析 时间复杂度：O(N^2^)，其中 N 是数组中的元素数量。最坏情况下数组中任意两个数都要被匹配一次。 空间复杂度：O(1)。 方法二：哈希表 思路及算法 此题，如果使用方法一，显然时间复杂度过高。结合题意：在一堆值里找一个值，应该考虑转化为hash的数据结构，hash的时间复杂度为O(1) 注意到方法一的时间复杂度较高的原因是寻找 target - x 的时间复杂度过高。因此，我们需要一种更优秀的方法，能够快速寻找数组中是否存在目标元素。如果存在，我们需要找出它的索引。使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N) 降低到 O(1)。这样我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在 target - x，然后将 x 插入到哈希表中，即可保证不会让 x 和自己匹配。 代码 class Solution { public int[] twoSum(int[] nums, int target) { Map\u003cInteger, Integer\u003e hashtable = new HashMap\u003cInteger, Integer\u003e(); for (int i = 0; i \u003c nums.length; ++i) { // 将此处的n次循环变为1次即可得到结果，这就是hash的好处 if (hashtable.containsKey(target - nums[i])) { return new int[]{hashtable.get(target - nums[i]), i}; } hashtable.put(nums[i], i); } return new int[0]; } } 复杂度分析 时间复杂度：O(N)，其中 N 是数组中的元素数量。对于每一个元素 x，我们可以 O(1) 地寻找 target - x。 空间复杂度：O(N)，其中 N 是数组中的元素数量。主要为哈希表的开销。 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:21:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day22 15. 三数之和 题目 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 *a，b，c ，*使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。 **注意：**答案中不可以包含重复的三元组。 示例 1： 输入：nums = [-1,0,1,2,-1,-4] 输出：[[-1,-1,2],[-1,0,1]] 示例 2： 输入：nums = [] 输出：[] 示例 3： 输入：nums = [0] 输出：[] 提示： 0 \u003c= nums.length \u003c= 3000 -105 \u003c= nums[i] \u003c= 105 解法 方法一：排序 + 双指针 题目中要求找到所有「不重复」且和为 0 的三元组，这个「不重复」的要求使得我们无法简单地使用三重循环枚举所有的三元组。这是因为在最坏的情况下，数组中的元素全部为 0，即 [0, 0, 0, 0, 0, ..., 0, 0, 0] 任意一个三元组的和都为 00。如果我直接使用三重循环枚举三元组，会得到 O(N^3^) 个满足题目要求的三元组（其中 N 是数组的长度）时间复杂度至少为 O(N^3^)。在这之后，我们还需要使用哈希表进行去重操作，得到不包含重复三元组的最终答案，又消耗了大量的空间。这个做法的时间复杂度和空间复杂度都很高，因此我们要换一种思路来考虑这个问题。 「不重复」的本质是什么？我们保持三重循环的大框架不变，只需要保证： 第二重循环枚举到的元素不小于当前第一重循环枚举到的元素； 第三重循环枚举到的元素不小于当前第二重循环枚举到的元素。 也就是说，我们枚举的三元组 (a, b, c) 满足 a≤b≤c，保证了只有 (a, b, c) 这个顺序会被枚举到，而 (b, a, c)、(c, b, a) 等等这些不会，这样就减少了重复。要实现这一点，我们可以将数组中的元素从小到大进行排序，随后使用普通的三重循环就可以满足上面的要求。 同时，对于每一重循环而言，相邻两次枚举的元素不能相同，否则也会造成重复。举个例子，如果排完序的数组为 [0, 1, 2, 2, 2, 3] ^ ^ ^ 我们使用三重循环枚举到的第一个三元组为 (0, 1, 2)，如果第三重循环继续枚举下一个元素，那么仍然是三元组 (0, 1, 2)，产生了重复。因此我们需要将第三重循环「跳到」下一个不相同的元素，即数组中的最后一个元素 3，枚举三元组 (0, 1, 3)。 下面给出了改进的方法的伪代码实现： nums.sort() for first = 0 .. n-1 // 只有和上一次枚举的元素不相同，我们才会进行枚举 if first == 0 or nums[first] != nums[first-1] then for second = first+1 .. n-1 if second == first+1 or nums[second] != nums[second-1] then for third = second+1 .. n-1 if third == second+1 or nums[third] != nums[third-1] then // 判断是否有 a+b+c==0 check(first, second, third) 这种方法的时间复杂度仍然为 O(N^3^)，毕竟我们还是没有跳出三重循环的大框架。然而它是很容易继续优化的，可以发现，如果我们固定了前两重循环枚举到的元素 a 和 b，那么只有唯一的 c 满足 a+b+c=0。当第二重循环往后枚举一个元素 b’ 时，由于 b’ \u003e b，那么满足 a+b’+c’=0 的 c’ 一定有 c’ \u003c c，即 c’ 在数组中一定出现在 c 的左侧。也就是说，我们可以从小到大枚举 b，同时从大到小枚举 c，即第二重循环和第三重循环实际上是并列的关系。 有了这样的发现，我们就可以保持第二重循环不变，而将第三重循环变成一个从数组最右端开始向左移动的指针，从而得到下面的伪代码： nums.sort() for first = 0 .. n-1 if first == 0 or nums[first] != nums[first-1] then // 第三重循环对应的指针 third = n-1 for second = first+1 .. n-1 if second == first+1 or nums[second] != nums[second-1] then // 向左移动指针，直到 a+b+c 不大于 0 while nums[first]+nums[second]+nums[third] \u003e 0 third = third-1 // 判断是否有 a+b+c==0 check(first","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:22:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day23 202. 快乐数 题目 编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」 定义为： 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。 然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。 如果这个过程 结果为 1，那么这个数就是快乐数。 如果 n 是 快乐数 就返回 true ；不是，则返回 false 。 示例 1： 输入：n = 19 输出：true 解释： 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 示例 2： 输入：n = 2 输出：false 提示： 1 \u003c= n \u003c= 231 - 1 解法 暴力错误且超时 class Solution { public boolean isHappy(int n) { int tmp=n; while(true){ tmp=get(tmp); if(tmp==n) return false; else if(tmp==1) return true; } } public int get(int n) { int tmp=n; int sum=0; int r=0; while(tmp!=0){ r = tmp%10; sum = r*r+sum; tmp = tmp/10; } return sum; } } 超时的原因在于：条件判断错误，不是一定要出现到初始数字才会陷入死循环，有可能是中途的某个节点出现循环，例如：数字116 显然，需要使用弗洛伊德判圈算法（龟兔赛跑算法）–\u003e 快慢指针法：一个快指针和一个慢指针同时出发，如果快指针追上了慢指针说明是一个死循环，就返回false 快慢指针法 class Solution { public boolean isHappy(int n) { int slowRunner = n; int fastRunner = getNext(n); while (fastRunner != 1 \u0026\u0026 slowRunner != fastRunner) { slowRunner = getNext(slowRunner); fastRunner = getNext(getNext(fastRunner)); } return fastRunner == 1; } public int getNext(int n) { int tmp=n; int sum=0; int r=0; while(tmp!=0){ r = tmp%10; sum = r*r+sum; tmp = tmp/10; } return sum; } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:23:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day24 454. 四数相加 II 题目 给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足： 0 \u003c= i, j, k, l \u003c n nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0 示例 1： 输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2] 输出：2 解释： 两个元组如下： 1. (0, 0, 0, 1) -\u003e nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0 2. (1, 1, 0, 0) -\u003e nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0 示例 2： 输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0] 输出：1 提示： n == nums1.length n == nums2.length n == nums3.length n == nums4.length 1 \u003c= n \u003c= 200 -228 \u003c= nums1[i], nums2[i], nums3[i], nums4[i] \u003c= 228 解法：分组+hash表 思路与算法 我们可以将四个数组分成两部分，A 和 B 为一组，C 和 D 为另外一组。 对于 A 和 B，我们使用二重循环对它们进行遍历，得到所有 A[i]+B[j] 的值并存入哈希映射中。对于哈希映射中的每个键值对，每个键表示一种 A[i]+B[j]，对应的值为 A[i]+B[j] 出现的次数。 对于 CC 和 DD，我们同样使用二重循环对它们进行遍历。当遍历到 C[k]+D[l] 时，如果 -(C[k]+D[l]) 出现在哈希映射中，那么将 -(C[k]+D[l]) 对应的值累加进答案中。 最终即可得到满足 A[i]+B[j]+C[k]+D[l]=0 的四元组数目。 代码 class Solution { public int fourSumCount(int[] A, int[] B, int[] C, int[] D) { Map\u003cInteger, Integer\u003e countAB = new HashMap\u003cInteger, Integer\u003e(); for (int u : A) { for (int v : B) { countAB.put(u + v, countAB.getOrDefault(u + v, 0) + 1); } } int ans = 0; for (int u : C) { for (int v : D) { if (countAB.containsKey(-u - v)) { ans += countAB.get(-u - v); } } } return ans; } } 复杂度分析 时间复杂度：O(n^2^)。我们使用了两次二重循环，时间复杂度均为 O(n^2^)。在循环中对哈希映射进行的修改以及查询操作的期望时间复杂度均为 O(1)，因此总时间复杂度为 O(n^2^)。 空间复杂度：O(n^2^)，即为哈希映射需要使用的空间。在最坏的情况下，A[i]+B[j] 的值均不相同，因此值的个数为 n^2^，也就需要 O(n^2^) 的空间。 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:24:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day25 100. 相同的树 题目 给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。 如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。 示例 1： 输入：p = [1,2,3], q = [1,2,3] 输出：true 示例 2： 输入：p = [1,2], q = [1,null,2] 输出：false 示例 3： 输入：p = [1,2,1], q = [1,1,2] 输出：false 提示： 两棵树上的节点数目都在范围 [0, 100] 内 -104 \u003c= Node.val \u003c= 104 解法 两个二叉树相同，当且仅当两个二叉树的结构完全相同，且所有对应节点的值相同。因此，可以通过搜索的方式判断两个二叉树是否相同。 方法一：深度优先搜索 如果两个二叉树都为空，则两个二叉树相同。如果两个二叉树中有且只有一个为空，则两个二叉树一定不相同。 如果两个二叉树都不为空，那么首先判断它们的根节点的值是否相同，若不相同则两个二叉树一定不同，若相同，再分别判断两个二叉树的左子树是否相同以及右子树是否相同。这是一个递归的过程，因此可以使用深度优先搜索，递归地判断两个二叉树是否相同。 class Solution { public boolean isSameTree(TreeNode p, TreeNode q) { if (p == null \u0026\u0026 q == null) { return true; } else if (p == null || q == null) { return false; } else if (p.val != q.val) { return false; } else { return isSameTree(p.left, q.left) \u0026\u0026 isSameTree(p.right, q.right); } } } 复杂度分析 时间复杂度：O(min(m,n))，其中 m 和 n 分别是两个二叉树的节点数。对两个二叉树同时进行深度优先搜索，只有当两个二叉树中的对应节点都不为空时才会访问到该节点，因此被访问到的节点数不会超过较小的二叉树的节点数。 空间复杂度：O(min(m,n))，其中 m 和 n 分别是两个二叉树的节点数。空间复杂度取决于递归调用的层数，递归调用的层数不会超过较小的二叉树的最大高度，最坏情况下，二叉树的高度等于节点数。 方法二：广度优先搜索 也可以通过广度优先搜索判断两个二叉树是否相同。同样首先判断两个二叉树是否为空，如果两个二叉树都不为空，则从两个二叉树的根节点开始广度优先搜索。 使用两个队列分别存储两个二叉树的节点。初始时将两个二叉树的根节点分别加入两个队列。每次从两个队列各取出一个节点，进行如下比较操作。 比较两个节点的值，如果两个节点的值不相同则两个二叉树一定不同； 如果两个节点的值相同，则判断两个节点的子节点是否为空，如果只有一个节点的左子节点为空，或者只有一个节点的右子节点为空，则两个二叉树的结构不同，因此两个二叉树一定不同； 如果两个节点的子节点的结构相同，则将两个节点的非空子节点分别加入两个队列，子节点加入队列时需要注意顺序，如果左右子节点都不为空，则先加入左子节点，后加入右子节点。 如果搜索结束时两个队列同时为空，则两个二叉树相同。如果只有一个队列为空，则两个二叉树的结构不同，因此两个二叉树不同。 class Solution { public boolean isSameTree(TreeNode p, TreeNode q) { if (p == null \u0026\u0026 q == null) { return true; } else if (p == null || q == null) { return false; } Queue\u003cTreeNode\u003e queue1 = new LinkedList\u003cTreeNode\u003e(); Queue\u003cTreeNode\u003e queue2 = new LinkedList\u003cTreeNode\u003e(); queue1.offer(p); queue2.offer(q); while (!queue1.isEmpty() \u0026\u0026 !queue2.isEmpty()) { TreeNode node1 = queue1.poll(); TreeNode node2 = queue2.poll(); if (node1.val != node2.val) { return false; } TreeNode left1 = node1.left, right1 = node1.right, left2 = node2.left, right2 = node2.right; if (left1 == null ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:25:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day26 101. 对称二叉树 题目 给你一个二叉树的根节点 root ， 检查它是否轴对称。 示例 1： 输入：root = [1,2,2,3,4,4,3] 输出：true 示例 2： 输入：root = [1,2,2,null,3,null,3] 输出：false 提示： 树中节点数目在范围 [1, 1000] 内 -100 \u003c= Node.val \u003c= 100 **进阶：**你可以运用递归和迭代两种方法解决这个问题吗？ 解法 方法一：递归 思路和算法 如果一个树的左子树与右子树镜像对称，那么这个树是对称的。 因此，该问题可以转化为：两个树在什么情况下互为镜像？ 如果同时满足下面的条件，两个树互为镜像： 它们的两个根结点具有相同的值 每个树的右子树都与另一个树的左子树镜像对称 我们可以实现这样一个递归函数，通过「同步移动」两个指针的方法来遍历这棵树，p 指针和 q 指针一开始都指向这棵树的根，随后 p 右移时，q 左移，p 左移时，q 右移。每次检查当前 p 和 q 节点的值是否相等，如果相等再判断左右子树是否对称。 代码如下： class Solution { public boolean isSymmetric(TreeNode root) { return check(root.left, root.right); } public boolean check(TreeNode p, TreeNode q) { if (p == null \u0026\u0026 q == null) { return true; }else if (p == null || q == null) { return false; }else if (p.val != q.val ){ return false; } return check(p.left, q.right) \u0026\u0026 check(p.right, q.left); // 就是看左子树和右子树节点是否相同 } } 复杂度分析 假设树上一共 n 个节点。 时间复杂度：这里遍历了这棵树，渐进时间复杂度为 O(n)。 空间复杂度：这里的空间复杂度和递归使用的栈空间有关，这里递归层数不超过 n，故渐进空间复杂度为 O(n)。 方法二：迭代 思路和算法 「方法一」中我们用递归的方法实现了对称性的判断，那么如何用迭代的方法实现呢？首先我们引入一个队列，这是把递归程序改写成迭代程序的常用方法。初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。 class Solution { public boolean isSymmetric(TreeNode root) { return check(root, root); } public boolean check(TreeNode u, TreeNode v) { Queue\u003cTreeNode\u003e q = new LinkedList\u003cTreeNode\u003e(); q.offer(u); q.offer(v); while (!q.isEmpty()) { u = q.poll(); v = q.poll(); if (u == null \u0026\u0026 v == null) { continue; } if ((u == null || v == null) || (u.val != v.val)) { return false; } // 核心代码 q.offer(u.left); q.offer(v.right); q.offer(u.right); q.offer(v.left); } return true; } } 复杂度分析 时间复杂度：O(n)，同「方法一」。 空间复杂度：这里需要用一个队列来维护节点，每个节点最多进队一次，出队一次，队列中最多不会超过 n 个点，故渐进空间复杂度为 O(n)。 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:26:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day27 104. 二叉树的最大深度 题目 给定一个二叉树，找出其最大深度。 二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。 说明: 叶子节点是指没有子节点的节点。 示例： 给定二叉树 [3,9,20,null,null,15,7]， 3 / \\ 9 20 / \\ 15 7 返回它的最大深度 3 。 解法 方法一：深度优先搜索 思路与算法 如果我们知道了左子树和右子树的最大深度 l 和 r，那么该二叉树的最大深度即为max(l,r)+1 而左子树和右子树的最大深度又可以以同样的方式进行计算。因此我们可以用「深度优先搜索」的方法来计算二叉树的最大深度。具体而言，在计算当前二叉树的最大深度时，可以先递归计算出其左子树和右子树的最大深度，然后在 O(1) 时间内计算出当前二叉树的最大深度。递归在访问到空节点时退出。 class Solution { public int maxDepth(TreeNode root) { if (root == null) { return 0; } else { int leftHeight = maxDepth(root.left); int rightHeight = maxDepth(root.right); return Math.max(leftHeight, rightHeight) + 1; } } } 复杂度分析 时间复杂度：O(n)，其中 n 为二叉树节点的个数。每个节点在递归中只被遍历一次。 空间复杂度：O(height)，其中 height 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。 方法二：广度优先搜索 思路与算法 我们也可以用「广度优先搜索」的方法来解决这道题目，但我们需要对其进行一些修改，此时我们广度优先搜索的队列里存放的是「当前层的所有节点」。每次拓展下一层的时候，不同于广度优先搜索的每次只从队列里拿出一个节点，我们需要将队列里的所有节点都拿出来进行拓展，这样能保证每次拓展完的时候队列里存放的是当前层的所有节点，即我们是一层一层地进行拓展，最后我们用一个变量 ans 来维护拓展的次数，该二叉树的最大深度即为 ans。 class Solution { public int maxDepth(TreeNode root) { if (root == null) { return 0; } Queue\u003cTreeNode\u003e queue = new LinkedList\u003cTreeNode\u003e(); queue.offer(root); int ans = 0; while (!queue.isEmpty()) { int size = queue.size(); while (size \u003e 0) { TreeNode node = queue.poll(); if (node.left != null) { queue.offer(node.left); } if (node.right != null) { queue.offer(node.right); } size--; } ans++; } return ans; } } /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func maxDepth(root *TreeNode) int { if root==nil { return 0 } depth:=0 queue:=[]*TreeNode{root} for len(queue)!=0{ n:=len(queue) for i:=0;i\u003cn;i++{ node:=queue[i] // fmt.Println(node.Val) if node.Left!=nil{ queue=append(queue,node.Left) } if node.Right!=nil{ queue=append(queue,node.Right) } } queue=queue[n:] depth++ } return depth } 复杂度分析 时间复杂度：O(n)，其中 n 为二叉树的节点个数。与方法一同样的分析，每个节点只会被访问一次。 空间复杂度：此方法空间的消耗取决于队列存储的元素数量，其在最坏情况下会达到 O(n)。 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:27:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day28 111. 二叉树的最小深度 题目 给定一个二叉树，找出其最小深度。 最小深度是从根节点到最近叶子节点的最短路径上的节点数量。 **说明：**叶子节点是指没有子节点的节点。 示例 1： 输入：root = [3,9,20,null,null,15,7] 输出：2 示例 2： 输入：root = [2,null,3,null,4,null,5,null,6] 输出：5 提示： 树中节点数的范围在 [0, 105] 内 -1000 \u003c= Node.val \u003c= 1000 解法 方法一：深度优先搜索 思路及解法 首先可以想到使用深度优先搜索的方法，遍历整棵树，记录最小深度。 对于每一个非叶子节点，我们只需要分别计算其左右子树的最小叶子节点深度。这样就将一个大问题转化为了小问题，可以递归地解决该问题。 代码 class Solution { public int minDepth(TreeNode root) { if (root==null) return 0; int l=Integer.MAX_VALUE; int r=Integer.MAX_VALUE; if (root.left==null\u0026\u0026root.right==null) return 1; if (root.left!=null){ l=minDepth(root.left)+1; } if(root.right!=null){ // System.out.println(root.val); r=minDepth(root.right)+1; } return l\u003er?r:l; } } 复杂度分析 时间复杂度：O(N)，其中 N 是树的节点数。对每个节点访问一次。 空间复杂度：O(H)，其中 H 是树的高度。空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为 O(N)。平均情况下树的高度与节点数的对数正相关，空间复杂度为 O(log N)。 方法二：广度优先搜索 思路及解法 同样，我们可以想到使用广度优先搜索的方法，遍历整棵树。 当我们找到一个叶子节点时，直接返回这个叶子节点的深度。广度优先搜索的性质保证了最先搜索到的叶子节点的深度一定最小。 代码 class Solution { public int minDepth(TreeNode root) { if (root==null) return 0; if (root.left==null\u0026\u0026root.right==null) return 1; int layerNum=1; Queue\u003cTreeNode\u003e queue=new LinkedList\u003c\u003e(); queue.offer(root); while(!queue.isEmpty()){ int size = queue.size(); while(size\u003e0){ TreeNode node = queue.poll(); if(node.left==null\u0026\u0026node.right==null) return layerNum; if(node.left!=null) queue.offer(node.left); if(node.right!=null) queue.offer(node.right); size--; } layerNum++; } return layerNum; } } 复杂度分析 时间复杂度：O(N)，其中 N 是树的节点数。对每个节点访问一次。 空间复杂度：O(N)，其中 N 是树的节点数。空间复杂度主要取决于队列的开销，队列中的元素个数不会超过树的节点数。 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:28:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day29 112. 路径总和 题目 给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。 叶子节点 是指没有子节点的节点。 示例 1： 输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 输出：true 解释：等于目标和的根节点到叶节点路径如上图所示。 示例 2： 输入：root = [1,2,3], targetSum = 5 输出：false 解释：树中存在两条根节点到叶子节点的路径： (1 --\u003e 2): 和为 3 (1 --\u003e 3): 和为 4 不存在 sum = 5 的根节点到叶子节点的路径。 示例 3： 输入：root = [], targetSum = 0 输出：false 解释：由于树是空的，所以不存在根节点到叶子节点的路径。 提示： 树中节点的数目在范围 [0, 5000] 内 -1000 \u003c= Node.val \u003c= 1000 -1000 \u003c= targetSum \u003c= 1000 解法 写在前面 注意到本题的要求是，询问是否有从「根节点」到某个「叶子节点」经过的路径上的节点之和等于目标和。核心思想是对树进行一次遍历，在遍历时记录从根节点到当前节点的路径和，以防止重复计算。 需要特别注意的是，给定的 root 可能为空。 方法一：广度优先搜索 思路及算法 首先我们可以想到使用广度优先搜索的方式，记录从根节点到当前节点的路径和，以防止重复计算。 这样我们使用两个队列，分别存储将要遍历的节点，以及根节点到这些节点的路径和即可。 代码 class Solution { public boolean hasPathSum(TreeNode root, int sum) { if (root == null) { return false; } Queue\u003cTreeNode\u003e queNode = new LinkedList\u003c\u003e(); Queue\u003cInteger\u003e queVal = new LinkedList\u003c\u003e(); queNode.offer(root); queVal.offer(root.val); while (!queNode.isEmpty()) { TreeNode now = queNode.poll(); int temp = queVal.poll(); if (now.left == null \u0026\u0026 now.right == null) { if (temp == sum) { return true; } continue; } if (now.left != null) { queNode.offer(now.left); queVal.offer(now.left.val + temp); } if (now.right != null) { queNode.offer(now.right); queVal.offer(now.right.val + temp); } } return false; } } 复杂度分析 时间复杂度：O(N)，其中 N 是树的节点数。对每个节点访问一次。 空间复杂度：O(N)，其中 N 是树的节点数。空间复杂度主要取决于队列的开销，队列中的元素个数不会超过树的节点数。 方法二：递归 思路及算法 观察要求我们完成的函数，我们可以归纳出它的功能：询问是否存在从当前节点 root 到叶子节点的路径，满足其路径和为 sum。 假定从根节点到当前节点的值之和为 val，我们可以将这个大问题转化为一个小问题：是否存在从当前节点的子节点到叶子的路径，满足其路径和为 sum - val。 不难发现这满足递归的性质，若当前节点就是叶子节点，那么我们直接判断 sum 是否等于 val 即可（因为路径和已经确定，就是当前节点的值，我们只需要判断该路径和是否满足条件）。若当前节点不是叶子节点，我们只需要递归地询问它的子节点是否能满足条件即可。 代码 class Solution { public boolean hasPathSum(TreeNode root, int sum) { if (root == null) { return false; } if (root.left == null \u0026\u0026 root.right == null) { return sum == root.val; } return hasPathSum(root.left, sum - root.val) || hasPathSum(r","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:29:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day30 222. 完全二叉树的节点个数 题目 给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。 完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。 示例 1： 输入：root = [1,2,3,4,5,6] 输出：6 示例 2： 输入：root = [] 输出：0 示例 3： 输入：root = [1] 输出：1 提示： 树中节点的数目范围是[0, 5 * 104] 0 \u003c= Node.val \u003c= 5 * 104 题目数据保证输入的树是 完全二叉树 **进阶：**遍历树来统计节点是一种时间复杂度为 O(n) 的简单解决方案。你可以设计一个更快的算法吗？ 解法 方法一：深度优先遍历 class Solution { public int countNodes(TreeNode root) { if(root == null) { return 0; } int left = countNodes(root.left); int right = countNodes(root.right); return left+right+1; } } 方法二：广度优先遍历 一如既往，广度优先貌似硬是要比深度优先慢一些 class Solution { public int countNodes(TreeNode root) { if (root==null) return 0; Queue\u003cTreeNode\u003e queue=new LinkedList\u003c\u003e(); int count=0; queue.offer(root); while(!queue.isEmpty()){ int size = queue.size(); while(size\u003e0){ TreeNode n = queue.poll(); if (n!=null) count++; if (n.left!=null) queue.offer(n.left); if (n.right!=null) queue.offer(n.right); size--; } } return count; } } 方法三：二分查找 + 位运算 对于任意二叉树，都可以通过广度优先搜索或深度优先搜索计算节点个数，时间复杂度和空间复杂度都是 O(n)，其中 n 是二叉树的节点个数。这道题规定了给出的是完全二叉树，因此可以利用完全二叉树的特性计算节点个数。 规定根节点位于第 0 层，完全二叉树的最大层数为 h。根据完全二叉树的特性可知，完全二叉树的最左边的节点一定位于最底层，因此从根节点出发，每次访问左子节点，直到遇到叶子节点，该叶子节点即为完全二叉树的最左边的节点，经过的路径长度即为最大层数 h。 当 0≤i\u003ch 时，第 i 层包含 2^i^ 个节点，最底层包含的节点数最少为 1，最多为 2^h^。 当最底层包含 1 个节点时，完全二叉树的节点个数是 $$ \\sum_{i=0}^{h-1}2^i+1=2^h $$ 当最底层包含 2^h^ 个节点时，完全二叉树的节点个数是 $$ \\sum_{i=0}^{h}2^i=2^{h+1}-1 $$ 因此对于最大层数为 h 的完全二叉树，节点个数一定在 [2^h^,2^h+1^-1] 的范围内，可以在该范围内通过二分查找的方式得到完全二叉树的节点个数。 具体做法是，根据节点个数范围的上下界得到当前需要判断的节点个数 k，如果第 k 个节点存在，则节点个数一定大于或等于 k，如果第 k 个节点不存在，则节点个数一定小于 k，由此可以将查找的范围缩小一半，直到得到节点个数。 如何判断第 k 个节点是否存在呢？如果第 k 个节点位于第 h 层，则 k 的二进制表示包含 h+1 位，其中最高位是 1，其余各位从高到低表示从根节点到第 k 个节点的路径，0 表示移动到左子节点，1 表示移动到右子节点。通过位运算得到第 k 个节点对应的路径，判断该路径对应的节点是否存在，即可判断第 k 个节点是否存在。 class Solution { public int countNodes(TreeNode root) { if (root == null) { return 0; } int level = 0; TreeNode node = root; while (node.left != null) { level++; node = node.left; } int low = 1 \u003c\u003c level, high = (1 \u003c\u003c (level + 1)) - 1; while (low \u003c high) ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:30:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day31 226. 翻转二叉树 题目 给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。 示例 1： 输入：root = [4,2,7,1,3,6,9] 输出：[4,7,2,9,6,3,1] 示例 2： 输入：root = [2,1,3] 输出：[2,3,1] 示例 3： 输入：root = [] 输出：[] 提示： 树中节点数目范围在 [0, 100] 内 -100 \u003c= Node.val \u003c= 100 解法 方法一：深度优先遍历 思路与算法 这是一道很经典的二叉树问题。显然，我们从根节点开始，递归地对树进行遍历，并从叶子节点先开始翻转。如果当前遍历到的节点 root 的左右两棵子树都已经翻转，那么我们只需要交换两棵子树的位置，即可完成以 root 为根节点的整棵子树的翻转。 代码 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode() {} * TreeNode(int val) { this.val = val; } * TreeNode(int val, TreeNode left, TreeNode right) { * this.val = val; * this.left = left; * this.right = right; * } * } */ class Solution { public TreeNode invertTree(TreeNode root) { if(root==null) return null; // 先交换一下左右子树 TreeNode tmp = root.right; root.right = root.left; root.left = tmp; // 此时已经交换过子树了，所以分别遍历左右子树 root.left = invertTree(root.left); root.right = invertTree(root.right); return root; } } 复杂度分析 时间复杂度：O(N)，其中 N 为二叉树节点的数目。我们会遍历二叉树中的每一个节点，对每个节点而言，我们在常数时间内交换其两棵子树。 空间复杂度：O(N)。使用的空间由递归栈的深度决定，它等于当前节点在二叉树中的高度。在平均情况下，二叉树的高度与节点个数为对数关系，即 O*(logN)。而在最坏情况下，树形成链状，空间复杂度为 O(N)。 方法二：广度优先遍历 public TreeNode invertTree(TreeNode root) { if (root == null) return root; Queue\u003cTreeNode\u003e queue = new LinkedList\u003c\u003e(); queue.add(root);//相当于把数据加入到队列尾部 while (!queue.isEmpty()) { //poll方法相当于移除队列头部的元素 TreeNode node = queue.poll(); //先交换子节点 TreeNode left = node.left; node.left = node.right; node.right = left; if (node.left != null) queue.add(node.left); if (node.right != null) queue.add(node.right); } return root; } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:31:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day32 236. 二叉树的最近公共祖先 题目 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 示例 1： 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出：3 解释：节点 5 和节点 1 的最近公共祖先是节点 3 。 示例 2： 输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出：5 解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。 示例 3： 输入：root = [1,2], p = 1, q = 2 输出：1 提示： 树中节点数目在范围 [2, 105] 内。 -109 \u003c= Node.val \u003c= 109 所有 Node.val 互不相同 。 p != q p 和 q 均存在于给定的二叉树中。 解法 方法零：两层递归 class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if (root==null) return null; //左子树是否含有这两个节点，如果有，就继续递归，直到左子树不再同时含有两个节点 if (doSome(root.left,p)\u0026\u0026doSome(root.left,q)) { return lowestCommonAncestor(root.left,p,q); } if (doSome(root.right,p)\u0026\u0026doSome(root.right,q)){ return lowestCommonAncestor(root.right,p,q); } return root; } // 检查 node子树里是否含有n节点 public boolean doSome(TreeNode node,TreeNode n){ if (node==null)return false; if (node.val==n.val){ return true; } boolean l = doSome(node.left,n); boolean r = doSome(node.right,n); return l||r; } } 方法一：递归 思路和算法 我们递归遍历整棵二叉树，定义 f~x~ 表示 x 节点的子树中是否包含 p 节点或 q 节点，如果包含为 true，否则为 false。那么符合条件的最近公共祖先 x 一定满足如下条件：(f^lson^ \u0026\u0026 f^rson^) ∣∣ ((x = p ∣∣ x = q) \u0026\u0026 (f^lson^ ∣∣ f^rson^)) 其中 lson 和 rson 分别代表 x 节点的左孩子和右孩子。初看可能会感觉条件判断有点复杂，我们来一条条看，f^lson^ \u0026\u0026 f^rson^` 说明左子树和右子树均包含 p 节点或 q 节点，如果左子树包含的是 p 节点，那么右子树只能包含 q 节点，反之亦然，因为 p 节点和 q 节点都是不同且唯一的节点，因此如果满足这个判断条件即可说明 x 就是我们要找的最近公共祖先。再来看第二条判断条件，这个判断条件即是考虑了 x 恰好是 p 节点或 q 节点且它的左子树或右子树有一个包含了另一个节点的情况，因此如果满足这个判断条件亦可说明 x 就是我们要找的最近公共祖先。 你可能会疑惑这样找出来的公共祖先深度是否是最大的。其实是最大的，因为我们是自底向上从叶子节点开始更新的，所以在所有满足条件的公共祖先中一定是深度最大的祖先先被访问到，且由于 f~x~ 本身的定义很巧妙，在找到最近公共祖先 x 以后，f~x~ 按定义被设置为 true ，即假定了这个子树中只有一个 p 节点或 q 节点，因此其他公共祖先不会再被判断为符合条件。 class Solution { private TreeNode ans; public Solution() { this.ans = null; } private boolean dfs(TreeNode root, TreeNode p, TreeNode q) { if (root == null) return false; boolean lson = dfs(root.left, p, q); boolean rson = dfs(root.right, p, q); if ((lson \u0026\u0026","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:32:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day33 257. 二叉树的所有路径 题目 给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。 叶子节点 是指没有子节点的节点。 示例 1： 输入：root = [1,2,3,null,5] 输出：[\"1-\u003e2-\u003e5\",\"1-\u003e3\"] 示例 2： 输入：root = [1] 输出：[\"1\"] 提示： 树中节点的数目在范围 [1, 100] 内 -100 \u003c= Node.val \u003c= 100 解法 方法一：深度优先搜索 思路与算法 最直观的方法是使用深度优先搜索。在深度优先搜索遍历二叉树时，我们需要考虑当前的节点以及它的孩子节点。 如果当前节点不是叶子节点，则在当前的路径末尾添加该节点，并继续递归遍历该节点的每一个孩子节点。 如果当前节点是叶子节点，则在当前路径末尾添加该节点后我们就得到了一条从根节点到叶子节点的路径，将该路径加入到答案即可。 如此，当遍历完整棵二叉树以后我们就得到了所有从根节点到叶子节点的路径。当然，深度优先搜索也可以使用非递归的方式实现，这里不再赘述。 代码 class Solution { public List\u003cString\u003e binaryTreePaths(TreeNode root) { List\u003cString\u003e paths = new ArrayList\u003cString\u003e(); constructPaths(root, \"\", paths); return paths; } public void constructPaths(TreeNode root, String path, List\u003cString\u003e paths) { if (root != null) { StringBuffer pathSB = new StringBuffer(path); pathSB.append(Integer.toString(root.val)); if (root.left == null \u0026\u0026 root.right == null) { // 当前节点是叶子节点 paths.add(pathSB.toString()); // 把路径加入到答案中 } else { pathSB.append(\"-\u003e\"); // 当前节点不是叶子节点，继续递归遍历 constructPaths(root.left, pathSB.toString(), paths); constructPaths(root.right, pathSB.toString(), paths); } } } } 复杂度分析 时间复杂度：O(N^2^)，其中 N 表示节点数目。在深度优先搜索中每个节点会被访问一次且只会被访问一次，每一次会对 path 变量进行拷贝构造，时间代价为 O(N) ，故时间复杂度为 O(N^2^)。 空间复杂度：O(N^2^)，其中 N 表示节点数目。除答案数组外我们需要考虑递归调用的栈空间。在最坏情况下，当二叉树中每个节点只有一个孩子节点时，即整棵二叉树呈一个链状，此时递归的层数为 N，此时每一层的 path 变量的空间代价的总和为 $$ O(\\sum_{i = 1}^{N} i) = O(N^2) $$ 空间复杂度为 O(N^2^)。最好情况下，当二叉树为平衡二叉树时，它的高度为 log N ，此时空间复杂度为 $$ O((\\log {N})^2) $$ 。 方法二：广度优先搜索 思路与算法 我们也可以用广度优先搜索来实现。我们维护一个队列，存储节点以及根到该节点的路径。一开始这个队列里只有根节点。在每一步迭代中，我们取出队列中的首节点，如果它是叶子节点，则将它对应的路径加入到答案中。如果它不是叶子节点，则将它的所有孩子节点加入到队列的末尾。当队列为空时广度优先搜索结束，我们即能得到答案。 代码 class Solution { public List\u003cString\u003e binaryTreePaths(TreeNode root) { List\u003cString\u003e paths = new ArrayList\u003cString\u003e(); if (root == null) { return paths; } Queue\u003cTreeNode\u003e nodeQueue = new LinkedList\u003cTreeNode\u003e(); Queue\u003cString\u003e pathQueue = new LinkedList\u003cString\u003e(); nodeQueue.offer(root); pathQueue.offer(Integer.toString(root.val)); while (!nodeQueue.isEmpty()) { TreeNode node = nodeQueue.poll(); String ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:33:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day34 404. 左叶子之和 题目 给定二叉树的根节点 root ，返回所有左叶子之和。 示例 1： 输入: root = [3,9,20,null,null,15,7] 输出: 24 解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24 示例 2: 输入: root = [1] 输出: 0 提示: 节点数在 [1, 1000] 范围内 -1000 \u003c= Node.val \u003c= 1000 解法 一个节点为「左叶子」节点，当且仅当它是某个节点的左子节点，并且它是一个叶子结点。因此我们可以考虑对整棵树进行遍历，当我们遍历到节点 node 时，如果它的左子节点是一个叶子结点，那么就将它的左子节点的值累加计入答案。 遍历整棵树的方法有深度优先搜索和广度优先搜索，下面分别给出了实现代码。 方法一：深度优先搜索 class Solution { public int sumOfLeftLeaves(TreeNode root) { return root != null ? dfs(root) : 0; } public int dfs(TreeNode node) { int ans = 0; if (node.left != null) { ans += isLeafNode(node.left) ? node.left.val : dfs(node.left); } if (node.right != null \u0026\u0026 !isLeafNode(node.right)) { ans += dfs(node.right); } return ans; } public boolean isLeafNode(TreeNode node) { return node.left == null \u0026\u0026 node.right == null; } } 复杂度分析 时间复杂度：O(n)，其中 n 是树中的节点个数。 空间复杂度：O(n)。空间复杂度与深度优先搜索使用的栈的最大深度相关。在最坏的情况下，树呈现链式结构，深度为 O(n)，对应的空间复杂度也为 O(n)。 方法二：广度优先搜索 class Solution { public int sumOfLeftLeaves(TreeNode root) { if (root == null) { return 0; } Queue\u003cTreeNode\u003e queue = new LinkedList\u003cTreeNode\u003e(); queue.offer(root); int ans = 0; while (!queue.isEmpty()) { TreeNode node = queue.poll(); if (node.left != null) { if (isLeafNode(node.left)) { ans += node.left.val; } else { queue.offer(node.left); } } if (node.right != null) { if (!isLeafNode(node.right)) { queue.offer(node.right); } } } return ans; } public boolean isLeafNode(TreeNode node) { return node.left == null \u0026\u0026 node.right == null; } } 复杂度分析 时间复杂度：O(n) ，其中 n 是树中的节点个数。 空间复杂度：O(n) 。空间复杂度与广度优先搜索使用的队列需要的容量相关，为 O(n)。 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:34:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day35 513. 找树左下角的值 题目 给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。 假设二叉树中至少有一个节点。 示例 1: 输入: root = [2,1,3] 输出: 1 示例 2: 输入: [1,2,3,4,null,5,6,null,null,7] 输出: 7 提示: 二叉树的节点个数的范围是 [1,104] -231 \u003c= Node.val \u003c= 231 - 1 解法 方法一：深度优先搜索 使用 height 记录遍历到的节点的高度，curVal 记录高度在 curHeight 的最左节点的值。在深度优先搜索时，我们先搜索当前节点的左子节点，再搜索当前节点的右子节点，然后判断当前节点的高度 height 是否大于 curHeight，如果是，那么将 curVal 设置为当前结点的值,curHeight 设置为 height。 因为我们先遍历左子树，然后再遍历右子树，所以对同一高度的所有节点，最左节点肯定是最先被遍历到的。 class Solution { int curVal = 0; int curHeight = 0; public int findBottomLeftValue(TreeNode root) { int curHeight = 0; dfs(root, 0); return curVal; } public void dfs(TreeNode root, int height) { if (root == null) { return; } height++; dfs(root.left, height); dfs(root.right, height); // 相当于后续遍历麻，最先遍历的一定是左子节点，然后是右、根子节点 if (height \u003e curHeight) { curHeight = height; curVal = root.val; } } } 复杂度分析 时间复杂度：O(n)，其中 n 是二叉树的节点数目。需要遍历 n 个节点。 空间复杂度：O(n)。递归栈需要占用 O(n) 的空间。 方法二：广度优先搜索 使用广度优先搜索遍历每一层的节点。在遍历一个节点时，需要先把它的非空右子节点放入队列，然后再把它的非空左子节点放入队列，这样才能保证从右到左遍历每一层的节点。广度优先搜索所遍历的最后一个节点的值就是最底层最左边节点的值。 class Solution { public int findBottomLeftValue(TreeNode root) { int ret = 0; Queue\u003cTreeNode\u003e queue = new ArrayDeque\u003cTreeNode\u003e(); queue.offer(root); while (!queue.isEmpty()) { TreeNode p = queue.poll(); if (p.right != null) { queue.offer(p.right); } if (p.left != null) { queue.offer(p.left); } ret = p.val; } return ret; } } 复杂度分析 时间复杂度：O(n)，其中 n 是二叉树的节点数目。 空间复杂度：O(n)。如果二叉树是满完全二叉树，那么队列 q 最多保存 2/n 个节点。 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:35:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day36 559. N 叉树的最大深度 题目 给定一个 N 叉树，找到其最大深度。 最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。 N 叉树输入按层序遍历序列化表示，每组子节点由空值分隔（请参见示例）。 示例 1： 输入：root = [1,null,3,2,4,null,5,6] 输出：3 示例 2： 输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] 输出：5 提示： 树的深度不会超过 1000 。 树的节点数目位于 [0, 104] 之间。 解法 方法一：深度优先搜索 如果根节点有 N 个子节点，则这 N 个子节点对应 N 个子树。记 N 个子树的最大深度中的最大值为 maxChildDepth，则该 N 叉树的最大深度为 maxChildDepth+1。 每个子树的最大深度又可以以同样的方式进行计算。因此我们可以用「深度优先搜索」的方法计算 N 叉树的最大深度。具体而言，在计算当前 N 叉树的最大深度时，可以先递归计算出其每个子树的最大深度，然后在 O(1) 的时间内计算出当前 N 叉树的最大深度。递归在访问到空节点时退出。 class Solution { public int maxDepth(Node root) { if (root == null) { return 0; } int maxChildDepth = 0; List\u003cNode\u003e children = root.children; for (Node child : children) { int childDepth = maxDepth(child); maxChildDepth = Math.max(maxChildDepth, childDepth); } return maxChildDepth + 1; } } 复杂度分析 时间复杂度：O(n)，其中 n 为 N 叉树节点的个数。每个节点在递归中只被遍历一次。 空间复杂度：O(height)，其中 height 表示 N 叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于 N 叉树的高度。 方法二：广度优先搜索 我们也可以用「广度优先搜索」的方法来解决这道题目，但我们需要对其进行一些修改，此时我们广度优先搜索的队列里存放的是「当前层的所有节点」。每次拓展下一层的时候，不同于广度优先搜索的每次只从队列里拿出一个节点，我们需要将队列里的所有节点都拿出来进行拓展，这样能保证每次拓展完的时候队列里存放的是当前层的所有节点，即我们是一层一层地进行拓展。最后我们用一个变量 ans 来维护拓展的次数，该 N 叉树的最大深度即为 ans。 class Solution { public int maxDepth(Node root) { if (root == null) { return 0; } Queue\u003cNode\u003e queue = new LinkedList\u003cNode\u003e(); queue.offer(root); int ans = 0; while (!queue.isEmpty()) { int size = queue.size(); while (size \u003e 0) { Node node = queue.poll(); List\u003cNode\u003e children = node.children; for (Node child : children) { queue.offer(child); } size--; } ans++; } return ans; } } 复杂度分析 时间复杂度：O(n)，其中 n 为 N 叉树的节点个数。与方法一同样的分析，每个节点只会被访问一次。 空间复杂度：此方法空间的消耗取决于队列存储的元素数量，其在最坏情况下会达到 O(n)。 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:36:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day37 617. 合并二叉树 题目 给你两棵二叉树： root1 和 root2 。 想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。 返回合并后的二叉树。 注意: 合并过程必须从两个树的根节点开始。 示例 1： 输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7] 输出：[3,4,5,5,4,null,7] 示例 2： 输入：root1 = [1], root2 = [1,2] 输出：[2,2] 提示： 两棵树中的节点数目在范围 [0, 2000] 内 -104 \u003c= Node.val \u003c= 104 解法 方法一：深度优先搜索 可以使用深度优先搜索合并两个二叉树。从根节点开始同时遍历两个二叉树，并将对应的节点进行合并。 两个二叉树的对应节点可能存在以下三种情况，对于每种情况使用不同的合并方式。 如果两个二叉树的对应节点都为空，则合并后的二叉树的对应节点也为空； 如果两个二叉树的对应节点只有一个为空，则合并后的二叉树的对应节点为其中的非空节点； 如果两个二叉树的对应节点都不为空，则合并后的二叉树的对应节点的值为两个二叉树的对应节点的值之和，此时需要显性合并两个节点。 对一个节点进行合并之后，还要对该节点的左右子树分别进行合并。这是一个递归的过程。 class Solution { public TreeNode mergeTrees(TreeNode root1, TreeNode root2) { TreeNode node; // 定义一个局部变量用于递归时，本层节点记录 if(root1==null\u0026\u0026root2==null){// 当两个根节点都是null，直接返回null return null; }else if(root1==null){// 当两个根节点有一个为空时，也直接返回非空节点，没必要加 return root2; }else if(root2==null){// 当两个根节点有一个为空时，也直接返回非空节点，没必要加 return root1; }else{// 当两个根节点都不为空的时候，先记录合并后的根节点 node = new TreeNode(root1.val+root2.val); } // 然后再递归的遍历左右子树 TreeNode left = mergeTrees(root1.left,root2.left); TreeNode right = mergeTrees(root1.right,root2.right); // 将左右子树的结果挂在新的根节点上 node.left = left; node.right = right; return node; } } 复杂度分析 时间复杂度：O(min(m,n))，其中 m 和 n 分别是两个二叉树的节点个数。对两个二叉树同时进行深度优先搜索，只有当两个二叉树中的对应节点都不为空时才会对该节点进行显性合并操作，因此被访问到的节点数不会超过较小的二叉树的节点数。 空间复杂度：O(min(m,n))，其中 m 和 n 分别是两个二叉树的节点个数。空间复杂度取决于递归调用的层数，递归调用的层数不会超过较小的二叉树的最大高度，最坏情况下，二叉树的高度等于节点数。 方法二：广度优先搜索 也可以使用广度优先搜索合并两个二叉树。首先判断两个二叉树是否为空，如果两个二叉树都为空，则合并后的二叉树也为空，如果只有一个二叉树为空，则合并后的二叉树为另一个非空的二叉树。 如果两个二叉树都不为空，则首先计算合并后的根节点的值，然后从合并后的二叉树与两个原始二叉树的根节点开始广度优先搜索，从根节点开始同时遍历每个二叉树，并将对应的节点进行合并。 使用三个队列分别存储合并后的二叉树的节点以及两个原始二叉树的节点。初始时将每个二叉树的根节点分别加入相应的队列。每次从每个队列中取出一个节点，判断两个原始二叉树的节点的左右子节点是否为空。如果两个原始二叉树的当前节点中至少有一个节点的左子节点不为空，则合并后的二叉树的对应节点的左子节点也不为空。对于右子节点同理。 如果合并后的二叉树的左子节点不为空，则需要根据两个原始二叉树的左子节点计算合并后的二叉树的左子节点以及整个左子树。考虑以下两种情况： 如果两个原始二叉树的左子节点都不为空，则合并后的二叉树的左子节点的值为两个原始二叉树的左子节点的值之和，在创建合并后的二叉树的左子节点之后，将每个二叉树中的左子节点都加入相应的队列； 如果两个原始二叉树的左子节点有一个为空","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:37:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day38 654. 最大二叉树 题目 给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建: 创建一个根节点，其值为 nums 中的最大值。 递归地在最大值 左边 的 子数组前缀上 构建左子树。 递归地在最大值 右边 的 子数组后缀上 构建右子树。 返回 nums 构建的 *最大二叉树* 。 示例 1： 输入：nums = [3,2,1,6,0,5] 输出：[6,3,5,null,2,0,null,null,1] 解释：递归调用如下所示： - [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。 - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。 - 空数组，无子节点。 - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。 - 空数组，无子节点。 - 只有一个元素，所以子节点是一个值为 1 的节点。 - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。 - 只有一个元素，所以子节点是一个值为 0 的节点。 - 空数组，无子节点。 示例 2： 输入：nums = [3,2,1] 输出：[3,null,2,null,1] 提示： 1 \u003c= nums.length \u003c= 1000 0 \u003c= nums[i] \u003c= 1000 nums 中的所有整数 互不相同 解法 方法一：递归 思路与算法 最简单的方法是直接按照题目描述进行模拟。 我们用递归函数 construct(nums,left,right) 表示对数组 nums 中从 nums 到 的元素构建一棵树。我们首先找到这一区间中的最大值，记为 nums 中从 nums[best]，这样就确定了根节点的值。随后我们就可以进行递归： 左子树为 construct(nums, left, best-1)； 右子树为 construct(nums,best+1,right)。 当递归到一个无效的区间（即 left*\u003e*right）时，便可以返回一棵空的树。 代码 class Solution { public TreeNode constructMaximumBinaryTree(int[] nums) { return construct(nums, 0, nums.length - 1); } public TreeNode construct(int[] nums, int left, int right) { if (left \u003e right) { return null; } int best = left; for (int i = left + 1; i \u003c= right; ++i) { if (nums[i] \u003e nums[best]) { best = i; } } TreeNode node = new TreeNode(nums[best]); node.left = construct(nums, left, best - 1); node.right = construct(nums, best + 1, right); return node; } } 复杂度分析 时间复杂度：O(n^2^)，其中 n 是数组 nums 的长度。在最坏的情况下，数组严格递增或递减，需要递归 n 层，第 i (0≤i\u003cn) 层需要遍历 n-i 个元素以找出最大值，总时间复杂度为 O(n^2^)。 空间复杂度：O(n)，即为最坏情况下需要使用的栈空间。 方法二：单调栈 思路与算法 我们可以将题目中构造树的过程等价转换为下面的构造过程： 初始时，我们只有一个根节点，其中存储了整个数组； 在每一步操作中，我们可以「任选」一个存储了超过一个数的节点，找出其中的最大值并存储在该节点。最大值左侧的数组部分下放到该节点的左子节点，右侧的数组部分下放到该节点的右子节点； 如果所有的节点都恰好存储了一个数，那么构造结束。 由于最终构造出的是一棵树，因此无需按照题目的要求「递归」地进行构造，而是每次可以「任选」一个节点进行构造。这里可以类比一棵树的「深度优先搜索」和「广度优先搜索」，二者都可以起到遍历整棵树的效果。 既然可以任意进行选择，那么我们不妨每次选择数组中最大值最大的那个节点进行构造。这样一来，我们就可以保证按照数组中元素降序排序的顺序依次构造每个节点。因此： 当我们选择的节点中数组的最大值为 nums[i] 时，所有大于 nums[i] 的元素已经被构造过（即被单独放入某一个节点中），所有小于 nums[i] 的元素还没有被构造过。 这就说明： 在最终构造出的树上，以 nums[i] 为根节点的子树，在原数组中对应","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:38:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day39 144. 二叉树的前序遍历 题目 给你二叉树的根节点 root ，返回它节点值的 前序 遍历。 示例 1： 输入：root = [1,null,2,3] 输出：[1,2,3] 示例 2： 输入：root = [] 输出：[] 示例 3： 输入：root = [1] 输出：[1] 示例 4： 输入：root = [1,2] 输出：[1,2] 示例 5： 输入：root = [1,null,2] 输出：[1,2] 提示： 树中节点数目在范围 [0, 100] 内 -100 \u003c= Node.val \u003c= 100 **进阶：**递归算法很简单，你可以通过迭代算法完成吗？ 解法 方法一：递归 思路与算法 首先我们需要了解什么是二叉树的前序遍历：按照访问根节点——左子树——右子树的方式遍历这棵树，而在访问左子树或者右子树的时候，我们按照同样的方式遍历，直到遍历完整棵树。因此整个遍历过程天然具有递归的性质，我们可以直接用递归函数来模拟这一过程。 定义 preorder(root) 表示当前遍历到 root 节点的答案。按照定义，我们只要首先将 root 节点的值加入答案，然后递归调用 preorder(root.left) 来遍历 root 节点的左子树，最后递归调用 preorder(root.right) 来遍历 root 节点的右子树即可，递归终止的条件为碰到空节点。 代码 class Solution { public List\u003cInteger\u003e preorderTraversal(TreeNode root) { List\u003cInteger\u003e res = new ArrayList\u003cInteger\u003e(); preorder(root, res); return res; } public void preorder(TreeNode root, List\u003cInteger\u003e res) { if (root == null) { return; } res.add(root.val); preorder(root.left, res); preorder(root.right, res); } } 复杂度分析 时间复杂度：O(n)，其中 n 是二叉树的节点数。每一个节点恰好被遍历一次。 空间复杂度：O(n)，为递归过程中栈的开销，平均情况下为 O(log n)，最坏情况下树呈现链状，为 O(n)。 方法二：迭代 思路与算法 我们也可以用迭代的方式实现方法一的递归函数，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其余的实现与细节都相同，具体可以参考下面的代码。 初始化维护一个栈，将根节点入栈。 当栈不为空时 弹出栈顶元素 node，将节点值加入结果数组中。 若 node 的右子树不为空，右子树入栈。 若 node 的左子树不为空，左子树入栈。 代码 class Solution { public List\u003cInteger\u003e preorderTraversal(TreeNode root) { List\u003cInteger\u003e res = new ArrayList\u003cInteger\u003e(); if (root == null) { return res; } Deque\u003cTreeNode\u003e stack = new LinkedList\u003cTreeNode\u003e(); TreeNode node = root; while (!stack.isEmpty() || node != null) { while (node != null) { res.add(node.val); stack.push(node); node = node.left; } node = stack.pop(); node = node.right; } return res; } } 复杂度分析 时间复杂度：O(n)，其中 n 是二叉树的节点数。每一个节点恰好被遍历一次。 空间复杂度：O(n)，为迭代过程中显式栈的开销，平均情况下为 O(log n)，最坏情况下树呈现链状，为 O(n)。 方法三：Morris 遍历 思路与算法 有一种巧妙的方法可以在线性时间内，只占用常数空间来实现前序遍历。这种方法由 J. H. Morris 在 1979 年的论文「Traversing Binary Trees Simply and Cheaply」中首次提出，因此被称为 Morris 遍历。 Morris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其前序遍历规则总结如下： 新建临时节点，令该节点为 root； 如果当前节点的左子节点为空，将当前节点加入答案，并遍历当前节点的右子节点； 如果当前节点的","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:39:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day40 94. 二叉树的中序遍历 题目 给定一个二叉树的根节点 root ，返回 它的 中序 遍历 。 示例 1： 输入：root = [1,null,2,3] 输出：[1,3,2] 示例 2： 输入：root = [] 输出：[] 示例 3： 输入：root = [1] 输出：[1] 提示： 树中节点数目在范围 [0, 100] 内 -100 \u003c= Node.val \u003c= 100 进阶: 递归算法很简单，你可以通过迭代算法完成吗？ 解法 方法一：递归 思路与算法 首先我们需要了解什么是二叉树的中序遍历：按照访问左子树——根节点——右子树的方式遍历这棵树，而在访问左子树或者右子树的时候我们按照同样的方式遍历，直到遍历完整棵树。因此整个遍历过程天然具有递归的性质，我们可以直接用递归函数来模拟这一过程。 定义 inorder(root) 表示当前遍历到 root 节点的答案，那么按照定义，我们只要递归调用 inorder(root.left) 来遍历 root 节点的左子树，然后将 root 节点的值加入答案，再递归调用inorder(root.right) 来遍历 root 节点的右子树即可，递归终止的条件为碰到空节点。 代码 class Solution { public List\u003cInteger\u003e inorderTraversal(TreeNode root) { List\u003cInteger\u003e res = new ArrayList\u003cInteger\u003e(); inorder(root, res); return res; } public void inorder(TreeNode root, List\u003cInteger\u003e res) { if (root == null) { return; } inorder(root.left, res); res.add(root.val); inorder(root.right, res); } } 复杂度分析 时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。 空间复杂度：O(n)。空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。 方法二：迭代 思路与算法 方法一的递归函数我们也可以用迭代的方式实现，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其他都相同，具体实现可以看下面的代码。 初始化一个空栈。 当【根节点不为空】或者【栈不为空】时，从根节点开始 若当前节点有左子树，一直遍历左子树，每次将当前节点压入栈中。 若当前节点无左子树，从栈中弹出该节点，尝试访问该节点的右子树。 代码 class Solution { public List\u003cInteger\u003e inorderTraversal(TreeNode root) { List\u003cInteger\u003e res = new ArrayList\u003cInteger\u003e(); Deque\u003cTreeNode\u003e stk = new LinkedList\u003cTreeNode\u003e(); while (root != null || !stk.isEmpty()) { while (root != null) { stk.push(root); root = root.left; } root = stk.pop(); res.add(root.val); root = root.right; } return res; } } 复杂度分析 时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。 空间复杂度：O(n)。空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。 方法三：Morris 中序遍历 思路与算法 Morris 遍历算法是另一种遍历二叉树的方法，它能将非递归的中序遍历空间复杂度降为 O(1)。 Morris 遍历算法整体步骤如下（假设当前遍历到的节点为 x）： 如果 x 无左孩子，先将 x 的值加入答案数组，再访问 x 的右孩子，即x*=*x.right。 如果 x 有左孩子，则找到 x 左子树上最右的节点（即左子树中序遍历的最后一个节点，x 在中序遍历中的前驱节点），我们记为predecessor. 根据predecessor的右孩子是否为空，进行如下操作。 如果 predecessor 的右孩子为空，则将其右孩子指向 x，然后访问 x 的左孩子，即 x = x.left。 如果 predecessor 的右孩子不为空，则此时其右孩子指向 x，说明我们已经遍历完 x 的左子树，我们将 predecessor 的右孩子","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:40:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day41 105. 从前序与中序遍历序列构造二叉树 题目 给定两个整数数组 preorder 和 inorder ，其中 preorder 是二叉树的先序遍历， inorder 是同一棵树的中序遍历，请构造二叉树并返回其根节点。 示例 1: 输入: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] 输出: [3,9,20,null,null,15,7] 示例 2: 输入: preorder = [-1], inorder = [-1] 输出: [-1] 提示: 1 \u003c= preorder.length \u003c= 3000 inorder.length == preorder.length -3000 \u003c= preorder[i], inorder[i] \u003c= 3000 preorder 和 inorder 均 无重复 元素 inorder 均出现在 preorder preorder 保证 为二叉树的前序遍历序列 inorder 保证 为二叉树的中序遍历序列 解法 二叉树前序遍历的顺序为： 先遍历根节点； 随后递归地遍历左子树； 最后递归地遍历右子树。 二叉树中序遍历的顺序为： 先递归地遍历左子树； 随后遍历根节点； 最后递归地遍历右子树。 在「递归」地遍历某个子树的过程中，我们也是将这颗子树看成一颗全新的树，按照上述的顺序进行遍历。挖掘「前序遍历」和「中序遍历」的性质，我们就可以得出本题的做法。 方法一：递归 思路 对于任意一颗树而言，前序遍历的形式总是 [ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ] 即根节点总是前序遍历中的第一个节点。而中序遍历的形式总是 [ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ] 只要我们在中序遍历中定位到根节点，那么我们就可以分别知道左子树和右子树中的节点数目。由于同一颗子树的前序遍历和中序遍历的长度显然是相同的，因此我们就可以对应到前序遍历的结果中，对上述形式中的所有左右括号进行定位。 这样以来，我们就知道了左子树的前序遍历和中序遍历结果，以及右子树的前序遍历和中序遍历结果，我们就可以递归地对构造出左子树和右子树，再将这两颗子树接到根节点的左右位置。 细节 在中序遍历中对根节点进行定位时，一种简单的方法是直接扫描整个中序遍历的结果并找出根节点，但这样做的时间复杂度较高。我们可以考虑使用哈希表来帮助我们快速地定位根节点。对于哈希映射中的每个键值对，键表示一个元素（节点的值），值表示其在中序遍历中的出现位置。在构造二叉树的过程之前，我们可以对中序遍历的列表进行一遍扫描，就可以构造出这个哈希映射。在此后构造二叉树的过程中，我们就只需要 O(1) 的时间对根节点进行定位了。 下面的代码给出了详细的注释。 class Solution { private Map\u003cInteger, Integer\u003e indexMap; public TreeNode myBuildTree(int[] preorder, int[] inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) { if (preorder_left \u003e preorder_right) { return null; } // 前序遍历中的第一个节点就是根节点 int preorder_root = preorder_left; // 在中序遍历中定位根节点 int inorder_root = indexMap.get(preorder[preorder_root]); // 先把根节点建立出来 TreeNode root = new TreeNode(preorder[preorder_root]); // 得到左子树中的节点数目 int size_left_subtree = inorder_root - inorder_left; // 递归地构造左子树，并连接到根节点 // 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素 root.left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1); // 递归地构造右子树，并连接到根节点 // 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:41:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day42 106. 从中序与后序遍历序列构造二叉树 题目 给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。 示例 1: 输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3] 输出：[3,9,20,null,null,15,7] 示例 2: 输入：inorder = [-1], postorder = [-1] 输出：[-1] 提示: 1 \u003c= inorder.length \u003c= 3000 postorder.length == inorder.length -3000 \u003c= inorder[i], postorder[i] \u003c= 3000 inorder 和 postorder 都由 不同 的值组成 postorder 中每一个值都在 inorder 中 inorder 保证是树的中序遍历 postorder 保证是树的后序遍历 解法 方法一：递归 我们可以发现后序遍历的数组最后一个元素代表的即为根节点。知道这个性质后，我们可以利用已知的根节点信息在中序遍历的数组中找到根节点所在的下标，然后根据其将中序遍历的数组分成左右两部分，左边部分即左子树，右边部分为右子树，针对每个部分可以用同样的方法继续递归下去构造。 算法 为了高效查找根节点元素在中序遍历数组中的下标，我们选择创建哈希表来存储中序序列，即建立一个（元素，下标）键值对的哈希表。 定义递归函数 helper(in_left, in_right) 表示当前递归到中序序列中当前子树的左右边界，递归入口为helper(0, n - 1) ： 如果 in_left \u003e in_right，说明子树为空，返回空节点。 选择后序遍历的最后一个节点作为根节点。 利用哈希表 O(1) 查询当根节点在中序遍历中下标为 index。从 in_left 到 index - 1 属于左子树，从 index + 1 到 in_right 属于右子树。 根据后序遍历逻辑，递归创建右子树 helper(index + 1, in_right) 和左子树 helper(in_left, index - 1)。注意这里有需要先创建右子树，再创建左子树的依赖关系。可以理解为在后序遍历的数组中整个数组是先存储左子树的节点，再存储右子树的节点，最后存储根节点，如果按每次选择「后序遍历的最后一个节点」为根节点，则先被构造出来的应该为右子树。 返回根节点 root 代码 class Solution { int post_idx; int[] postorder; int[] inorder; Map\u003cInteger, Integer\u003e idx_map = new HashMap\u003cInteger, Integer\u003e(); public TreeNode helper(int in_left, int in_right) { // 如果这里没有节点构造二叉树了，就结束 if (in_left \u003e in_right) { return null; } // 选择 post_idx 位置的元素作为当前子树根节点 int root_val = postorder[post_idx]; TreeNode root = new TreeNode(root_val); // 根据 root 所在位置分成左右两棵子树 int index = idx_map.get(root_val); // 下标减一 post_idx--; // 构造右子树 root.right = helper(index + 1, in_right); // 构造左子树 root.left = helper(in_left, index - 1); return root; } public TreeNode buildTree(int[] inorder, int[] postorder) { this.postorder = postorder; this.inorder = inorder; // 从后序遍历的最后一个元素开始 post_idx = postorder.length - 1; // 建立（元素，下标）键值对的哈希表 int idx = 0; for (Integer val : inorder) { idx_map.put(val, idx++); } return helper(0, inorder.length - 1); } } // 或者 复杂度分析 时间复杂度：O(n)，其中 n 是树中的节点个数。 空间复杂度：O(n)。我们需要使用 O(n) 的","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:42:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day43 145. 二叉树的后序遍历 题目 给你一棵二叉树的根节点 root ，返回其节点值的 后序遍历 。 示例 1： 输入：root = [1,null,2,3] 输出：[3,2,1] 示例 2： 输入：root = [] 输出：[] 示例 3： 输入：root = [1] 输出：[1] 提示： 树中节点的数目在范围 [0, 100] 内 -100 \u003c= Node.val \u003c= 100 **进阶：**递归算法很简单，你可以通过迭代算法完成吗？ 解法 方法一：递归 思路与算法 首先我们需要了解什么是二叉树的后序遍历：按照访问左子树——右子树——根节点的方式遍历这棵树，而在访问左子树或者右子树的时候，我们按照同样的方式遍历，直到遍历完整棵树。因此整个遍历过程天然具有递归的性质，我们可以直接用递归函数来模拟这一过程。 定义 postorder(root) 表示当前遍历到 root 节点的答案。按照定义，我们只要递归调用 postorder(root-\u003eleft) 来遍历 root 节点的左子树，然后递归调用 postorder(root-\u003eright) 来遍历 root 节点的右子树，最后将 root 节点的值加入答案即可，递归终止的条件为碰到空节点。 代码 class Solution { public List\u003cInteger\u003e postorderTraversal(TreeNode root) { List\u003cInteger\u003e res = new ArrayList\u003cInteger\u003e(); postorder(root, res); return res; } public void postorder(TreeNode root, List\u003cInteger\u003e res) { if (root == null) { return; } postorder(root.left, res); postorder(root.right, res); res.add(root.val); } } 复杂度分析 时间复杂度：O(n)，其中 n 是二叉搜索树的节点数。每一个节点恰好被遍历一次。 空间复杂度：O(n)，为递归过程中栈的开销，平均情况下为 O(log n)，最坏情况下树呈现链状，为 O(n)。 方法二：迭代 思路与算法 我们也可以用迭代的方式实现方法一的递归函数，两种方式是等价的，区别在于递归的时候隐式地维护了一个栈，而我们在迭代的时候需要显式地将这个栈模拟出来，其余的实现与细节都相同，具体可以参考下面的代码。 代码 class Solution { public List\u003cInteger\u003e postorderTraversal(TreeNode root) { List\u003cInteger\u003e res = new ArrayList\u003cInteger\u003e(); if (root == null) { return res; } Deque\u003cTreeNode\u003e stack = new LinkedList\u003cTreeNode\u003e(); TreeNode prev = null; while (root != null || !stack.isEmpty()) { while (root != null) { stack.push(root); root = root.left; } root = stack.pop(); if (root.right == null || root.right == prev) { res.add(root.val); prev = root; root = null; } else { stack.push(root); root = root.right; } } return res; } } 复杂度分析 时间复杂度：O(n)，其中 n 是二叉搜索树的节点数。每一个节点恰好被遍历一次。 空间复杂度：O(n)，为迭代过程中显式栈的开销，平均情况下为 O(log n)，最坏情况下树呈现链状，为 O(n)。 方法三：Morris 遍历 思路与算法 有一种巧妙的方法可以在线性时间内，只占用常数空间来实现后序遍历。这种方法由 J. H. Morris 在 1979 年的论文「Traversing Binary Trees Simply and Cheaply」中首次提出，因此被称为 Morris 遍历。 Morris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其后序遍历规则总结如下： 新建临时节点，令该节点为 root； 如果当前节点的左子节点为空，则遍历当前节点的右子节点； 如果当前节点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点； 如果前驱节点的右子节点为空，","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:43:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day44 102. 二叉树的层序遍历 题目 给你二叉树的根节点 root ，返回其节点值的 层序遍历 。 （即逐层地，从左到右访问所有节点）。 示例 1： 输入：root = [3,9,20,null,null,15,7] 输出：[[3],[9,20],[15,7]] 示例 2： 输入：root = [1] 输出：[[1]] 示例 3： 输入：root = [] 输出：[] 提示： 树中节点数目在范围 [0, 2000] 内 -1000 \u003c= Node.val \u003c= 1000 解法 解法一：深度优先 采用递归方法来找出层序序列。思路：我们知道，遍历递归地遍历二叉树是往深处走，我们只需要在往深处走的时候，将相同深度的节点放到一起即可。 class Solution { public List\u003cList\u003cInteger\u003e\u003e levelOrder(TreeNode root) { if (root==null) return new ArrayList\u003c\u003e(); List\u003cList\u003cInteger\u003e\u003e lls =new ArrayList\u003c\u003e(); doSome(root,1,lls); return lls; } // 递归层序遍历的秘诀：深度相同的节点放到同一个list public void doSome(TreeNode node,int depth,List\u003cList\u003cInteger\u003e\u003e lls){ // 当前深度下没有对应的“层list”，就创建 if(lls.size()\u003cdepth) { lls.add(new ArrayList\u003cInteger\u003e()); } //在同一深度，把节点加上去 lls.get(depth-1).add(node.val); if(node.left!=null) doSome(node.left,depth+1,lls); if(node.right!=null) doSome(node.right,depth+1,lls); } } /** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func levelOrder(root *TreeNode) [][]int { ans := [][]int{} if root==nil { return ans } var dfs func(root *TreeNode,depth int) dfs = func(root *TreeNode,depth int){ if root==nil{ return } if len(ans)\u003cdepth+1{ ans=append(ans,[]int{}) } ans[depth]=append(ans[depth],root.Val) dfs(root.Left,depth+1) dfs(root.Right,depth+1) return } dfs(root,0) return ans } 解法二：广度优先搜索 解题思路 本文将会讲解为什么这道题适合用广度优先搜索（BFS），以及 BFS 适用于什么样的场景。 DFS（深度优先搜索）和 BFS（广度优先搜索）就像孪生兄弟，提到一个总是想起另一个。然而在实际使用中，我们用 DFS 的时候远远多于 BFS。那么，是不是 BFS 就没有什么用呢？ 如果我们使用 DFS/BFS 只是为了遍历一棵树、一张图上的所有结点的话，那么 DFS 和 BFS 的能力没什么差别，我们当然更倾向于更方便写、空间复杂度更低的 DFS 遍历。不过，某些使用场景是 DFS 做不到的，只能使用 BFS 遍历。这就是本文要介绍的两个场景：「层序遍历」、「最短路径」。 本文包括以下内容： DFS 与 BFS 的特点比较 BFS 的适用场景 如何用 BFS 进行层序遍历 如何用 BFS 求解最短路径问题 DFS 与 BFS 让我们先看看在二叉树上进行 DFS 遍历和 BFS 遍历的代码比较。 DFS 遍历使用递归： void dfs(TreeNode root) { if (root == null) { return; } dfs(root.left); dfs(root.right); } BFS 遍历使用队列数据结构： void bfs(TreeNode root) { Queue\u003cTreeNode\u003e queue = new ArrayDeque\u003c\u003e(); queue.add(root); while (!queue.isEmpty()) { TreeNode node = queue.poll(","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:44:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day45 107. 二叉树的层序遍历 II 题目 给你二叉树的根节点 root ，返回其节点值 自底向上的层序遍历 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历） 示例 1： 输入：root = [3,9,20,null,null,15,7] 输出：[[15,7],[9,20],[3]] 示例 2： 输入：root = [1] 输出：[[1]] 示例 3： 输入：root = [] 输出：[] 提示： 树中节点数目在范围 [0, 2000] 内 -1000 \u003c= Node.val \u003c= 1000 解法 解法一：无脑广度优先 在前面一题的思路上，转换一下：只需要在添加当层遍历list时，插入头部即可。 题解 解法二：不优雅的深度优先遍历 将上题设深度优先产生的序列反序即可。 class Solution { void level(TreeNode root, int index, List\u003cList\u003cInteger\u003e\u003e res) { // 当前行对应的列表不存在，加一个空列表 if(res.size() \u003c index) { res.add(new ArrayList\u003cInteger\u003e()); } // 将当前节点的值加入当前行的 res 中 res.get(index-1).add(root.val); // 递归处理左子树 if(root.left != null) { level(root.left, index+1, res); } // 递归处理右子树 if(root.right != null) { level(root.right, index+1, res); } } public List\u003cList\u003cInteger\u003e\u003e levelOrderBottom(TreeNode root) { if(root == null) { return new ArrayList\u003cList\u003cInteger\u003e\u003e(); } List\u003cList\u003cInteger\u003e\u003e list = new ArrayList\u003cList\u003cInteger\u003e\u003e(); List\u003cList\u003cInteger\u003e\u003e res = new ArrayList\u003cList\u003cInteger\u003e\u003e(); level(root, 1, list); for(int i = list.size()-1; i \u003e= 0; i--){ res.add(list.get(i)); } return res; } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:45:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day46 199. 二叉树的右视图 题目 给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。 示例 1: 输入: [1,2,3,null,5,null,4] 输出: [1,3,4] 示例 2: 输入: [1,null,3] 输出: [1,3] 示例 3: 输入: [] 输出: [] 提示: 二叉树的节点个数的范围是 [0,100] -100 \u003c= Node.val \u003c= 100 解法 BFS 思路： 利用 BFS 进行层次遍历，记录下每层的最后一个元素。 时间复杂度： O(N)，每个节点都入队出队了 1 次。 空间复杂度： O(N)，使用了额外的队列空间。 class Solution { public List\u003cInteger\u003e rightSideView(TreeNode root) { if(root == null) return new ArrayList\u003cInteger\u003e(); Queue\u003cTreeNode\u003e queue = new LinkedList\u003c\u003e(); List\u003cInteger\u003e ls =new ArrayList\u003c\u003e(); queue.offer(root); while(!queue.isEmpty()){ int size = queue.size(); while(size\u003e0){ TreeNode node = queue.poll(); if(size==1) ls.add(node.val);// 层序遍历是最右边的节点最后被遍历 if(node.left!=null) queue.offer(node.left); if(node.right!=null) queue.offer(node.right); size--; } } return ls; } } DFS （时间100%） 思路： 我们按照 「根结点 -\u003e 右子树 -\u003e 左子树」 的顺序访问，就可以保证每层都是最先访问最右边的节点的。 （与先序遍历 「根结点 -\u003e 左子树 -\u003e 右子树」 正好相反，先序遍历每层最先访问的是最左边的节点） 时间复杂度： O(N)，每个节点都访问了 1 次。 空间复杂度： O(N)，因为这不是一棵平衡二叉树，二叉树的深度最少是 logN, 最坏的情况下会退化成一条链表，深度就是 N，因此递归时使用的栈空间是 O(N) 的。 class Solution { List\u003cInteger\u003e res = new ArrayList\u003c\u003e(); public List\u003cInteger\u003e rightSideView(TreeNode root) { dfs(root, 0); // 从根节点开始访问，根节点深度是0 return res; } private void dfs(TreeNode root, int depth) { if (root == null) { return; } // 先访问 当前节点，再递归地访问 右子树 和 左子树。 if (depth == res.size()) { // 如果当前节点所在深度还没有出现在res里，说明在该深度下当前节点是第一个被访问的节点，因此将当前节点加入res中。 res.add(root.val); } depth++; dfs(root.right, depth); dfs(root.left, depth); } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:46:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day47 429. N 叉树的层序遍历 题目 给定一个 N 叉树，返回其节点值的层序遍历。（即从左到右，逐层遍历）。 树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。 示例 1： 输入：root = [1,null,3,2,4,null,5,6] 输出：[[1],[3,2,4],[5,6]] 示例 2： 输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] 输出：[[1],[2,3,4,5],[6,7,8,9,10],[11,12,13],[14]] 提示： 树的高度不会超过 1000 树的节点总数在 [0, 10^4] 之间 解法 方法一：广度优先搜索 思路与算法 对于「层序遍历」的题目，我们一般使用广度优先搜索。在广度优先搜索的每一轮中，我们会遍历同一层的所有节点。 具体地，我们首先把根节点 root 放入队列中，随后在广度优先搜索的每一轮中，我们首先记录下当前队列中包含的节点个数（记为 cnt），即表示上一层的节点个数。在这之后，我们从队列中依次取出节点，直到取出了上一层的全部 cnt 个节点为止。当取出节点 cur 时，我们将 cur 的值放入一个临时列表，再将 cur 的所有子节点全部放入队列中。 当这一轮遍历完成后，临时列表中就存放了当前层所有节点的值。这样一来，当整个广度优先搜索完成后，我们就可以得到层序遍历的结果。 细节 需要特殊判断树为空的情况。 代码 class Solution { public List\u003cList\u003cInteger\u003e\u003e levelOrder(Node root) { if (root == null) return new ArrayList\u003c\u003e(); List\u003cList\u003cInteger\u003e\u003e lls = new ArrayList\u003c\u003e(); lls.add(new ArrayList\u003c\u003e()); lls.get(0).add(root.val); Queue\u003cNode\u003e queue = new LinkedList\u003c\u003e(root.children); while (!queue.isEmpty()) { int size = queue.size(); List\u003cInteger\u003e ls = new ArrayList\u003c\u003e(); while (size \u003e 0) { Node node = queue.poll(); ls.add(node.val); if (node.children != null) queue.addAll(node.children); size--; } lls.add(ls); } return lls; } } 复杂度分析 时间复杂度：O(n)，其中 n 是树中包含的节点个数。在广度优先搜索的过程中，我们需要遍历每一个节点恰好一次。 空间复杂度：O(n)，即为队列需要使用的空间。在最坏的情况下，树只有两层，且最后一层有 n-1 个节点，此时就需要 O(n) 的空间。 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:47:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day48 637. 二叉树的层平均值 题目 给定一个非空二叉树的根节点 root , 以数组的形式返回每一层节点的平均值。与实际答案相差 10-5 以内的答案可以被接受。 示例 1： 输入：root = [3,9,20,null,null,15,7] 输出：[3.00000,14.50000,11.00000] 解释：第 0 层的平均值为 3,第 1 层的平均值为 14.5,第 2 层的平均值为 11 。 因此返回 [3, 14.5, 11] 。 示例 2: 输入：root = [3,9,20,15,7] 输出：[3.00000,14.50000,11.00000] 提示： 树中节点数量在 [1, 104] 范围内 -231 \u003c= Node.val \u003c= 231 - 1 解法 方法一：深度优先搜索 使用深度优先搜索计算二叉树的层平均值，需要维护两个数组，counts 用于存储二叉树的每一层的节点数，sums 用于存储二叉树的每一层的节点值之和。搜索过程中需要记录当前节点所在层，如果访问到的节点在第 i 层，则将 counts[i] 的值加 1，并将该节点的值加到 sums[i]。 遍历结束之后，第 i 层的平均值即为 sums[i]/counts[i]。 class Solution { public List\u003cDouble\u003e averageOfLevels(TreeNode root) { List\u003cInteger\u003e counts = new ArrayList\u003cInteger\u003e(); List\u003cDouble\u003e sums = new ArrayList\u003cDouble\u003e(); dfs(root, 0, counts, sums); List\u003cDouble\u003e averages = new ArrayList\u003cDouble\u003e(); int size = sums.size(); for (int i = 0; i \u003c size; i++) { averages.add(sums.get(i) / counts.get(i)); } return averages; } public void dfs(TreeNode root, int level, List\u003cInteger\u003e counts, List\u003cDouble\u003e sums) { if (root == null) { return; } if (level \u003c sums.size()) { sums.set(level, sums.get(level) + root.val); counts.set(level, counts.get(level) + 1); } else { sums.add(1.0 * root.val); counts.add(1); } dfs(root.left, level + 1, counts, sums); dfs(root.right, level + 1, counts, sums); } } 复杂度分析 时间复杂度：O(n)，其中 n 是二叉树中的节点个数。 深度优先搜索需要对每个节点访问一次，对于每个节点，维护两个数组的时间复杂度都是 O(1)，因此深度优先搜索的时间复杂度是 O(n)。 遍历结束之后计算每层的平均值的时间复杂度是 O(h)，其中 h 是二叉树的高度，任何情况下都满足 h≤n。 因此总时间复杂度是 O(n)。 空间复杂度：O(n)，其中 n 是二叉树中的节点个数。空间复杂度取决于两个数组的大小和递归调用的层数，两个数组的大小都等于二叉树的高度，递归调用的层数不会超过二叉树的高度，最坏情况下，二叉树的高度等于节点个数。 方法二：广度优先搜索 也可以使用广度优先搜索计算二叉树的层平均值。从根节点开始搜索，每一轮遍历同一层的全部节点，计算该层的节点数以及该层的节点值之和，然后计算该层的平均值。 如何确保每一轮遍历的是同一层的全部节点呢？我们可以借鉴层次遍历的做法，广度优先搜索使用队列存储待访问节点，只要确保在每一轮遍历时，队列中的节点是同一层的全部节点即可。具体做法如下： 初始时，将根节点加入队列； 每一轮遍历时，将队列中的节点全部取出，计算这些节点的数量以及它们的节点值之和，并计算这些节点的平均值，然后将这些节点的全部非空子节点加入队列，重复上述操作直到队列为空，遍历结束。 由于初始时队列中只有根节点，满足队列中的节点是同一层的全部节点，每一轮遍历时都会将队列中的当前层节点全部取出，并将下一层的全部节点加入队列，因此可以确保每一轮遍历的是同一层的全部节点。 具体实现方面，可以在每一轮遍历之前获得队列中的节点数量 size，遍历时只遍历 size 个节点，即可满足每一轮遍历的是同一层的全部节点。 class Solut","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:48:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day49 98. 验证二叉搜索树 题目 给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。 有效 二叉搜索树定义如下： 节点的左子树只包含 小于 当前节点的数。 节点的右子树只包含 大于 当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1： 输入：root = [2,1,3] 输出：true 示例 2： 输入：root = [5,1,4,null,null,3,6] 输出：false 解释：根节点的值是 5 ，但是右子节点的值是 4 。 提示： 树中节点数目范围在[1, 104] 内 -2^31^ \u003c= Node.val \u003c= 2^31^ - 1 解法 方法一: 递归 思路和算法 要解决这道题首先我们要了解二叉搜索树有什么性质可以给我们利用，由题目给出的信息我们可以知道：如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。 这启示我们设计一个递归函数 helper(root, lower, upper) 来递归判断，函数表示考虑以 root 为根的子树，判断子树中所有节点的值是否都在 (l,r) 的范围内（注意是开区间）。如果 root 节点的值 val 不在 (l,r) 的范围内说明不满足条件直接返回，否则我们要继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树。 那么根据二叉搜索树的性质，在递归调用左子树时，我们需要把上界 upper 改为 root.val，即调用 helper(root.left, lower, root.val)，因为左子树里所有节点的值均小于它的根节点的值。同理递归调用右子树时，我们需要把下界 lower 改为 root.val，即调用 helper(root.right, root.val, upper)。 函数递归调用的入口为 helper(root, -inf, +inf)， inf 表示一个无穷大的值。 下图展示了算法如何应用在示例 2 上： class Solution { public boolean isValidBST(TreeNode root) { return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE); } // 主要是递归过程中传递了左右子节点的值用于比较 public boolean isValidBST(TreeNode node, long lower, long upper) { if (node == null) { return true; } if (node.val \u003c= lower || node.val \u003e= upper) { return false; } return isValidBST(node.left, lower, node.val) \u0026\u0026 isValidBST(node.right, node.val, upper); } } 复杂度分析 时间复杂度：O(n)，其中 n 为二叉树的节点个数。在递归调用的时候二叉树的每个节点最多被访问一次，因此时间复杂度为 O(n)。 空间复杂度：O(n)，其中 n 为二叉树的节点个数。递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，即二叉树的高度。最坏情况下二叉树为一条链，树的高度为 n ，递归最深达到 n 层，故最坏情况下空间复杂度为 O(n) 。 方法二：中序遍历+类似于单调栈 思路和算法 基于方法一中提及的性质，我们可以进一步知道二叉搜索树「中序遍历」得到的值构成的序列一定是升序的，这启示我们在中序遍历的时候实时检查当前节点的值是否大于前一个中序遍历到的节点的值即可。如果均大于说明这个序列是升序的，整棵树是二叉搜索树，否则不是，下面的代码我们使用栈来模拟中序遍历的过程。 可能有读者不知道中序遍历是什么，我们这里简单提及。中序遍历是二叉树的一种遍历方式，它先遍历左子树，再遍历根节点，最后遍历右子树。而我们二叉搜索树保证了左子树的节点的值均小于根节点的值，根节点的值均小于右子树的值，因此中序遍历以后得到的序列一定是升序序列。 class Solution { public boolean isValidBST(TreeNode root) { Deque\u003cTreeNode\u003e stack = new LinkedList\u003cTreeNode\u003e(); double inorder = -Double.MAX_VALUE; while (!stack.isEmpty() || root != null) { while (root !=","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:49:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day50 108. 将有序数组转换为二叉搜索树 题目 给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。 高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。 示例 1： 输入：nums = [-10,-3,0,5,9] 输出：[0,-3,9,-10,null,5] 解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案： 示例 2： 输入：nums = [1,3] 输出：[3,1] 解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。 提示： 1 \u003c= nums.length \u003c= 104 -104 \u003c= nums[i] \u003c= 104 nums 按 严格递增 顺序排列 解法 前言 二叉搜索树的中序遍历是升序序列，题目给定的数组是按照升序排序的有序数组，因此可以确保数组是二叉搜索树的中序遍历序列。 **给定二叉搜索树的中序遍历，是否可以唯一地确定二叉搜索树？答案是否定的。**如果没有要求二叉搜索树的高度平衡，则任何一个数字都可以作为二叉搜索树的根节点，因此可能的二叉搜索树有多个。 如果增加一个限制条件，即要求二叉搜索树的高度平衡，是否可以唯一地确定二叉搜索树？答案仍然是否定的。 直观地看，我们可以选择中间数字作为二叉搜索树的根节点，这样分给左右子树的数字个数相同或只相差 11，可以使得树保持平衡。如果数组长度是奇数，则根节点的选择是唯一的，如果数组长度是偶数，则可以选择中间位置左边的数字作为根节点或者选择中间位置右边的数字作为根节点，选择不同的数字作为根节点则创建的平衡二叉搜索树也是不同的。 确定平衡二叉搜索树的根节点之后，其余的数字分别位于平衡二叉搜索树的左子树和右子树中，左子树和右子树分别也是平衡二叉搜索树，因此可以通过递归的方式创建平衡二叉搜索树。 当然，这只是我们直观的想法，为什么这么建树一定能保证是「平衡」的呢？这里可以参考「1382. 将二叉搜索树变平衡」，这两道题的构造方法完全相同，这种方法是正确的，1382 题解中给出了这个方法的正确性证明：1382 官方题解，感兴趣的同学可以戳进去参考。 递归的基准情形是平衡二叉搜索树不包含任何数字，此时平衡二叉搜索树为空。 在给定中序遍历序列数组的情况下，每一个子树中的数字在数组中一定是连续的，因此可以通过数组下标范围确定子树包含的数字，下标范围记为 [left,right]。对于整个中序遍历序列，下标范围从 left=0 到 right*=nums.length−1。当 left\u003e*right 时，平衡二叉搜索树为空。 以下三种方法中，方法一总是选择中间位置左边的数字作为根节点，方法二总是选择中间位置右边的数字作为根节点，方法三是方法一和方法二的结合，选择任意一个中间位置数字作为根节点。 方法一：中序遍历，总是选择中间位置左边的数字作为根节点 选择中间位置左边的数字作为根节点，则根节点的下标为 mid*=(*left+right)/2，此处的除法为整数除法。 class Solution { public TreeNode sortedArrayToBST(int[] nums) { return helper(nums, 0, nums.length - 1); } public TreeNode helper(int[] nums, int left, int right) { if (left \u003e right) { return null; } // 总是选择中间位置左边的数字作为根节点 int mid = (left + right) / 2; TreeNode root = new TreeNode(nums[mid]); root.left = helper(nums, left, mid - 1); root.right = helper(nums, mid + 1, right); return root; } } 复杂度分析 时间复杂度：O(n)，其中 n 是数组的长度。每个数字只访问一次。 空间复杂度：O(log n)，其中 n 是数组的长度。空间复杂度不考虑返回值，因此空间复杂度主要取决于递归栈的深度，递归栈的深度是 O(log n)。 方法二：中序遍历，总是选择中间位置右边的数字作为根节点 选择中间位置右边的数字作为根节点，则根节点的下标为 mid=(left+right+1)/2，此处的除法为整数除法。 class Solution { public TreeNode sortedArrayToBST(int[] nums) { return helper(nums, 0, nums.length - 1); } publ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:50:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day51 235. 二叉搜索树的最近公共祖先 题目 给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5] 示例 1: 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 输出: 6 解释: 节点 2 和节点 8 的最近公共祖先是 6。 示例 2: 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 输出: 2 解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉搜索树中。 解法 方法一：两次遍历 思路与算法 注意到题目中给出的是一棵「二叉搜索树」，因此我们可以快速地找出树中的某个节点以及从根节点到该节点的路径，例如我们需要找到节点 p： 我们从根节点开始遍历； 如果当前节点就是 p，那么成功地找到了节点； 如果当前节点的值大于 p 的值，说明 p 应该在当前节点的左子树，因此将当前节点移动到它的左子节点； 如果当前节点的值小于 p 的值，说明 p 应该在当前节点的右子树，因此将当前节点移动到它的右子节点。 对于节点 q 同理。在寻找节点的过程中，我们可以顺便记录经过的节点，这样就得到了从根节点到被寻找节点的路径。 当我们分别得到了从根节点到 p 和 q 的路径之后，我们就可以很方便地找到它们的最近公共祖先了。显然，p 和 q 的最近公共祖先就是从根节点到它们路径上的「分岔点」，也就是最后一个相同的节点。因此，如果我们设从根节点到 p 的路径为数组 path_p，从根节点到 q 的路径为数组 path_q，那么只要找出最大的编号 i，其满足path_p[i]=path_q[i] 那么对应的节点就是「分岔点」，即 p 和 q 的最近公共祖先就是 path_p[i]（或 path_q[i]）。 代码 class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { List\u003cTreeNode\u003e path_p = getPath(root, p); List\u003cTreeNode\u003e path_q = getPath(root, q); TreeNode ancestor = null; for (int i = 0; i \u003c path_p.size() \u0026\u0026 i \u003c path_q.size(); ++i) { if (path_p.get(i) == path_q.get(i)) { ancestor = path_p.get(i); } else { break; } } return ancestor; } public List\u003cTreeNode\u003e getPath(TreeNode root, TreeNode target) { List\u003cTreeNode\u003e path = new ArrayList\u003cTreeNode\u003e(); TreeNode node = root; while (node != target) { path.add(node); if (target.val \u003c node.val) { node = node.left; } else { node = node.right; } } path.add(node); return path; } } 复杂度分析 时间复杂度：O(n)，其中 n 是给定的二叉搜索树中的节点个数。上述代码需要的时间与节点 p 和 q 在树中的深度线性相关，而在最坏的情况下，树呈现链式结构，p 和 q 一个是树的唯一叶子结点，一个是该叶子结点的父节点，此时时间复杂度为Θ(n)。 空间复杂度：O(n)，我们需要存储根节点到 p 和 q 的路径。和上面的分析方法相同，在最坏的情况下，路径的长度为 Θ(n)，因此需要 Θ(n) 的空间。 方法二：一次遍历 思路与算法 在方法一中，我们对从根节点开始，通过遍历找出到达节点 p 和 q 的路径，一共需要两次遍历。我们也可以考虑将这两个节点放在一起遍历。 整体的遍历过程与方法一中的类似： 我们从根节点开始遍历； 如果当前节点的值大于 p 和 q 的值，说明 p 和 q 应该在当前节点的左子树，因此将","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:51:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day51 450. 删除二叉搜索树中的节点 题目 给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。 一般来说，删除节点可分为两个步骤： 首先找到需要删除的节点； 如果找到了，删除它。 示例 1: 输入：root = [5,3,6,2,4,null,7], key = 3 输出：[5,4,6,2,null,null,7] 解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。 一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。 另一个正确答案是 [5,2,6,null,4,null,7]。 示例 2: 输入: root = [5,3,6,2,4,null,7], key = 0 输出: [5,3,6,2,4,null,7] 解释: 二叉树不包含值为 0 的节点 示例 3: 输入: root = [], key = 0 输出: [] 提示: 节点数的范围 [0, 104]. -105 \u003c= Node.val \u003c= 105 节点值唯一 root 是合法的二叉搜索树 -105 \u003c= key \u003c= 105 进阶： 要求算法时间复杂度为 O(h)，h 为树的高度。 解法 方法一：递归 思路 二叉搜索树有以下性质： 左子树的所有节点（如果有）的值均小于当前节点的值； 右子树的所有节点（如果有）的值均大于当前节点的值； 左子树和右子树均为二叉搜索树。 二叉搜索树的题目往往可以用递归来解决。此题要求删除二叉树的节点，函数 deleteNode 的输入是二叉树的根节点 root 和一个整数 key，输出是删除值为 key 的节点后的二叉树，并保持二叉树的有序性。可以按照以下情况分类讨论： root 为空，代表未搜索到值为 key 的节点，返回空。 root.val*\u003e*key，表示值为 key 的节点可能存在于 root 的左子树中，需要递归地在 root.left 调用 deleteNode，并返回 root。 root.val*\u003c*key，表示值为 key 的节点可能存在于 root 的右子树中，需要递归地在 root.right 调用 deleteNode，并返回root。 root.val*=*key，root即为要删除的节点。此时要做的是删除root，并将它的子树合并成一棵子树，保持有序性，并返回根节点。根据root的子树情况分成以下情况讨论： root 为叶子节点，没有子树。此时可以直接将它删除，即返回空。 root 只有左子树，没有右子树。此时可以将它的左子树作为新的子树，返回它的左子节点。 root 只有右子树，没有左子树。此时可以将它的右子树作为新的子树，返回它的右子节点。 root 有左右子树，这时可以将 root 的后继节点（比 root 大的最小节点，即它的右子树中的最小节点，记为 successor）作为新的根节点替代 root，并将 successor 从 root 的右子树中删除，使得在保持有序性的情况下合并左右子树。 简单证明，successor 位于 root 的右子树中，因此大于 root 的所有左子节点；successor 是 root 的右子树中的最小节点，因此小于 root 的右子树中的其他节点。以上两点保持了新子树的有序性。 在代码实现上，我们可以先寻找 successor，再删除它。successor 是 root 的右子树中的最小节点，可以先找到 root 的右子节点，再不停地往左子节点寻找，直到找到一个不存在左子节点的节点，这个节点即为 successor。然后递归地在 root.right 调用 deleteNode 来删除 successor。因为 successor 没有左子节点，因此这一步递归调用不会再次步入这一种情况。然后将 successor 更新为新的 root 并返回。 代码 class Solution { public TreeNode deleteNode(TreeNode root, int key) { if (root == null) { return null; } if (root.val \u003e key) { root.left = deleteNode(root.left, key); return root; } if (root.val \u003c key) { root.right = deleteNode(root.right, key); return root; } if (root.val == key) { if (root.left == null \u0026\u0026 root.right == ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:52:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day52 501. 二叉搜索树中的众数 题目 给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。 如果树中有不止一个众数，可以按 任意顺序 返回。 假定 BST 满足如下定义： 结点左子树中所含节点的值 小于等于 当前节点的值 结点右子树中所含节点的值 大于等于 当前节点的值 左子树和右子树都是二叉搜索树 示例 1： 输入：root = [1,null,2,2] 输出：[2] 示例 2： 输入：root = [0] 输出：[0] 提示： 树中节点的数目在范围 [1, 104] 内 -105 \u003c= Node.val \u003c= 105 **进阶：**你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内） 解法 方法一：当作普通二叉树 先便利二叉树，然后值作为键，重复次数作为值放到一个map，之后统计这个map即可 方法二：中序遍历 思路与算法 首先我们一定能想到一个最朴素的做法：因为这棵树的中序遍历是一个有序的序列，所以我们可以先获得这棵树的中序遍历，然后从扫描这个中序遍历序列，然后用一个哈希表来统计每个数字出现的个数，这样就可以找到出现次数最多的数字。但是这样做的空间复杂度显然不是 O(1) 的，原因是哈希表和保存中序遍历序列的空间代价都是 O(n)。 首先，我们考虑在寻找出现次数最多的数时，不使用哈希表。 这个优化是基于二叉搜索树中序遍历的性质：一棵二叉搜索树的中序遍历序列是一个非递减的有序序列。例如： 1 / \\ 0 2 / \\ / -1 0 2 这样一颗二叉搜索树的中序遍历序列是 {−1,0,0,1,2,2}。我们可以发现重复出现的数字一定是一个连续出现的，例如这里的 0 和 2，它们都重复出现了，并且所有的 0 都集中在一个连续的段内，所有的 2 也集中在一个连续的段内。我们可以顺序扫描中序遍历序列，用 base 记录当前的数字，用 count 记录当前数字重复的次数，用 maxCount 来维护已经扫描过的数当中出现最多的那个数字的出现次数，用 answer 数组记录出现的众数。每次扫描到一个新的元素： 首先更新base和count: 如果该元素和 base 相等，那么 count 自增 1； 否则将 base 更新为当前数字，count 复位为 1。 然后更新maxCount： 如果 count = maxCount，那么说明当前的这个数字（base）出现的次数等于当前众数出现的次数，将 base 加入 answer 数组； 如果 count*\u003e*maxCount，那么说明当前的这个数字（base）出现的次数大于当前众数出现的次数，因此，我们需要将 maxCount 更新为 count，清空 answer 数组后将 base 加入 answer 数组。 我们可以把这个过程写成一个 update 函数。这样我们在寻找出现次数最多的数字的时候就可以省去一个哈希表带来的空间消耗。 然后，我们考虑不存储这个中序遍历序列。 如果我们在递归进行中序遍历的过程中，访问当了某个点的时候直接使用上面的 update 函数，就可以省去中序遍历序列的空间，代码如下。 代码 class Solution { List\u003cInteger\u003e answer = new ArrayList\u003cInteger\u003e(); int base, count, maxCount; public int[] findMode(TreeNode root) { dfs(root); int[] mode = new int[answer.size()]; for (int i = 0; i \u003c answer.size(); ++i) { mode[i] = answer.get(i); } return mode; } public void dfs(TreeNode o) { if (o == null) { return; } dfs(o.left); update(o.val); dfs(o.right); } public void update(int x) { if (x == base) { ++count; } else { count = 1; base = x; } if (count == maxCount) { answer.add(base); } if (count \u003e maxCount) { maxCount = count; answer.clear(); answer.add(base); } } } 复杂度分析 时间复杂度：O(n)。即遍历这棵树的复杂度。 空间复杂度：O(n)。即递归的栈空间的空间代价。 方法三：Morris 中序遍历 思路与","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:53:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day53 530. 二叉搜索树的最小绝对差 题目 给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。 差值是一个正数，其数值等于两值之差的绝对值。 示例 1： 输入：root = [4,2,6,1,3] 输出：1 示例 2： 输入：root = [1,0,48,null,null,12,49] 输出：1 提示： 树中节点的数目范围是 [2, 104] 0 \u003c= Node.val \u003c= 105 **注意：**本题与 783 https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/ 相同 解法 方法一：中序遍历 思路与算法 考虑对升序数组 aa 求任意两个元素之差的绝对值的最小值，答案一定为相邻两个元素之差的最小值，即 $$ \\textit{ans}=\\min_{i=0}^{n-2}\\left{a[i+1]-a[i]\\right} $$ 其中 n 为数组 a 的长度。其他任意间隔距离大于等于 2 的下标对 (i,j) 的元素之差一定大于下标对 (i,i+1) 的元素之差，故不需要再被考虑。 回到本题，本题要求二叉搜索树任意两节点差的绝对值的最小值，而我们知道二叉搜索树有个性质为二叉搜索树中序遍历得到的值序列是递增有序的，因此我们只要得到中序遍历后的值序列即能用上文提及的方法来解决。 朴素的方法是经过一次中序遍历将值保存在一个数组中再进行遍历求解，我们也可以在中序遍历的过程中用 pre 变量保存前驱节点的值，这样即能边遍历边更新答案，不再需要显式创建数组来保存，需要注意的是 pre 的初始值需要设置成任意负数标记开头，下文代码中设置为 -1−1。 二叉树的中序遍历有多种方式，包括递归、栈、Morris 遍历等，读者可选择自己最擅长的来实现。下文代码提供最普遍的递归方法来实现，其他遍历方法的介绍可以详细看「94. 二叉树的中序遍历的官方题解」，这里不再赘述。 代码 class Solution { int pre; int ans; public int getMinimumDifference(TreeNode root) { ans = Integer.MAX_VALUE; pre = -1; dfs(root); return ans; } public void dfs(TreeNode root) { if (root == null) { return; } dfs(root.left); if (pre == -1) { pre = root.val; } else { ans = Math.min(ans, root.val - pre); pre = root.val; } dfs(root.right); } } 复杂度分析 时间复杂度：O(n)，其中 n 为二叉搜索树节点的个数。每个节点在中序遍历中都会被访问一次且只会被访问一次，因此总时间复杂度为 O(n)。 空间复杂度：O(n)。递归函数的空间复杂度取决于递归的栈深度，而栈深度在二叉搜索树为一条链的情况下会达到 O(n) 级别。 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:54:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day54 538. 把二叉搜索树转换为累加树 题目 给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。 提醒一下，二叉搜索树满足下列约束条件： 节点的左子树仅包含键 小于 节点键的节点。 节点的右子树仅包含键 大于 节点键的节点。 左右子树也必须是二叉搜索树。 **注意：**本题和 1038: https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ 相同 示例 1： 输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8] 输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8] 示例 2： 输入：root = [0,null,1] 输出：[1,null,1] 示例 3： 输入：root = [1,0,2] 输出：[3,3,2] 示例 4： 输入：root = [3,2,4,1] 输出：[7,9,4,10] 提示： 树中的节点数介于 0 和 104 之间。 每个节点的值介于 -104 和 104 之间。 树中的所有值 互不相同 。 给定的树为二叉搜索树。 解法 前言 二叉搜索树是一棵空树，或者是具有下列性质的二叉树： 若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值； 它的左、右子树也分别为二叉搜索树。 由这样的性质我们可以发现，二叉搜索树的中序遍历是一个单调递增的有序序列。如果我们反序地中序遍历该二叉搜索树，即可得到一个单调递减的有序序列。 方法一：反序中序遍历 思路及算法 本题中要求我们将每个节点的值修改为原来的节点值加上所有大于它的节点值之和。这样我们只需要反序中序遍历该二叉搜索树，记录过程中的节点值之和，并不断更新当前遍历到的节点的节点值，即可得到题目要求的累加树。 代码 class Solution { int sum = 0; public TreeNode convertBST(TreeNode root) { if (root != null) { convertBST(root.right); sum += root.val; root.val = sum; convertBST(root.left); } return root; } } 复杂度分析 时间复杂度：O(n)，其中 n 是二叉搜索树的节点数。每一个节点恰好被遍历一次。 空间复杂度：O(n)，为递归过程中栈的开销，平均情况下为 O(log n)，最坏情况下树呈现链状，为 O(n)。 方法二：Morris 遍历 思路及算法 有一种巧妙的方法可以在线性时间内，只占用常数空间来实现中序遍历。这种方法由 J. H. Morris 在 1979 年的论文「Traversing Binary Trees Simply and Cheaply」中首次提出，因此被称为 Morris 遍历。 Morris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其反序中序遍历规则总结如下： 如果当前节点的右子节点为空，处理当前节点，并遍历当前节点的左子节点； 如果当前节点的右子节点不为空，找到当前节点右子树的最左节点（该节点为当前节点中序遍历的前驱节点）； 如果最左节点的左指针为空，将最左节点的左指针指向当前节点，遍历当前节点的右子节点； 如果最左节点的左指针不为空，将最左节点的左指针重新置为空（恢复树的原状），处理当前节点，并将当前节点置为其左节点； 重复步骤 1 和步骤 2，直到遍历结束。 这样我们利用 Morris 遍历的方法，反序中序遍历该二叉搜索树，即可实现线性时间与常数空间的遍历。 代码 class Solution { public TreeNode convertBST(TreeNode root) { int sum = 0; TreeNode node = root; while (node != null) { if (node.right == null) { sum += node.val; node.val = sum; node = node.left; } else { TreeNode succ = getSuccessor(node); if (succ.left == null) { succ.left = node; node = node.right; } else { succ.left = null; s","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:55:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day55 669. 修剪二叉搜索树 题目 给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。 所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。 示例 1： 输入：root = [1,0,2], low = 1, high = 2 输出：[1,null,2] 示例 2： 输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3 输出：[3,2,null,1] 提示： 树中节点数在范围 [1, 104] 内 0 \u003c= Node.val \u003c= 104 树中每个节点的值都是 唯一 的 题目数据保证输入是一棵有效的二叉搜索树 0 \u003c= low \u003c= high \u003c= 104 解法 方法一：递归 对根结点 root 进行深度优先遍历。对于当前访问的结点，如果结点为空结点，直接返回空结点；如果结点的值小于 low，那么说明该结点及它的左子树都不符合要求，我们返回对它的右结点进行修剪后的结果；如果结点的值大于 high，那么说明该结点及它的右子树都不符合要求，我们返回对它的左子树进行修剪后的结果；如果结点的值位于区间 [low,high]，我们将结点的左结点设为对它的左子树修剪后的结果，右结点设为对它的右子树进行修剪后的结果。 class Solution { public TreeNode trimBST(TreeNode root, int low, int high) { if (root == null) { return null; } if (root.val \u003c low) { return trimBST(root.right, low, high); } else if (root.val \u003e high) { return trimBST(root.left, low, high); } else { root.left = trimBST(root.left, low, high); root.right = trimBST(root.right, low, high); return root; } } } 复杂度分析 时间复杂度：O(n)，其中 n 为二叉树的结点数目。 空间复杂度：O(n)。递归栈最坏情况下需要 O(n) 的空间。 方法二：迭代 如果一个结点 node 符合要求，即它的值位于区间 [low, high]，那么它的左子树与右子树应该如何修剪？ 我们先讨论左子树的修剪： node 的左结点为空结点：不需要修剪 node 的左结点非空： 如果它的左结点 left 的值小于 low，那么 left 以及 left 的左子树都不符合要求，我们将 node 的左结点设为 left 的右结点，然后再重新对 node 的左子树进行修剪。 如果它的左结点 left 的值大于等于 low，又因为 node 的值已经符合要求，所以 left 的右子树一定符合要求。基于此，我们只需要对 left 的左子树进行修剪。我们令 node 等于 left ，然后再重新对 node 的左子树进行修剪。 以上过程可以迭代处理。对于右子树的修剪同理。 我们对根结点进行判断，如果根结点不符合要求，我们将根结点设为对应的左结点或右结点，直到根结点符合要求，然后将根结点作为符合要求的结点，依次修剪它的左子树与右子树。 class Solution { public TreeNode trimBST(TreeNode root, int low, int high) { while (root != null \u0026\u0026 (root.val \u003c low || root.val \u003e high)) { if (root.val \u003c low) { root = root.right; } else { root = root.left; } } if (root == null) { return null; } for (TreeNode node = root; node.left != null; ) { if (node.left.val \u003c low) { node.left = node.left.right; } else { node = node.left; } } for (TreeNode node = root; node.right != null; ) { if (node.right.val \u003e high) { ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:56:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day56 701. 二叉搜索树中的插入操作 题目 给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。 注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。 示例 1： 输入：root = [4,2,7,1,3], val = 5 输出：[4,2,7,1,3,5] 解释：另一个满足题目要求可以通过的树是： 示例 2： 输入：root = [40,20,60,10,30,50,70], val = 25 输出：[40,20,60,10,30,50,70,null,null,25] 示例 3： 输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5 输出：[4,2,7,1,3,5] 提示： 树中的节点数将在 [0, 104]的范围内。 -108 \u003c= Node.val \u003c= 108 所有值 Node.val 是 独一无二 的。 -108 \u003c= val \u003c= 108 保证 val 在原始BST中不存在。 解法 方法一：模拟 思路与算法 首先回顾二叉搜索树的性质：对于任意节点 root 而言，左子树（如果存在）上所有节点的值均小于 root.val，右子树（如果存在）上所有节点的值均大于 root.val，且它们都是二叉搜索树。 因此，当将 val 插入到以 root 为根的子树上时，根据 val 与 root.val 的大小关系，就可以确定要将 val 插入到哪个子树中。 如果该子树不为空，则问题转化成了将 val 插入到对应子树上。 否则，在此处新建一个以 val 为值的节点，并链接到其父节点 root 上。 代码 class Solution { public TreeNode insertIntoBST(TreeNode root, int val) { if (root == null) { return new TreeNode(val); } TreeNode pos = root; while (pos != null) { if (val \u003c pos.val) { if (pos.left == null) { pos.left = new TreeNode(val); break; } else { pos = pos.left; } } else { if (pos.right == null) { pos.right = new TreeNode(val); break; } else { pos = pos.right; } } } return root; } } 复杂度分析 时间复杂度：O(N)，其中 N 为树中节点的数目。最坏情况下，我们需要将值插入到树的最深的叶子结点上，而叶子节点最深为 O(N)。 空间复杂度：O(1)。我们只使用了常数大小的空间。 方法二：递归、 我们知道二叉搜索树插入新的节点时，如果还要满足BST性质，那么还有一种简单得思路：直接遍历到何时得叶子节点，插入到叶子节点末尾即可。 class Solution { TreeNode parent = null; int flag = 0; // 二叉排序树插入节点，一定可以插入到叶子节点 public TreeNode insertIntoBST(TreeNode root, int val) { if(root==null) { if(flag == -1){ return new TreeNode(val); }else{ return new TreeNode(val); } } if(val\u003eroot.val){ parent = root; flag = 1; root.right = insertIntoBST(root.right,val); } else if(val\u003croot.val){ parent = root; flag = -1; root.left = insertIntoBST(root.left,val); } return root; } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:57:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day57 110. 平衡二叉树 题目 给定一个二叉树，判断它是否是高度平衡的二叉树。 本题中，一棵高度平衡二叉树定义为： 一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。 示例 1： 输入：root = [3,9,20,null,null,15,7] 输出：true 示例 2： 输入：root = [1,2,2,3,3,null,null,4,4] 输出：false 示例 3： 输入：root = [] 输出：true 提示： 树中的节点数在范围 [0, 5000] 内 -104 \u003c= Node.val \u003c= 104 解法 前言 这道题中的平衡二叉树的定义是：二叉树的每个节点的左右子树的高度差的绝对值不超过 1，则二叉树是平衡二叉树。根据定义，一棵二叉树是平衡二叉树，当且仅当其所有子树也都是平衡二叉树，因此可以使用递归的方式判断二叉树是不是平衡二叉树，递归的顺序可以是自顶向下或者自底向上。 方法一：自顶向下的递归 定义函数 height，用于计算二叉树中的任意一个节点 p 的高度： $$ \\texttt{height}(p) = \\begin{cases} 0 \u0026 p \\text{ 是空节点}\\ \\max(\\texttt{height}(p.\\textit{left}), \\texttt{height}(p.\\textit{right}))+1 \u0026 p \\text{ 是非空节点} \\end{cases} $$ 有了计算节点高度的函数，即可判断二叉树是否平衡。具体做法类似于二叉树的前序遍历，即对于当前遍历到的节点，首先计算左右子树的高度，如果左右子树的高度差是否不超过 1，再分别递归地遍历左右子节点，并判断左子树和右子树是否平衡。这是一个自顶向下的递归的过程。 class Solution { public boolean isBalanced(TreeNode root) { if (root == null) { return true; } else { return Math.abs(height(root.left) - height(root.right)) \u003c= 1 \u0026\u0026 isBalanced(root.left) \u0026\u0026 isBalanced(root.right); } } public int height(TreeNode root) { if (root == null) { return 0; } else { return Math.max(height(root.left), height(root.right)) + 1; } } } 复杂度分析 时间复杂度：O(n^2)，其中 n 是二叉树中的节点个数。 最坏情况下，二叉树是满二叉树，需要遍历二叉树中的所有节点，时间复杂度是 O(n)。 对于节点 p，如果它的高度是 d，则 height(p) 最多会被调用 d 次（即遍历到它的每一个祖先节点时）。对于平均的情况，一棵树的高度 h 满足 O(h)=O(logn)，因为 d≤h，所以总时间复杂度为 O(nlog n)。对于最坏的情况，二叉树形成链式结构，高度为 O(n)，此时总时间复杂度为 O(n^2)。 空间复杂度：O(n)，其中 n 是二叉树中的节点个数。空间复杂度主要取决于递归调用的层数，递归调用的层数不会超过 n。 方法二：自底向上的递归 方法一由于是自顶向下递归，因此对于同一个节点，函数 height 会被重复调用，导致时间复杂度较高。如果使用自底向上的做法，则对于每个节点，函数 height 只会被调用一次。 自底向上递归的做法类似于后序遍历，对于当前遍历到的节点，先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。如果一棵子树是平衡的，则返回其高度（高度一定是非负整数），否则返回 -1。如果存在一棵子树不平衡，则整个二叉树一定不平衡。 class Solution { public boolean isBalanced(TreeNode root) { return height(root) \u003e= 0; } public int height(TreeNode root) { if (root == null) { return 0; } int leftHeight = height(root.left); int rightHeight = height(root.right); if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) \u003e 1) { return -1; } else { return Math.max(leftHeight, ri","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:58:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day58 1382. 将二叉搜索树变平衡 题目 给你一棵二叉搜索树，请你返回一棵 平衡后 的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。如果有多种构造方法，请你返回任意一种。 如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 1 ，我们就称这棵二叉搜索树是 平衡的 。 示例 1： 输入：root = [1,null,2,null,3,null,4,null,null] 输出：[2,1,3,null,null,null,4] 解释：这不是唯一的正确答案，[3,1,4,null,2,null,null] 也是一个可行的构造方案。 示例 2： 输入: root = [2,1,3] 输出: [2,1,3] 提示： 树节点的数目在 [1, 104] 范围内。 1 \u003c= Node.val \u003c= 105 解法 贪心构造 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:59:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day59 28. 找出字符串中第一个匹配项的下标 题目 给你两个字符串 haystack 和 needle ，请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标（下标从 0 开始）。如果 needle 不是 haystack 的一部分，则返回 -1 。 示例 1： 输入：haystack = \"sadbutsad\", needle = \"sad\" 输出：0 解释：\"sad\" 在下标 0 和 6 处匹配。 第一个匹配项的下标是 0 ，所以返回 0 。 示例 2： 输入：haystack = \"leetcode\", needle = \"leeto\" 输出：-1 解释：\"leeto\" 没有在 \"leetcode\" 中出现，所以返回 -1 。 提示： 1 \u003c= haystack.length, needle.length \u003c= 104 haystack 和 needle 仅由小写英文字符组成 解法 KMP ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:60:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day60 459. 重复的子字符串 题目 给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。 示例 1: 输入: s = \"abab\" 输出: true 解释: 可由子串 \"ab\" 重复两次构成。 示例 2: 输入: s = \"aba\" 输出: false 示例 3: 输入: s = \"abcabcabcabc\" 输出: true 解释: 可由子串 \"abc\" 重复四次构成。 (或子串 \"abcabc\" 重复两次构成。) 提示： 1 \u003c= s.length \u003c= 104 s 由小写英文字母组成 解法 https://leetcode.cn/problems/repeated-substring-pattern/solution/zhong-fu-de-zi-zi-fu-chuan-by-leetcode-solution/ ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:61:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day61 50. Pow(x, n) 题目 实现 pow(x, n) ，即计算 x 的整数 n 次幂函数（即，xn ）。 示例 1： 输入：x = 2.00000, n = 10 输出：1024.00000 示例 2： 输入：x = 2.10000, n = 3 输出：9.26100 示例 3： 输入：x = 2.00000, n = -2 输出：0.25000 解释：2-2 = 1/22 = 1/4 = 0.25 提示： -100.0 \u003c x \u003c 100.0 -231 \u003c= n \u003c= 231-1 -104 \u003c= xn \u003c= 104 解法 使用暴力迭代和暴力递归均会爆栈或超时 // 递归求解爆栈 public double myPow(double x, int n) { if(n==0) return 1.0; else if(n\u003e0) return myPow(x,n-1)*x; else return myPow(x,n+1)*(1.0/x); } // 迭代超时 public double myPow(double x, int n) { if(n==0) return 1.0; else if(n\u003e0) { double r=x; for(int i=0;i\u003cn-1;i++){ r=r*x; } return r; }else { double r=(1.0/x); for(int i=0;i\u003c-n-1;i++){ r =r*(1.0/x); } return r; } } 方法一：快速幂+递归 方法二：快速幂+迭代 https://leetcode.cn/problems/powx-n/solution/powx-n-by-leetcode-solution/ ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:62:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day62 33. 搜索旋转排序数组 题目 整数数组 nums 按升序排列，数组中的值 互不相同 。 在传递给函数之前，nums 在预先未知的某个下标 k（0 \u003c= k \u003c nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。 给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的下标，否则返回 -1 。 你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。 示例 1： 输入：nums = [4,5,6,7,0,1,2], target = 0 输出：4 示例 2： 输入：nums = [4,5,6,7,0,1,2], target = 3 输出：-1 示例 3： 输入：nums = [1], target = 0 输出：-1 提示： 1 \u003c= nums.length \u003c= 5000 -104 \u003c= nums[i] \u003c= 104 nums 中的每个值都 独一无二 题目数据保证 nums 在预先未知的某个下标上进行了旋转 -104 \u003c= target \u003c= 104 解法 https://leetcode.cn/problems/search-in-rotated-sorted-array/solution/sou-suo-xuan-zhuan-pai-xu-shu-zu-by-leetcode-solut/ func search(nums []int, target int) int { l:=0 r:=len(nums)-1 mid :=0 for l\u003c=r { mid = (r-l)/2+l if nums[mid] == target { return mid } if nums[mid]\u003cnums[0]{// 右边有序 if target\u003c=nums[r]\u0026\u0026target\u003enums[mid]{ l = mid + 1 }else{ r = mid - 1 } }else{// 左边有序 if target\u003e=nums[l]\u0026\u0026target\u003cnums[mid]{ r = mid - 1 }else{ l = mid + 1 } } } return -1 } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:63:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day63 34. 在排序数组中查找元素的第一个和最后一个位置 题目 给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。 如果数组中不存在目标值 target，返回 [-1, -1]。 你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。 示例 1： 输入：nums = [5,7,7,8,8,10], target = 8 输出：[3,4] 示例 2： 输入：nums = [5,7,7,8,8,10], target = 6 输出：[-1,-1] 示例 3： 输入：nums = [], target = 0 输出：[-1,-1] 提示： 0 \u003c= nums.length \u003c= 105 -109 \u003c= nums[i] \u003c= 109 nums 是一个非递减数组 -109 \u003c= target \u003c= 109 解法 官方题解 二分+暴力 先二分找数，找到之后再两边扩展。 问题：如果查找的数组重复度很高，而且刚好是target的重复，算法逐渐退化到O(n). func searchRange(nums []int, target int) []int { ans:=[]int{-1,-1} idx:=-1 l:=0 r:=len(nums)-1 mid:=0 for l\u003c=r{ mid = (r-l)/2+l if nums[mid]==target{ idx = mid break }else if nums[mid]\u003etarget{ r = mid - 1 }else{ l = mid + 1 } } if idx!=-1{ l=idx r=idx for l\u003e=0\u0026\u0026nums[l]==target { l-- } l++ for r\u003clen(nums)\u0026\u0026nums[r]==target { r++ } r-- ans[0] = l ans[1] = r } return ans } 二分+二分 针对问题二再进行优化：二分都是找到索引最小的那个值。第一次二分找target，第二次二分找target+1的索引再-1 func searchRange(nums []int, target int) []int { leftmost := sort.SearchInts(nums, target) if leftmost == len(nums) || nums[leftmost] != target { return []int{-1, -1} } rightmost := sort.SearchInts(nums, target + 1) - 1 return []int{leftmost, rightmost} } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:64:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day64 81. 搜索旋转排序数组 II 题目 已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。 在传递给函数之前，nums 在预先未知的某个下标 k（0 \u003c= k \u003c nums.length）上进行了 旋转 ，使数组变为 [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,4,4,5,6,6,7] 在下标 5 处经旋转后可能变为 [4,5,6,6,7,0,1,2,4,4] 。 给你 旋转后 的数组 nums 和一个整数 target ，请你编写一个函数来判断给定的目标值是否存在于数组中。如果 nums 中存在这个目标值 target ，则返回 true ，否则返回 false 。 你必须尽可能减少整个操作步骤。 示例 1： 输入：nums = [2,5,6,0,0,1,2], target = 0 输出：true 示例 2： 输入：nums = [2,5,6,0,0,1,2], target = 3 输出：false 提示： 1 \u003c= nums.length \u003c= 5000 -104 \u003c= nums[i] \u003c= 104 题目数据保证 nums 在预先未知的某个下标上进行了旋转 -104 \u003c= target \u003c= 104 进阶： 这是 搜索旋转排序数组 的延伸题目，本题中的 nums 可能包含重复元素。 这会影响到程序的时间复杂度吗？会有怎样的影响，为什么？ 解法 https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/solution/sou-suo-xuan-zhuan-pai-xu-shu-zu-ii-by-l-0nmp/ ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:65:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day65 153. 寻找旋转排序数组中的最小值 题目 已知一个长度为 n 的数组，预先按照升序排列，经由 1 到 n 次 旋转 后，得到输入数组。例如，原数组 nums = [0,1,2,4,5,6,7] 在变化后可能得到： 若旋转 4 次，则可以得到 [4,5,6,7,0,1,2] 若旋转 7 次，则可以得到 [0,1,2,4,5,6,7] 注意，数组 [a[0], a[1], a[2], ..., a[n-1]] 旋转一次 的结果为数组 [a[n-1], a[0], a[1], a[2], ..., a[n-2]] 。 给你一个元素值 互不相同 的数组 nums ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 最小元素 。 你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。 示例 1： 输入：nums = [3,4,5,1,2] 输出：1 解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。 示例 2： 输入：nums = [4,5,6,7,0,1,2] 输出：0 解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。 示例 3： 输入：nums = [11,13,15,17] 输出：11 解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。 提示： n == nums.length 1 \u003c= n \u003c= 5000 -5000 \u003c= nums[i] \u003c= 5000 nums 中的所有整数 互不相同 nums 原来是一个升序排序的数组，并进行了 1 至 n 次旋转 解法 Leecode官方题解 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:66:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day66 11. 盛最多水的容器 题目 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。 返回容器可以储存的最大水量。 **说明：**你不能倾斜容器。 示例 1： 输入：[1,8,6,2,5,4,8,3,7] 输出：49 解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例 2： 输入：height = [1,1] 输出：1 提示： n == height.length 2 \u003c= n \u003c= 105 0 \u003c= height[i] \u003c= 104 解法 双指针解法 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:67:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day67 45. 跳跃游戏 II 题目 给你一个非负整数数组 nums ，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 假设你总是可以到达数组的最后一个位置。 示例 1: 输入: nums = [2,3,1,1,4] 输出: 2 解释: 跳到最后一个位置的最小跳跃数是 2。 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 示例 2: 输入: nums = [2,3,0,1,4] 输出: 2 提示: 1 \u003c= nums.length \u003c= 104 0 \u003c= nums[i] \u003c= 1000 解法 两种贪心策略解决：一种是反向查找出发位置；另一种是正向查找可达到的最大位置。 Leecode官方题解 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:68:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day68 53. 最大子数组和 题目 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组 是数组中的一个连续部分。 示例 1： 输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2： 输入：nums = [1] 输出：1 示例 3： 输入：nums = [5,4,-1,7,8] 输出：23 提示： 1 \u003c= nums.length \u003c= 105 -104 \u003c= nums[i] \u003c= 104 **进阶：**如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。 解法 官方题解：贪心、动态规划、分治 贪心： public int maxSubArray(int[] nums) { int maxSum = Integer.MIN_VALUE;//最大和 int thisSum = 0;//当前和 int len = nums.length; for(int i = 0; i \u003c len; i++) { thisSum += nums[i]; if(maxSum \u003c thisSum) { maxSum = thisSum; } //如果当前和小于0则归零，因为对于后面的元素来说这些是减小的。于是归零，意即从此处算开始最大和 if(thisSum \u003c 0) { thisSum = 0; } } return maxSum; } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:69:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day69 55. 跳跃游戏 题目 给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 判断你是否能够到达最后一个下标。 示例 1： 输入：nums = [2,3,1,1,4] 输出：true 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。 示例 2： 输入：nums = [3,2,1,0,4] 输出：false 解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。 提示： 1 \u003c= nums.length \u003c= 3 * 104 0 \u003c= nums[i] \u003c= 105 解法 解法一：贪心 官方题解 解法一：反向遍历 不断地从最后一个位置开始往前找能到达当前位置的索引，然后再往前找。直到找到第一个位置可以到达为止 func canJump(nums []int) bool { if len(nums)\u003c=1{ return true } if nums[0] == 0 { return false } idx:=len(nums)-1 for i:=len(nums)-2;i\u003e=0;i--{ if i+nums[i]\u003e=idx{ // fmt.Println(idx,nums[idx]) idx = i } } return idx == 0 } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:70:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day70 56. 合并区间 题目 以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回 一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间 。 示例 1： 输入：intervals = [[1,3],[2,6],[8,10],[15,18]] 输出：[[1,6],[8,10],[15,18]] 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2： 输入：intervals = [[1,4],[4,5]] 输出：[[1,5]] 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。 提示： 1 \u003c= intervals.length \u003c= 104 intervals[i].length == 2 0 \u003c= starti \u003c= endi \u003c= 104 解法 总的来说，就是找规律 官方题解 func merge(intervals [][]int) [][]int { sort.Slice(intervals,func(i,j int) bool{ return intervals[i][0]\u003cintervals[j][0] }) merged := [][]int{{intervals[0][0],intervals[0][1]}} for i:=1;i\u003clen(intervals);i++{ if intervals[i][0]\u003emerged[len(merged)-1][1]{ merged = append(merged,intervals[i]) }else if merged[len(merged)-1][1]\u003cintervals[i][1] { merged[len(merged)-1][1] = intervals[i][1] } } return merged } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:71:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day71 121. 买卖股票的最佳时机 题目 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。 示例 1： 输入：[7,1,5,3,6,4] 输出：5 解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。 注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。 示例 2： 输入：prices = [7,6,4,3,1] 输出：0 解释：在这种情况下, 没有交易完成, 所以最大利润为 0。 提示： 1 \u003c= prices.length \u003c= 105 0 \u003c= prices[i] \u003c= 104 解法 暴力\\动态规划(记录历史最小值) 官方题解 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:72:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day72 122. 买卖股票的最佳时机 II 题目 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。 返回 你能获得的 最大 利润 。 示例 1： 输入：prices = [7,1,5,3,6,4] 输出：7 解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。 随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。 总利润为 4 + 3 = 7 。 示例 2： 输入：prices = [1,2,3,4,5] 输出：4 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。 总利润为 4 。 示例 3： 输入：prices = [7,6,4,3,1] 输出：0 解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。 题解 贪心\\动态规划 官方题解 // dp class Solution { public int maxProfit(int[] prices) { // dp[i][0]表示第i天不持有股票的最大利润，dp[i][1]表示第i天持有股票的最大利润 int[][] dp = new int[prices.length][2]; // 初始化 dp[0][0] = 0; dp[0][1] = -prices[0]; // 状态转移 for(int i=1;i\u003cprices.length;i++){ // 不持有股票的利润，应该是前一天不持有股票和持有股票但是今天要卖出的最大利润 dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]+prices[i]); // 持有股票的利润，应该是前一天不持有股票，今天买入的和前一天持有股票的最大利润 dp[i][1] = Math.max(dp[i-1][0]-prices[i],dp[i-1][1]); } return dp[prices.length-1][0]; } } // dp 优化 class Solution { public int maxProfit(int[] prices) { // 初始化 int dp0 = 0; int dp1 = -prices[0]; // 状态转移 for(int i=1;i\u003cprices.length;i++){ // 不持有股票的利润，应该是前一天不持有股票和持有股票但是今天要卖出的最大利润 dp0 = Math.max(dp0,dp1+prices[i]); // 持有股票的利润，应该是前一天不持有股票，今天买入的和前一天持有股票的最大利润 dp1 = Math.max(dp0-prices[i],dp1); } return dp0; } } 例如：7,1,2,5,4,6,4 找局部递增序列，局部递增序列最小值买入，最大值卖出 先找最小值，再找较大值，遇到小的值就结束，找下一个最小值 由于递增序列内的数字序列：5-2+2-1 = 5-1 所以，我们可以再遇到一个正的利润就可以直接把这个利润加上即可，当然，也可以找出递增区间的最值的差值就是利润 class Solution { public int maxProfit(int[] prices) { int min = Integer.MAX_VALUE;// 最小值 int w = 0;// 利润 for(int i=0;i\u003cprices.length;i++){ if(prices[i]-min\u003e0){ w += prices[i]-min; min = Integer.MAX_VALUE; // 重置 } if(min\u003eprices[i]){ min = prices[i]; } } return w; } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:73:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day73 134. 加油站 题目 在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。 给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。 示例 1: 输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2] 输出: 3 解释: 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。 因此，3 可为起始索引。 示例 2: 输入: gas = [2,3,4], cost = [3,4,3] 输出: -1 解释: 你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。 我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油 开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油 开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油 你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。 因此，无论怎样，你都不可能绕环路行驶一周。 提示: gas.length == n cost.length == n 1 \u003c= n \u003c= 105 0 \u003c= gas[i], cost[i] \u003c= 104 解法 数学证明，降低时间复杂度 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:74:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day74 135. 分发糖果 题目 n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分。 你需要按照以下要求，给这些孩子分发糖果： 每个孩子至少分配到 1 个糖果。 相邻两个孩子评分更高的孩子会获得更多的糖果。 请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目 。 示例 1： 输入：ratings = [1,0,2] 输出：5 解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。 示例 2： 输入：ratings = [1,2,2] 输出：4 解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。 第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。 提示： n == ratings.length 1 \u003c= n \u003c= 2 * 104 0 \u003c= ratings[i] \u003c= 2 * 104 解法 方法一：两次遍历 我们可以将「相邻的孩子中，评分高的孩子必须获得更多的糖果」这句话拆分为两个规则，分别处理。 左规则：当 $\\textit{ratings}[i - 1] \u003c \\textit{ratings}[i]$ 时，i 号学生的糖果数量将比 i - 1 号孩子的糖果数量多。 右规则：当 $\\textit{ratings}[i] \u003e \\textit{ratings}[i + 1]$ 时，i 号学生的糖果数量将比 i + 1 号孩子的糖果数量多。 我们遍历该数组两次，处理出每一个学生分别满足左规则或右规则时，最少需要被分得的糖果数量。每个人最终分得的糖果数量即为这两个数量的最大值。 具体地，以左规则为例：我们从左到右遍历该数组，假设当前遍历到位置 i，如果有 $\\textit{ratings}[i - 1] \u003c \\textit{ratings}[i]$ 那么 i 号学生的糖果数量将比 i - 1 号孩子的糖果数量多，我们令 $\\textit{left}[i] = \\textit{left}[i - 1] + 1$ 即可，否则我们令 $\\textit{left}[i] = 1$。 在实际代码中，我们先计算出左规则 $\\textit{left}$ 数组，在计算右规则的时候只需要用单个变量记录当前位置的右规则，同时计算答案即可。 // 形式一 class Solution { public int candy(int[] ratings) { // 每人先发一个糖果 int sum = ratings.length; // 挨个比较相邻评分的大小，分高者糖果数+1 int[] matrix = new int[ratings.length]; for(int i=1;i\u003cratings.length;i++){ if(ratings[i]\u003eratings[i-1]\u0026\u0026matrix[i]\u003c=matrix[i-1]){ matrix[i]=matrix[i-1]+1; } } // System.out.println(Arrays.toString(matrix)); for(int i=ratings.length-2;i\u003e=0;i--){ if(ratings[i]\u003eratings[i+1]\u0026\u0026matrix[i]\u003c=matrix[i+1]){ matrix[i]=matrix[i+1]+1; } } // System.out.println(Arrays.toString(matrix)); for(int i=0;i\u003cmatrix.length;i++){sum+=matrix[i];} return sum; } } // 形式二 class Solution { public int candy(int[] ratings) { int n = ratings.length; int[] left = new int[n]; for (int i = 0; i \u003c n; i++) { if (i \u003e 0 \u0026\u0026 ratings[i] \u003e ratings[i - 1]) { left[i] = left[i - 1] + 1; } else { left[i] = 1; } } int right = 0, ret = 0; for (int i = n - 1; i \u003e= 0; i--) { if (i \u003c n - 1 \u0026\u0026 ratings[i] \u003e ratings[i + 1]) { right++; } else { right = 1; } ret += Math.max(left[i], right); } return ret; } } 方法二：常数空间遍历 https://leetcode.cn/problems/candy/solution/fen-f","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:75:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day75 376. 摆动序列 题目 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。 例如， [1, 7, 4, 9, 2, 5] 是一个 摆动序列 ，因为差值 (6, -3, 5, -7, 3) 是正负交替出现的。 相反，[1, 4, 7, 2, 5] 和 [1, 7, 4, 5, 5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。 子序列 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。 给你一个整数数组 nums ，返回 nums 中作为 摆动序列 的 最长子序列的长度 。 示例 1： 输入：nums = [1,7,4,9,2,5] 输出：6 解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。 示例 2： 输入：nums = [1,17,5,10,13,15,10,5,16,8] 输出：7 解释：这个序列包含几个长度为 7 摆动序列。 其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。 示例 3： 输入：nums = [1,2,3,4,5,6,7,8,9] 输出：2 提示： 1 \u003c= nums.length \u003c= 1000 0 \u003c= nums[i] \u003c= 1000 **进阶：**你能否用 O(n) 时间复杂度完成此题? 解法 动态规划\\贪心算法 class Solution { public int wiggleMaxLength(int[] nums) { // 顺序遍历，“峰”才算上：一旦遇到非递增数据或者非递减数据，就算做最长子序列的一个元素 if(nums.length==1){ return 1; }else if(nums.length==2\u0026\u0026nums[0]!=nums[1]){ return 2; } int ans = 1; int state = 0; //表示先前的状态：0表示前面的两个数差为0，1表示差为正，-1表示差为负 // 只需计数“峰”的数量即可 for(int i=1;i\u003cnums.length;i++){ if(nums[i]\u003cnums[i-1]\u0026\u0026state==1){ ans++; state = -1; }else if(nums[i]\u003enums[i-1]\u0026\u0026state==-1){ ans++; state = 1; }else if(nums[i]\u003enums[i-1]\u0026\u0026state==0){ ans++; state = 1; }else if(nums[i]\u003cnums[i-1]\u0026\u0026state==0){ ans++; state = -1; } } return ans; } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:76:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day76 409. 最长回文串 题目 给定一个包含大写字母和小写字母的字符串 s ，返回 通过这些字母构造成的 最长的回文串 。 在构造过程中，请注意 区分大小写 。比如 \"Aa\" 不能当做一个回文字符串。 示例 1: 输入:s = \"abccccdd\" 输出:7 解释: 我们可以构造的最长的回文串是\"dccaccd\", 它的长度是 7。 示例 2: 输入:s = \"a\" 输入:1 示例 3： 输入:s = \"aaaaaccc\" 输入:7 提示: 1 \u003c= s.length \u003c= 2000 s 只由小写 和/或 大写英文字母组成 解法 解法一：数学规律 题目要求仅仅只是需要根据给出的字符序列构造出最长回文串序列，回文串的长度如果是偶数那么前一半字符序列是后一半字符序列的“镜像”；如果是奇数，那么中间会有一个字符作为分隔，左右两边是“镜像”关系。针对“镜像”字符序列，也就是说，一个字符重复n次，如果n是偶数，那么可以将这些字符一半放在左边，一半放在右边；如果是奇数，那么可以去掉一个字符，然后将一半放左边，一半放右边。如果给的字符序列里存在奇数个重复字符，都可以作为“镜像”序列的地中情况；如果都是偶数，那么只能构造第一个“镜像”字符序列。 class Solution { public int longestPalindrome(String s) { if(s.length()==1) return 1; // 先字典排序 char[] chs = s.toCharArray(); Arrays.sort(chs); // System.out.println(Arrays.toString(chs)); char pre = chs[0]; int count = 1; int[] counts = new int[chs.length]; int countIdx = 0; for(int i=1;i\u003cchs.length;i++){ if(chs[i]==pre){ count++; }else{ // 暂存 counts[countIdx] = count; countIdx++; count=1; pre = chs[i]; } } counts[countIdx]=count; // System.out.println(Arrays.toString(counts)); int Len = 1; boolean flag = false; for(int i=0;i\u003ccounts.length\u0026\u0026counts[i]!=0;i++){ if(counts[i]%2==0){ Len+=counts[i]; }else{ if(counts[i]\u003e1){ Len+=counts[i]-1; } flag=true; } } return flag?Len:Len-1; } } 解法二：官方解法 https://leetcode.cn/problems/longest-palindrome/solution/zui-chang-hui-wen-chuan-by-leetcode-solution/ ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:77:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day77 435. 无重叠区间 题目 给定一个区间的集合 intervals ，其中 intervals[i] = [starti, endi] 。返回 需要移除区间的最小数量，使剩余区间互不重叠 。 示例 1: 输入: intervals = [[1,2],[2,3],[3,4],[1,3]] 输出: 1 解释: 移除 [1,3] 后，剩下的区间没有重叠。 示例 2: 输入: intervals = [ [1,2], [1,2], [1,2] ] 输出: 2 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。 示例 3: 输入: intervals = [ [1,2], [2,3] ] 输出: 0 解释: 你不需要移除任何区间，因为它们已经是无重叠的了。 提示: 1 \u003c= intervals.length \u003c= 105 intervals[i].length == 2 -5 * 104 \u003c= starti \u003c endi \u003c= 5 * 104 解法 动态规划\\贪心 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:78:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day78 452. 用最少数量的箭引爆气球 题目 有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 points ，其中points[i] = [xstart, xend] 表示水平直径在 xstart 和 xend之间的气球。你不知道气球的确切 y 坐标。 一支弓箭可以沿着 x 轴从不同点 完全垂直 地射出。在坐标 x 处射出一支箭，若有一个气球的直径的开始和结束坐标为 x``start，x``end， 且满足 xstart ≤ x ≤ x``end，则该气球会被 引爆 。可以射出的弓箭的数量 没有限制 。 弓箭一旦被射出之后，可以无限地前进。 给你一个数组 points ，返回引爆所有气球所必须射出的 最小 弓箭数 。 示例 1： 输入：points = [[10,16],[2,8],[1,6],[7,12]] 输出：2 解释：气球可以用2支箭来爆破: -在x = 6处射出箭，击破气球[2,8]和[1,6]。 -在x = 11处发射箭，击破气球[10,16]和[7,12]。 示例 2： 输入：points = [[1,2],[3,4],[5,6],[7,8]] 输出：4 解释：每个气球需要射出一支箭，总共需要4支箭。 示例 3： 输入：points = [[1,2],[2,3],[3,4],[4,5]] 输出：2 解释：气球可以用2支箭来爆破: - 在x = 2处发射箭，击破气球[1,2]和[2,3]。 - 在x = 4处射出箭，击破气球[3,4]和[4,5]。 提示: 1 \u003c= points.length \u003c= 105 points[i].length == 2 -231 \u003c= xstart \u003c xend \u003c= 231 - 1 解法 注意给出的数据有大数，所以涉及到运算，不能直接向加减乘除等。 解法一：暴力 问题可以看成是：我们删除一些重叠的区间，之后再统计这些没有删除的区间 class Solution { public int findMinArrowShots(int[][] points) { if(points.length==1) return 1; // 按照右端点排序 Arrays.sort(points, new Comparator\u003cint[]\u003e() { public int compare(int[] point1, int[] point2) { if (point1[1] \u003e point2[1]) { return 1; } else if (point1[1] \u003c point2[1]) { return -1; } else { return 0; } } }); // 记录是否删除区间 boolean[] isDel = new boolean[points.length]; int ans = 0; // 基准区间的左右值 for(int i=0;i\u003cpoints.length;i++){ if(!isDel[i]){ int pivotLeft = points[i][0]; int pivotRight = points[i][1]; for(int j=i+1;j\u003cpoints.length;j++){ // 当前区间还在 if(!isDel[j]){ if(points[j][0]\u003epivotRight){} else{ isDel[j] = true; } } } } } for(int i=0;i\u003cisDel.length;i++){ if(!isDel[i]){ ans++; } } return ans; } } 解法二：排序+贪心 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:79:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day79 455. 分发饼干 题目 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] \u003e= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。 示例 1: 输入: g = [1,2,3], s = [1,1] 输出: 1 解释: 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。 所以你应该输出1。 示例 2: 输入: g = [1,2], s = [1,2,3] 输出: 2 解释: 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。 你拥有的饼干数量和尺寸都足以让所有孩子满足。 所以你应该输出2. 提示： 1 \u003c= g.length \u003c= 3 * 104 0 \u003c= s.length \u003c= 3 * 104 1 \u003c= g[i], s[j] \u003c= 231 - 1 解法 排序+双指针+贪心 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:80:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day80 605. 种花问题 题目 假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。 给你一个整数数组 flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则的情况下种入 n 朵花？能则返回 true ，不能则返回 false。 示例 1： 输入：flowerbed = [1,0,0,0,1], n = 1 输出：true 示例 2： 输入：flowerbed = [1,0,0,0,1], n = 2 输出：false 提示： 1 \u003c= flowerbed.length \u003c= 2 * 104 flowerbed[i] 为 0 或 1 flowerbed 中不存在相邻的两朵花 0 \u003c= n \u003c= flowerbed.length 解法 解法一：模拟 触雷首尾位置需要特殊处理，其余位置就是比较前一个和后一个是否都没种花，如果都没种花，再看当前位置是否种花，如果没，就种花，否则就需要迭代下一个花坛位置 class Solution { public boolean canPlaceFlowers(int[] flowerbed, int n) { if(flowerbed.length==1){ if(flowerbed[0]==1) return n==0; else return n\u003c=1; } for(int i=0;i\u003cflowerbed.length;i++){ // 当碰到收尾时，需要收敛比较 if(i==0){ if(flowerbed[i]!=flowerbed[i+1]){}else { if(n==0) break; flowerbed[i]=1; n--; } }else if(i==flowerbed.length-1){ if(flowerbed[i]!=flowerbed[i-1]){}else { if(n==0) break; flowerbed[i]=1; n--; } }else{ if(flowerbed[i]!=flowerbed[i-1]||flowerbed[i]!=flowerbed[i+1]){} else { if(n==0) break; flowerbed[i]=1; n--; } } } // System.out.println(Arrays.toString(flowerbed)); return n==0; } } 解法二：贪心 https://leetcode.cn/problems/can-place-flowers/solution/chong-hua-wen-ti-by-leetcode-solution-sojr/ ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:81:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day81 738. 单调递增的数字 题目 当且仅当每个相邻位数上的数字 x 和 y 满足 x \u003c= y 时，我们称这个整数是单调递增的。 给定一个整数 n ，返回 小于或等于 n 的最大数字，且数字呈 单调递增 。 示例 1: 输入: n = 10 输出: 9 示例 2: 输入: n = 1234 输出: 1234 示例 3: 输入: n = 332 输出: 299 提示: 0 \u003c= n \u003c= 109 解法 解法一：数学规律 我们只需要找到单调递增的最后一个数位上的数字，如果该数字是最后一个，那么整体都满足单调递增特性直接返回；如果不是，那么当前数位和前面的数位组成的数字减去1，再把后面的数位全部变成数字9，之后前面和后面凭借在一起返回即可 class Solution { public int monotoneIncreasingDigits(int n) { // 取位数 int Len = 0; int tmp = n; while(tmp!=0){ tmp=tmp/10; Len++; } // System.out.println(\"位数\"+Len); // 如果是一位直接返回结果 if(Len==1) return n; // 其他位数，循环处理 tmp = n; // 保证单调递增 int preMax = 0; int curMax = 0; int index = 0; while(index\u003cLen){ // 取出当前位 curMax = tmp/(int)Math.pow(10,Len-index-1)%10; // System.out.println(\"preMax=\"+preMax+\"curMax=\"+curMax); if(curMax\u003cpreMax){ // 往前回溯分割点 int i = index-1; while(i\u003e=0){ if(tmp/(int)Math.pow(10,Len-i-1)%10!=preMax){ break; } i--; } i++; // System.out.println(\"回溯次数=\"+i); // 将该位及以前的数据减去（该位数字+1），再和后面等位数的数字9拼接 // int lastCast = tmp/(int)Math.pow(10,Len-i-1); // System.out.println(\"lastCast=\"+lastCast); int front = tmp/(int)Math.pow(10,Len-i-1)-1; int back = 0; int j=Len-i-1; while(j\u003e0){ back=back*10+9; j--; } // System.out.println(\"front=\"+front+\"back=\"+back); return front*((int)Math.pow(10,Len-i-1))+back; } preMax = curMax; index++; } return n; } } 解法二：贪心 https://leetcode.cn/problems/monotone-increasing-digits/solution/dan-diao-di-zeng-de-shu-zi-by-leetcode-s-5908/ ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:82:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day82 1005. K 次取反后最大化的数组和 题目 给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组： 选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。 重复这个过程恰好 k 次。可以多次选择同一个下标 i 。 以这种方式修改数组后，返回数组 可能的最大和 。 示例 1： 输入：nums = [4,2,3], k = 1 输出：5 解释：选择下标 1 ，nums 变为 [4,-2,3] 。 示例 2： 输入：nums = [3,-1,0,2], k = 3 输出：6 解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。 示例 3： 输入：nums = [2,-3,-1,5,-4], k = 2 输出：13 解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。 提示： 1 \u003c= nums.length \u003c= 104 -100 \u003c= nums[i] \u003c= 100 1 \u003c= k \u003c= 104 解法 解法一：寻找数学规律 // 代码一 class Solution { public int largestSumAfterKNegations(int[] nums, int k) { Arrays.sort(nums); for(int i=0;i\u003cnums.length;i++){ if(k\u003c=0) break; if(nums[i]\u003c0) { nums[i]*=-1; k--; } } // 可以通过找最值，省去第二次排序懒得写了 Arrays.sort(nums); int sum = 0; // System.out.println(Arrays.toString(nums)); // 找和 for(int i=0;i\u003cnums.length;i++){ sum+=nums[i]; } return k%2==1?sum-2*nums[0]:sum; } } // 官方解法 class Solution { public int largestSumAfterKNegations(int[] nums, int k) { Map\u003cInteger, Integer\u003e freq = new HashMap\u003cInteger, Integer\u003e(); for (int num : nums) { freq.put(num, freq.getOrDefault(num, 0) + 1); } int ans = Arrays.stream(nums).sum(); for (int i = -100; i \u003c 0; ++i) { if (freq.containsKey(i)) { int ops = Math.min(k, freq.get(i)); ans += (-i) * ops * 2; freq.put(i, freq.get(i) - ops); freq.put(-i, freq.getOrDefault(-i, 0) + ops); k -= ops; if (k == 0) { break; } } } if (k \u003e 0 \u0026\u0026 k % 2 == 1 \u0026\u0026 !freq.containsKey(0)) { for (int i = 1; i \u003c= 100; ++i) { if (freq.containsKey(i)) { ans -= i * 2; break; } } } return ans; } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:83:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day83 1013. 将数组分成和相等的三个部分 题目 给你一个整数数组 arr，只有可以将其划分为三个和相等的 非空 部分时才返回 true，否则返回 false。 形式上，如果可以找出索引 i + 1 \u003c j 且满足 (arr[0] + arr[1] + ... + arr[i] == arr[i + 1] + arr[i + 2] + ... + arr[j - 1] == arr[j] + arr[j + 1] + ... + arr[arr.length - 1]) 就可以将数组三等分。 示例 1： 输入：arr = [0,2,1,-6,6,-7,9,1,2,0,1] 输出：true 解释：0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1 示例 2： 输入：arr = [0,2,1,-6,6,7,9,-1,2,0,1] 输出：false 示例 3： 输入：arr = [3,3,6,5,-2,2,5,1,-9,4] 输出：true 解释：3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4 提示： 3 \u003c= arr.length \u003c= 5 * 104 -104 \u003c= arr[i] \u003c= 104 解法 解法一：暴力法 题目要求求出是否存在三个相等的划分。显而易见，我们可以暴力。 class Solution { public boolean canThreePartsEqualSum(int[] arr) { // 先放第一个挡板 for(int i=0;i\u003carr.length-2;i++){ // 继续放第二个挡板 for(int j=i+1;j\u003carr.length-1;j++){ int firstPart = sum(0,i,arr); // System.out.println(firstPart+\"-\"+sum(i+1,j,arr)+\"-\"+sum(j+1,arr.length-1,arr)); if(firstPart==sum(i+1,j,arr)){ if(firstPart==sum(j+1,arr.length-1,arr)){ return true; } } } } return false; } public int sum(int l,int r,int[] arr){ int sum=0; for(;l\u003c=r;l++){ sum+=arr[l]; } return sum; } } 遗憾的是，暴力算法的时间复杂度为O(n^3^)。问题出现在，每次求和都需要重新计算和。可以使用前缀和的方式优化一下算法 解法二：前缀和优化 class Solution { public boolean canThreePartsEqualSum(int[] arr) { int sum = 0; for(int i=0;i\u003carr.length;i++){ sum+=arr[i]; } int firstSum = 0; int secondSum = 0; // 先放第一个挡板 for(int i=0;i\u003carr.length-2;i++){ firstSum +=arr[i]; // 继续放第二个挡板 for(int j=i+1;j\u003carr.length-1;j++){ secondSum += arr[j]; // System.out.println(firstSum+\"-\"+secondSum+\"-\"+(sum-firstSum-secondSum)); if(firstSum==secondSum){ if(firstSum==sum-firstSum-secondSum){ return true; } } } secondSum=0; } return false; } } 解法三：贪心 发现数学规律，寻找切分点 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:84:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day84 392. 判断子序列 题目 给定字符串 s 和 t ，判断 s 是否为 t 的子序列。 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，\"ace\"是\"abcde\"的一个子序列，而\"aec\"不是）。 进阶： 如果有大量输入的 S，称作 S1, S2, … , Sk 其中 k \u003e= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代码？ 致谢： 特别感谢 @pbrother 添加此问题并且创建所有测试用例。 示例 1： 输入：s = \"abc\", t = \"ahbgdc\" 输出：true 示例 2： 输入：s = \"axc\", t = \"ahbgdc\" 输出：false 提示： 0 \u003c= s.length \u003c= 100 0 \u003c= t.length \u003c= 10^4 两个字符串都只由小写字符组成。 解法 解法一：双指针 https://leetcode.cn/problems/is-subsequence/solution/pan-duan-zi-xu-lie-by-leetcode-solution/ 解法二：动态规划 https://leetcode.cn/problems/is-subsequence/solution/shi-pin-jiang-jie-dong-tai-gui-hua-qiu-jie-is-subs/ 比官方题解稍微好理解一点 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:85:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day85 62. 不同路径 题目 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。 问总共有多少条不同的路径？ 示例 1： 输入：m = 3, n = 7 输出：28 示例 2： 输入：m = 3, n = 2 输出：3 解释： 从左上角开始，总共有 3 条路径可以到达右下角。 1. 向右 -\u003e 向下 -\u003e 向下 2. 向下 -\u003e 向下 -\u003e 向右 3. 向下 -\u003e 向右 -\u003e 向下 示例 3： 输入：m = 7, n = 3 输出：28 示例 4： 输入：m = 3, n = 3 输出：6 提示： 1 \u003c= m, n \u003c= 100 题目数据保证答案小于等于 2 * 109 解法 动态规划/组合数学 class Solution { public int uniquePaths(int m, int n) { // 定义状态：dp[i][j]表示移动到i行j列位置有多少条路径 long[][] dp = new long[m][n]; // 初始状态：第一行和第一列都只有一条路径 for(int i=0;i\u003cm;i++){ dp[i][0] = 1; } for(int i=0;i\u003cn;i++){ dp[0][i] = 1; } // 状态转移方程：dp[i][j]显然是由dp[i-1][j]或dp[i][j-1]转移而来，那么结果应该取二者之和 for(int i=1;i\u003cm;i++){ for(int j=1;j\u003cn;j++){ dp[i][j] = dp[i-1][j]+dp[i][j-1]; } } return (int)dp[m-1][n-1]; } } func uniquePaths(m int, n int) int { dp := make([][]int,m) for i:=0;i\u003cm;i++{ dp[i] = make([]int,n) dp[i][0] = 1 } for j:=0;j\u003cn;j++{ dp[0][j] = 1 } // 状态转移 for i:=1;i\u003cm;i++{ for j:=1;j\u003cn;j++{ dp[i][j] = dp[i-1][j]+dp[i][j-1] } } return dp[m-1][n-1] } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:86:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day86 63. 不同路径 II 题目 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 示例 1： 输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]] 输出：2 解释：3x3 网格的正中间有一个障碍物。 从左上角到右下角一共有 2 条不同的路径： 1. 向右 -\u003e 向右 -\u003e 向下 -\u003e 向下 2. 向下 -\u003e 向下 -\u003e 向右 -\u003e 向右 示例 2： 输入：obstacleGrid = [[0,1],[0,0]] 输出：1 提示： m == obstacleGrid.length n == obstacleGrid[i].length 1 \u003c= m, n \u003c= 100 obstacleGrid[i][j] 为 0 或 1 解法 解法一：动态规划 思路和上一道题一样，都满足动态规划的几个条件 官方动态规划题解 class Solution { public int uniquePathsWithObstacles(int[][] obstacleGrid) { int rowNum = obstacleGrid.length; int spanNum = obstacleGrid[0].length; int[][] dp = new int[rowNum][spanNum]; // 初始化dp for(int i=0;i\u003crowNum;i++){ if(obstacleGrid[i][0]==1){ break; } dp[i][0] = 1; } for(int i=0;i\u003cspanNum;i++){ if(obstacleGrid[0][i]==1){ break; } dp[0][i] = 1; } // System.out.println(rowNum+\"-\"+spanNum); // 状态转移 for(int i=1;i\u003crowNum;i++){ for(int j=1;j\u003cspanNum;j++){ if(obstacleGrid[i][j]==0){ dp[i][j]=dp[i-1][j]+dp[i][j-1]; // System.out.println(dp[i][j]+\"=\"+dp[i-1][j]+\"+\"+dp[i][j-1]); } } } //最后结果 return dp[rowNum-1][spanNum-1]; } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:87:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day87 64. 最小路径和 题目 给定一个包含非负整数的 *m* x *n* 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。 **说明：**每次只能向下或者向右移动一步。 示例 1： 输入：grid = [[1,3,1],[1,5,1],[4,2,1]] 输出：7 解释：因为路径 1→3→1→1→1 的总和最小。 示例 2： 输入：grid = [[1,2,3],[4,5,6]] 输出：12 提示： m == grid.length n == grid[i].length 1 \u003c= m, n \u003c= 200 0 \u003c= grid[i][j] \u003c= 100 解法 解法一：动态规划 https://leetcode.cn/problems/minimum-path-sum/solution/zui-xiao-lu-jing-he-by-leetcode-solution/ 这题和不同的路径的状态转移方程有点类似 func minPathSum(grid [][]int) int { m:=len(grid) n:=len(grid[0]) dp := make([][]int,m) s:=0 for i:=0;i\u003cm;i++{ dp[i] = make([]int,n) dp[i][0] = s + grid[i][0] s = dp[i][0] } s=0 for j:=0;j\u003cn;j++{ dp[0][j] =s + grid[0][j] s = dp[0][j] } for i:=1;i\u003cm;i++{ for j:=1;j\u003cn;j++{ if dp[i-1][j]\u003edp[i][j-1]{ dp[i][j] = dp[i][j-1]+grid[i][j] }else{ dp[i][j] = dp[i-1][j]+grid[i][j] } } } // fmt.Println(dp) return dp[m-1][n-1] } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:88:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day88 70. 爬楼梯 题目 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 示例 1： 输入：n = 2 输出：2 解释：有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶 示例 2： 输入：n = 3 输出：3 解释：有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶 提示： 1 \u003c= n \u003c= 45 解法 官方题解：动态规划/矩阵快速幂/通项公式/ dp应该是最简单的 https://leetcode.cn/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/ class Solution { public int climbStairs(int n) { if(n\u003c=2) return n; // 状态表示：dp[i]表示爬第i层楼梯的方法总数 int[] dp = new int[n+1]; // 状态初始化 //dp[0] = 1;// 没有意义，为了凑数,也可以置为1；也可以当作非法状态看待 dp[1] = 1;// 当爬第一层时，只有一种方法：爬一个台阶 // 状态转移方程：dp[i]是由dp[i-1]或dp[i-2]转移过来，那么显然方法总数就是前两者之和; dp[2] = 2; for(int i=3;i\u003c=n;i++){ dp[i] = dp[i-1] + dp[i-2]; } return dp[n]; } } 还可以将这个问题看成是“物品的重量分别是1和2，背包的容量是n”的完全背包问题。 二维DP解法： class Solution { public int climbStairs(int n) { if(n\u003c=2) return n; // 状态表示：dp[i][j]表示取前i物品，装下容量j的方法数，注意此处要排列数 int[][] dp = new int[3][n+1]; int[] w = new int[]{1,2}; // 状态初始化：取前i个物品装容量为0，只有一种方法，那就是什么都不取 dp[0][0]=1; // 状态转移 // 二维dp的顺序无所谓 for(int i=1;i\u003c=2;i++){ for(int j=0;j\u003c=n;j++){ if(j\u003e=w[i-1]) { // 每次可以放的时候，都是取前0-i个数的和，这样才是排列数。 // 可以画出dp转移表验证一下。 //（其实这是画表时候找到的规律。感觉是一种数学定律） for(int k=0;k\u003ci;k++){ dp[i][j] += dp[i][j-w[k]]; } } else dp[i][j] = dp[i-1][j]; } } // System.out.println(Arrays.deepToString(dp)); return dp[2][n]; } } 一维dp解法，这里的一维dp不再是优化二维得来的了。 class Solution { public int climbStairs(int n) { if(n\u003c=2) return n; // 状态表示：dp[j]表示装下容量j的方法数，注意此处要排列数 int[] dp = new int[n+1]; int[] w = new int[]{1,2}; // 状态初始化：装容量为0，只有一种方法，那就是什么都不取 dp[0]=1; // 状态转移 for(int j=0;j\u003c=n;j++){ for(int i=1;i\u003c=2;i++){ if(j\u003e=w[i-1]) { dp[j] += dp[j-w[i-1]]; } } } // System.out.println(Arrays.toString(dp)); return dp[n]; } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:89:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day89 72. 编辑距离 题目 给你两个单词 word1 和 word2， 请返回将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符 删除一个字符 替换一个字符 示例 1： 输入：word1 = \"horse\", word2 = \"ros\" 输出：3 解释： horse -\u003e rorse (将 'h' 替换为 'r') rorse -\u003e rose (删除 'r') rose -\u003e ros (删除 'e') 示例 2： 输入：word1 = \"intention\", word2 = \"execution\" 输出：5 解释： intention -\u003e inention (删除 't') inention -\u003e enention (将 'i' 替换为 'e') enention -\u003e exention (将 'n' 替换为 'x') exention -\u003e exection (将 'n' 替换为 'c') exection -\u003e execution (插入 'u') 提示： 0 \u003c= word1.length, word2.length \u003c= 500 word1 和 word2 由小写英文字母组成 解法 方法一：动态规划找编辑距离 好理解的图表解法 官方题解 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:90:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day90 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:91:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"分解质因数 题目 问题描述 求出区间[a,b]中所有整数的质因数分解。 输入格式 输入两个整数a，b。 输出格式 每行输出一个数的分解，形如k=a1a2a3…(a1\u003c=a2\u003c=a3…，k也是从小到大的)(具体可看样例) 样例输入 3 10 样例输出 3=3 4=2*2 5=5 6=2*3 7=7 8=2*2*2 9=3*3 10=2*5 提示 先筛出所有素数，然后再分解。 数据规模和约定 2\u003c=a\u003c=b\u003c=10000 解法 思路：这道题的暴力解法思路显而易见：对区间内的每一个数都进行质因数分解。但是这样做显然做了很多的重复计算，我们可以利用空间换时间的原理，将第一次计算出来的结果保存好，这样第二次再计算时，直接拿出来用即可，这样就避免了大量的重复计算 代码演示 import java.util.*; public class Main{ public static void main(String args[]){ Scanner sc = new Scanner(System.in); int a = sc.nextInt(); int b = sc.nextInt(); String[] dict = new String[b+1]; dict[2] = \"2*\"; dict[3] = \"3*\"; // System.out.println(\"2=2\"); for(int i=2;i\u003c=b;i++) { int tmp = i; boolean flag = true; // 算质因数 for(int n=2;n\u003ci\u0026\u0026tmp\u003e=1;n++) { // 找到的第一个最小因子n，就是质因数。再拆分剩余因子 if(tmp%n==0) { flag = false; // 将第一个因子拼凑在tmp位置上 if(dict[n]!=null) { dict[tmp]=dict[n]; }else { dict[tmp] = n+\"*\"; } // 剩余因子的记忆化搜索，降低时间复杂度 if(dict[tmp/n]!=null) { dict[tmp]=dict[tmp]+dict[tmp/n]; break; } // 迭代剩余因子的分解，需要重新开始 tmp = tmp/n; n=2; } } // 如果i为素数，那么i就没有因子，所以需要直接初始化dict if(flag) { dict[i] = i+\"*\"; } if(i\u003e=a) { if(dict[i].length()\u003e1\u0026\u0026dict[i].charAt(dict[i].length()-1)=='*') { System.out.println(i+\"=\"+dict[i].substring(0, dict[i].length()-1)); }else System.out.println(i+\"=\"+dict[i]); } } //System.out.print(Arrays.toString(dict)); sc.close(); } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:91:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day91 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:92:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"最大分解 题目 问题描述 给出一个正整数n，求一个和最大的序列a0，a1，a2，……，ap，满足n=a0\u003ea1\u003ea2\u003e……\u003eap且ai+1是ai的约数，输出a1+a2+……+ap的最大值 输入格式 输入仅一行，包含一个正整数n 输出格式 一个正整数，表示最大的序列和，即a1+a2+……+ap的最大值 样例输入 10 样例输出 6 数据规模和约定 1\u003cn\u003c=10^6 样例说明 p=2 a0=10，a1=5，a2=1，6=5+1 解法 主要采用dfs+贪心优化 思路：这个题目本身就是不断得分解得到约数，显而易见应该使用递归编程求解；我们再思考题目：题目的意思是让我们找出约数序列和得最大值，可以验证这种贪心策略：每次都取最大约数，这样得到的结果总是当前最优，这样每一步的最优解的和自然是最终的最大值。 import java.util.Scanner; public class Main { public static void main(String[] args) { Scanner sc =new Scanner(System.in); System.out.print(dfs(sc.nextInt())); sc.close(); } // dfs+贪心优化 public static int dfs(int num) { // 判断当前数是否是素数，是的话就停止当前分支递归 if(num\u003c=3) return 1; boolean flag = false; for(int i=2;i\u003cnum;i++) { if(num%i==0) { flag =true; // 找到第一个约数i，也就是最小得那个约数i;就去递归最大得那个约数 // System.out.println(num+\"|\"+num/i+\"|\"+i); return dfs(num/i)+num/i; } } // 素数 if(!flag) { return 1; } return 1; } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:92:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day92 46. 全排列 题目 给定一个不含重复数字的数组 nums ，返回其 所有可能的全排列 。你可以 按任意顺序 返回答案。 示例 1： 输入：nums = [1,2,3] 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] 示例 2： 输入：nums = [0,1] 输出：[[0,1],[1,0]] 示例 3： 输入：nums = [1] 输出：[[1]] 提示： 1 \u003c= nums.length \u003c= 6 -10 \u003c= nums[i] \u003c= 10 nums 中的所有整数 互不相同 解法 解法一：dfs+回溯 这个问题可以看作有 n 个排列成一行的空格，我们需要从左往右依此填入题目给定的 n 个数，每个数只能使用一次。那么很直接的可以想到一种穷举的算法，即从左往右每一个位置都依此尝试填入一个数，看能不能填完这 n 个空格，在程序中我们可以用「回溯法」来模拟这个过程。 DFS+回溯 解法二：dfs+回溯+哈希去重 全排列可以从【组合数】里筛选出来，利用哈希表去重。同时，需要注意深度拷贝的问题 class Solution { HashSet\u003cInteger\u003e hm; public Solution(){ hm = new HashSet\u003c\u003e(); } public List\u003cList\u003cInteger\u003e\u003e permute(int[] nums) { List\u003cList\u003cInteger\u003e\u003e lls = new ArrayList\u003c\u003e(); dfs(lls,new ArrayList\u003c\u003e(),nums,nums.length,0); return lls; } public void dfs(List\u003cList\u003cInteger\u003e\u003e lls,List\u003cInteger\u003e ls,int[] nums,int len,int step){ if(step==len){ // 核心关键: ls是引用类型,所以此处要深拷贝出来 lls.add(new ArrayList\u003c\u003e(ls)); return; } for(int i=0;i\u003clen;i++){ if (hm.contains(nums[i])){ continue; } ls.add(nums[i]); hm.add(nums[i]); dfs(lls,ls,nums,len,step+1); hm.remove(nums[i]); ls.remove(ls.size()-1); } } } // 全排列不去重 func permute(nums []int) [][]int { ans := [][]int{} used := make([]bool,len(nums)) var dfs func(nums []int,item []int,step int) dfs = func(nums []int,item []int,step int){ if step==len(nums){ newItem:=make([]int,len(item)) copy(newItem,item) ans = append(ans,newItem) return } for i:=0;i\u003clen(nums);i++{ if used[i] { continue } item = append(item,nums[i]) used[i] = true dfs(nums,item,step+1) used[i] = false item = item[:len(item)-1] } } dfs(nums,[]int{},0) return ans } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:93:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day93 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:94:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"马虎的算式 题目 小明是个急性子，上小学的时候经常把老师写在黑板上的题目抄错了。有一次，老师出的题目是：36 x 495 = ? 他却给抄成了：396 x 45 = ?但结果却很戏剧性，他的答案竟然是对的！！因为 36 * 495 = 396 * 45 = 17820 类似这样的巧合情况可能还有很多，比如：27 * 594 = 297 * 54 假设 a b c d e 代表1~9不同的5个数字（注意是各不相同的数字，且不含0）能满足形如： ab * cde = adb * ce 这样的算式一共有多少种呢？请你利用计算机的优势寻找所有的可能，并回答不同算式的种类数。满足乘法交换律的算式计为不同的种类，所以答案肯定是个偶数。 解法 解法一：暴力枚举 题目的意思就是在1~9里找到五个不同的数字组合，满足题目的要求。直接五个for循环嵌套解决 public class Main { public static void main(String[] args){ int a,b,c,d,e; int count=0;//记录满足条件的个数 for(a=1;a\u003c=9;a++) for(b=1;b\u003c=9;b++) for(c=1;c\u003c=9;c++) for(d=1;d\u003c=9;d++) for(e=1;e\u003c=9;e++){//abcde代表1-9各不同的5个数字 if(a!=b\u0026\u0026a!=c\u0026\u0026a!=d\u0026\u0026a!=e\u0026\u0026b!=c\u0026\u0026b!=d\u0026\u0026b!=e \u0026\u0026c!=d\u0026\u0026c!=e\u0026\u0026d!=e){ int sum1=(a*10+b)*(c*100+d*10+e); int sum2=(a*100+d*10+b)*(c*10+e); if(sum1==sum2) { count++; } } } System.out.println(count); } } 解法二：优雅的DFS+回溯 我们可以通过dfs搜索解决。 import java.util.Arrays; public class Main { static int[] nums = {1,2,3,4,5,6,7,8,9}; static boolean[] vs = new boolean[9]; static int count = 0; public static void main(String[] args) { dfs(new int[5],0); System.out.print(count); } // DFS枚举: 找出五个数的所有组合 public static void dfs(int[] zuhe,int step) { if(step\u003e4) { // 处理五个数 int a = zuhe[0]*10+zuhe[1]; int b = zuhe[2]*100+zuhe[3]*10+zuhe[4]; int c = zuhe[0]*100+zuhe[3]*10+zuhe[1]; int d = zuhe[2]*10+zuhe[4]; if(a*b==c*d) { // System.out.println(Arrays.toString(zuhe)); count++; } return; } for(int i=0;i\u003cnums.length;i++) { // 取出没有被拿的数，保证每位数字都不一样 if(!vs[i]) { vs[i]=true; zuhe[step]=nums[i]; dfs(zuhe,step+1); vs[i]=false;// 回溯 zuhe[step]=0; // 回溯 } } } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:94:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day94 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:95:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"振兴中华 题目 小明参加了学校的趣味运动会，其中的一个项目是：跳格子。地上画着一些格子，每个格子里写一个字，如下所示：（也可参见p1.jpg） 从我做起振 我做起振兴 做起振兴中 起振兴中华 比赛时，先站在左上角的写着“从”字的格子里，可以横向或纵向跳到相邻的格子里，但不能跳到对角的格子或其它位置。一直要跳到“华”字结束。 要求跳过的路线刚好构成“从我做起振兴中华”这句话。 请你帮助小明算一算他一共有多少种可能的跳跃路线呢？ 解法 解法一：DFS 思路：只要每次都是往右或往左走，就一定满足题目要求。所以，就是求这样走的路径有多少。显然，可以通过DFS直接模拟这个过程。 public class Main { static String[][] matrix = { {\"从\",\"我\",\"做,\",\"起\",\"振\"}, {\"我\",\"做,\",\"起\",\"振\",\"兴\"}, {\"做,\",\"起\",\"振\",\"兴\",\"中\"}, {\"起\",\"振\",\"兴\",\"中\",\"华\"} }; public static void main(String[] args) { System.out.print(dfs(0,0)); } public static int dfs(int i,int j) { if(i==3||j==4) { return 1; } // 下一步走,且回溯前面往下走的步数，换一种往右走 return dfs(i+1,j)+dfs(i,j+1); } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:95:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day95 123. 买卖股票的最佳时机 III 题目 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。 **注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入：prices = [3,3,5,0,0,3,1,4] 输出：6 解释：在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。 随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。 示例 2： 输入：prices = [1,2,3,4,5] 输出：4 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。 因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3： 输入：prices = [7,6,4,3,1] 输出：0 解释：在这个情况下, 没有交易完成, 所以最大利润为 0。 示例 4： 输入：prices = [1] 输出：0 提示： 1 \u003c= prices.length \u003c= 105 0 \u003c= prices[i] \u003c= 105 解法 动态规划 class Solution { public int maxProfit(int[] prices) { // 状态定义：dp[i][0]表示没有操作 // dp[i][1]表示前i天第一次持有股票的最大利润 // dp[i][2]表示前i天第一次卖出股票的最大利润 // dp[i][3]表示前i天第二次持有股票的最大利润 // dp[i][4]表示前i天第二次卖出股票的最大利润 int[][] dp = new int[prices.length+1][5]; // 初始化 dp[0][0] = 0; dp[0][2] =0; dp[0][1] = -prices[0]; dp[0][3] = -prices[0]; for(int i=1;i\u003c=prices.length;i++){ dp[i][1] = Math.max(dp[i-1][0]-prices[i-1],dp[i-1][1]); dp[i][2] = Math.max(dp[i-1][1]+prices[i-1],dp[i-1][2]); dp[i][3] = Math.max(dp[i-1][2]-prices[i-1],dp[i-1][3]); dp[i][4] = Math.max(dp[i-1][3]+prices[i-1],dp[i-1][4]); } return dp[prices.length][4]; } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:96:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day96 152. 乘积最大子数组 题目 给你一个整数数组 nums ，请你找出数组中乘积最大的非空连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 测试用例的答案是一个 32-位 整数。 子数组 是数组的连续子序列。 示例 1: 输入: nums = [2,3,-2,4] 输出: 6 解释: 子数组 [2,3] 有最大乘积 6。 示例 2: 输入: nums = [-2,0,-1] 输出: 0 解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 提示: 1 \u003c= nums.length \u003c= 2 * 104 -10 \u003c= nums[i] \u003c= 10 nums 的任何前缀或后缀的乘积都 保证 是一个 32-位 整数 解法 方法一：数学规律 依题意不难看出：我们可以顺序连乘，直到遇到0时，我们需要重新连乘。每次连乘都要找到最大的乘积。我们需要正向和反向两个操作才能把所有组合全部遍历一遍。 class Solution { public int maxProduct(int[] nums) { int ans = 1; int max = Integer.MIN_VALUE; if(nums.length==1) return nums[0]; // 正向求最大 for(int i=0;i\u003cnums.length;i++){ if(nums[i]==0){ ans=1; continue; } ans*=nums[i]; if(ans\u003emax){ max = ans; } } // 反向求最大 ans = 1; for(int i=nums.length-1;i\u003e=0;i--){ if(nums[i]==0){ ans=1; continue; } ans*=nums[i]; if(ans\u003emax){ max = ans; } } return max\u003e0?max:0; } } 方法二：动态规划 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:97:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day97 416. 分割等和子集 题目 给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。 示例 1： 输入：nums = [1,5,11,5] 输出：true 解释：数组可以分割成 [1, 5, 5] 和 [11] 。 示例 2： 输入：nums = [1,2,3,5] 输出：false 解释：数组不能分割成两个元素和相等的子集。 提示： 1 \u003c= nums.length \u003c= 200 1 \u003c= nums[i] \u003c= 100 解法 每个元素只可以被选择1次，就是01背包问题 背包容量为sum/2，也就是在nums里挑选出刚好装满背包可能性 01背包的应用 二维DP class Solution { public boolean canPartition(int[] nums) { if(nums.length\u003c=1) return false; int sum = 0; for(int v:nums) sum+=v; if(sum%2!=0) return false; int bag = sum/2;// 背包容量 // 定义状态：dp[i][j]表示放入前i个物品时，是否可以凑出容量j boolean[][] dp = new boolean[nums.length+1][bag+1]; // 初始化 dp[0][0] = true; for(int i=1;i\u003c=nums.length;i++){ for(int j=0;j\u003c=bag;j++){ if(j\u003e=nums[i-1]) dp[i][j] = dp[i-1][j]||dp[i-1][j-nums[i-1]]; else dp[i][j] = dp[i-1][j]; } } return dp[nums.length][bag]; } } 滚动数组优化二维DP class Solution { public boolean canPartition(int[] nums) { if(nums.length\u003c=1) return false; int sum = 0; for(int v:nums) sum+=v; if(sum%2!=0) return false; int bag = sum/2;// 背包容量 // 定义状态：dp[j]表示是否可以凑出容量j boolean[] dp = new boolean[bag+1]; // 初始化 dp[0] = true; // 注意一维dp为了避免状态转移过程中状态的覆盖。需要先遍历物品再遍历背包； // 而且由于物品只放入一次，所以背包需要倒序遍历，否则就会放入多次物品，那这就不是01背包了，而是完全背包 for(int i=1;i\u003c=nums.length;i++){ for(int j=bag;j\u003e=0;j--){ if(j\u003e=nums[i-1]) dp[j] = dp[j]||dp[j-nums[i-1]]; } } return dp[bag]; } } 背包倒序遍历的解释： 需要倒序遍历背包容量。如果是顺序放入，那么根据dp转移方程： 第j个状态可能是由前面的第j-w[i]个状态转移过来。 如果顺序遍历，那么就会先算出前面的值，算出前面的值过后，后面dp转移的时候又可能会用到， 那么也就是说，一个物品被放入了多次。这就不是01背包问题了，而是完全背包 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:98:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day98 474. 一和零 题目 给你一个二进制字符串数组 strs 和两个整数 m 和 n 。 请你找出并返回 strs 的最大子集的长度，该子集中 最多 有 m 个 0 和 n 个 1 。 如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集 。 示例 1： 输入：strs = [\"10\", \"0001\", \"111001\", \"1\", \"0\"], m = 5, n = 3 输出：4 解释：最多有 5 个 0 和 3 个 1 的最大子集是 {\"10\",\"0001\",\"1\",\"0\"} ，因此答案是 4 。 其他满足题意但较小的子集包括 {\"0001\",\"1\"} 和 {\"10\",\"1\",\"0\"} 。{\"111001\"} 不满足题意，因为它含 4 个 1 ，大于 n 的值 3 。 示例 2： 输入：strs = [\"10\", \"0\", \"1\"], m = 1, n = 1 输出：2 解释：最大的子集是 {\"0\", \"1\"} ，所以答案是 2 。 提示： 1 \u003c= strs.length \u003c= 600 1 \u003c= strs[i].length \u003c= 100 strs[i] 仅由 '0' 和 '1' 组成 1 \u003c= m, n \u003c= 100 解法 解法一：01背包的变种 https://leetcode.cn/problems/ones-and-zeroes/solution/yi-he-ling-by-leetcode-solution-u2z2/ 二维DP class Solution { public int findMaxForm(String[] strs, int m, int n) { // 统计1的个数 int[] ones = new int[strs.length]; int count = 0; for(int i=0;i\u003cstrs.length;i++){ for(int j=0;j\u003cstrs[i].length();j++){ if(strs[i].charAt(j)=='1') count++; } ones[i] = count; count = 0; } // 定义dp: 表示选择的字符串个数 int[][][] dp = new int[strs.length+1][m+1][n+1]; // 初始化状态：当i==0时，表示取零个串，当然dp[0][][] = 0 // 状态转移: 完全就是01背包问题，只不过背包的维度增加了。 for(int i=1;i\u003c=strs.length;i++){ for(int j=m;j\u003e=0;j--){ for(int k=n;k\u003e=0;k--){ int a = strs[i-1].length()-ones[i-1]; int b = ones[i-1]; if(j\u003e=a\u0026\u0026k\u003e=b){ dp[i][j][k] = Math.max(dp[i-1][j][k],dp[i-1][j-a][k-b]+1); }else{ dp[i][j][k] = dp[i-1][j][k]; } } } } return dp[strs.length][m][n]; } } 滚动数组优化为一维DP class Solution { public int findMaxForm(String[] strs, int m, int n) { // 统计1的个数 int[] ones = new int[strs.length]; int count = 0; for(int i=0;i\u003cstrs.length;i++){ for(int j=0;j\u003cstrs[i].length();j++){ if(strs[i].charAt(j)=='1') count++; } ones[i] = count; count = 0; } // 定义dp: 表示选择的字符串个数 int[][] dp = new int[m+1][n+1]; // 初始化状态：为0 // 状态转移 for(int i=1;i\u003c=strs.length;i++){ for(int j=m;j\u003e=0;j--){// 倒序 for(int k=n;k\u003e=0;k--){// 倒序 int a = strs[i-1].length()-ones[i-1]; int b = ones[i-1]; if(j\u003e=a\u0026\u0026k\u003e=b){ dp[j][k] = Math.max(dp[j][k],dp[j-a][k-b]+1); } } } } return dp[m][n]; } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:99:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day99 494. 目标和 题目 给你一个整数数组 nums 和一个整数 target 。 向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式 ： 例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 \"+2-1\" 。 返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。 示例 1： 输入：nums = [1,1,1,1,1], target = 3 输出：5 解释：一共有 5 种方法让最终目标和为 3 。 -1 + 1 + 1 + 1 + 1 = 3 +1 - 1 + 1 + 1 + 1 = 3 +1 + 1 - 1 + 1 + 1 = 3 +1 + 1 + 1 - 1 + 1 = 3 +1 + 1 + 1 + 1 - 1 = 3 示例 2： 输入：nums = [1], target = 1 输出：1 提示： 1 \u003c= nums.length \u003c= 20 0 \u003c= nums[i] \u003c= 1000 0 \u003c= sum(nums[i]) \u003c= 1000 -1000 \u003c= target \u003c= 1000 解法 方法一：DFS 暴力DFS搜索所有解空间即可 class Solution { public int findTargetSumWays(int[] nums, int target) { return dfs(nums,target,0,0); } public int dfs(int[] nums, int target,int i,int next){ if(i==nums.length){ if(next==target) return 1; return 0; } return dfs(nums,target,i+1,next+nums[i])+dfs(nums,target,i+1,next-nums[i]); } } 方法二：DP https://leetcode.cn/problems/target-sum/solution/mu-biao-he-by-leetcode-solution-o0cp/ 将nums分成两堆数字（s1,s2），使得这两堆数字的差值等于target s1-s2=target s1+s2=sum 2*s1 = sum+target s1 = (sum+target)/2 s2 = (sum-target)/2 也就是说需要分出一堆数字为和为s1或s2的堆 将问题转化为为了背包问题 这里的话还是选择填充容量为s2的背包 因为选择s1的背包的话，如果要求的target为负数的话，数组的索引初始化会溢出 二维DP class Solution { public int findTargetSumWays(int[] nums, int target) { if(nums.length\u003c=1) return nums[0]==Math.abs(target)?1:0; int sum = 0; for(int v:nums) sum+=v; if((sum-target)%2!=0||target\u003esum) return 0; int bag = Math.abs((sum-target))/2; // 状态表示：dp[i][j]表示取第i个数后j容量背包的方法总数 int[][] dp = new int[nums.length+1][bag+1]; // 初始化 dp[0][0] = 1; // 状态转移 for(int i=1;i\u003c=nums.length;i++){ for(int j=0;j\u003c=bag;j++){ if(j\u003e=nums[i-1]){ dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i-1]]; }else if(j\u003cnums[i-1]){ // 放不下，方法数不变 dp[i][j] = dp[i-1][j]; } } } return dp[nums.length][bag]; } } 滚动数组优化为一维DP class Solution { public int findTargetSumWays(int[] nums, int target) { if(nums.length\u003c=1) return nums[0]==Math.abs(target)?1:0; int sum = 0; for(int v:nums) sum+=v; if((sum-target)%2!=0||target\u003esum) return 0; int bag = Math.abs((sum-target))/2; // 状态表示：","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:100:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day100 1049. 最后一块石头的重量 II 题目 有一堆石头，用整数数组 stones 表示。其中 stones[i] 表示第 i 块石头的重量。 每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x \u003c= y。那么粉碎的可能结果如下： 如果 x == y，那么两块石头都会被完全粉碎； 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。 最后，最多只会剩下一块 石头。返回此石头 最小的可能重量 。如果没有石头剩下，就返回 0。 示例 1： 输入：stones = [2,7,4,1,8,1] 输出：1 解释： 组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]， 组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]， 组合 2 和 1，得到 1，所以数组转化为 [1,1,1]， 组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。 示例 2： 输入：stones = [31,26,33,21,40] 输出：5 提示： 1 \u003c= stones.length \u003c= 30 1 \u003c= stones[i] \u003c= 100 解法 方法一：动态规划 https://leetcode.cn/problems/last-stone-weight-ii/solution/zui-hou-yi-kuai-shi-tou-de-zhong-liang-i-95p9/ 二维DP class Solution { public int lastStoneWeightII(int[] stones) { if(stones.length\u003c=1) return stones[0]; int sum = 0; for(int v:stones) sum+=v; int bag = sum/2;// 直接向下取整 // 状态表示：dp[i][j]表示选取前i个石头，容量为j时，能放入的最大重量 int[][] dp = new int[stones.length][bag+1]; // 初始化 //dp[i][0] = 0; // dp[0][j] = stones[0]; 初始化i=0时的情况，装得下就可以取第0个石头 for(int j=0;j\u003c=bag;j++){ if(j\u003e=stones[0]){ dp[0][j] = stones[0]; } } for(int i=1;i\u003cstones.length;i++){ for(int j=1;j\u003c=bag;j++){ if(j\u003e=stones[i]) dp[i][j] = Math.max(dp[i-1][j],dp[i-1][j-stones[i]]+stones[i]); else dp[i][j] = dp[i-1][j]; } } // System.out.println(Arrays.deepToString(dp)); return sum-2*dp[stones.length-1][bag]; } } // 将石头分成总重量最接近的两堆，这样碰撞后可以得到最小的堆 // 也就是要在一堆石头里找到可以最接近sum的half堆 滚动数组优化的DP class Solution { public int lastStoneWeightII(int[] stones) { if(stones.length\u003c=1) return stones[0]; int sum = 0; for(int v:stones) sum+=v; int bag = sum/2;// 直接向下取整 // 状态表示：dp[j]表示选取容量为j时，能放入的最大重量 int[] dp = new int[bag+1]; // 初始化 dp[0] = 0; // 初始化从0开始，因为第一行还没被填写 for(int i=0;i\u003cstones.length;i++){ for(int j=bag;j\u003e=stones[i];j--){// 倒序 if(j\u003e=stones[i]) dp[j] = Math.max(dp[j],dp[j-stones[i]]+stones[i]); } } // System.out.println(Arrays.deepToString(dp)); return sum-2*dp[bag]; } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:101:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day101 139. 单词拆分 题目 给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。 **注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。 示例 1： 输入: s = \"leetcode\", wordDict = [\"leet\", \"code\"] 输出: true 解释: 返回 true 因为 \"leetcode\" 可以由 \"leet\" 和 \"code\" 拼接成。 示例 2： 输入: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"] 输出: true 解释: 返回 true 因为 \"applepenapple\" 可以由 \"apple\" \"pen\" \"apple\" 拼接成。 注意，你可以重复使用字典中的单词。 示例 3： 输入: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"] 输出: false 提示： 1 \u003c= s.length \u003c= 300 1 \u003c= wordDict.length \u003c= 1000 1 \u003c= wordDict[i].length \u003c= 20 s 和 wordDict[i] 仅有小写英文字母组成 wordDict 中的所有字符串 互不相同 解法 解法一：DP https://leetcode.cn/problems/word-break/solution/dan-ci-chai-fen-by-leetcode-solution/ ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:102:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day102 279. 完全平方数 题目 给你一个整数 n ，返回 和为 n 的完全平方数的最少数量 。 完全平方数 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，1、4、9 和 16 都是完全平方数，而 3 和 11 不是。 示例 1： 输入：n = 12 输出：3 解释：12 = 4 + 4 + 4 示例 2： 输入：n = 13 输出：2 解释：13 = 4 + 9 提示： 1 \u003c= n \u003c= 104 解法 解法一：DP https://leetcode.cn/problems/perfect-squares/solution/wan-quan-ping-fang-shu-by-leetcode-solut-t99c/ class Solution { public int numSquares(int n) { // dp[i][j]表示选取前i个完全平方数，和为j时的所选完全平方数最少数量 int num = 1; for(;num\u003cn;num++){ if(num*num\u003e=n) break; } int[][] dp = new int[num+1][n+1]; // 初始化：毫无疑问，求得最小值，为了避免初始状态的覆盖，需要初始化为n+1，因为最多的情况就是n个1 for(int[] one:dp) Arrays.fill(one,n+1); // 开始 dp[0][0] = 0; for(int i=1;i\u003c=num;i++){ for(int j=0;j\u003c=n;j++){ if(j\u003e=i*i) dp[i][j] = Math.min(dp[i-1][j],dp[i][j-i*i]+1); else dp[i][j] = dp[i-1][j]; } } // System.out.println(Arrays.deepToString(dp)); return dp[num][n]; } } 优化DP class Solution { public int numSquares(int n) { // dp[j]表示所选完全平方数和为j时的最少数量 int num = 1; for(;num\u003cn;num++){ if(num*num\u003e=n) break; } int[] dp = new int[n+1]; // 初始化：毫无疑问，求得最小值，为了避免初始状态的覆盖，需要初始化为n+1，因为最多的情况就是n个1 Arrays.fill(dp,n+1); // 开始 dp[0] = 0; for(int i=1;i\u003c=num;i++){ for(int j=0;j\u003c=n;j++){ if(j\u003e=i*i) dp[j] = Math.min(dp[j],dp[j-i*i]+1); } } // System.out.println(Arrays.toString(dp)); return dp[n]; } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:103:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day103 322. 零钱兑换 题目 给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。 计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。 你可以认为每种硬币的数量是无限的。 示例 1： 输入：coins = [1, 2, 5], amount = 11 输出：3 解释：11 = 5 + 5 + 1 示例 2： 输入：coins = [2], amount = 3 输出：-1 示例 3： 输入：coins = [1], amount = 0 输出：0 提示： 1 \u003c= coins.length \u003c= 12 1 \u003c= coins[i] \u003c= 231 - 1 0 \u003c= amount \u003c= 104 解法 方法一：记忆化搜索 方法二：DP https://leetcode.cn/problems/coin-change/solution/322-ling-qian-dui-huan-by-leetcode-solution/ class Solution { public int coinChange(int[] coins, int amount) { // 状态定义：dp[i][j]表示取前i种面额的硬币，容量为j，所需的最少硬币个数 int[][] dp = new int[coins.length + 1][amount + 1]; // 初始状态：因为状态方程是求最小值，所以这里需要初始化一个较大的数即可 // 不然结果全为0.当然初始化也有讲究，不能初始化一个特别大的数如Integer.MAX_VALUE， // 太大的数在状态转移过程中会溢出。我们知道硬币的面值最小是1，那么最多的硬币数量就是面值，所以初始化为面值+1 for (int[] ints : dp) { Arrays.fill(ints,amount+1); } // 注意因为状态转移取得是最小值，所以这里状态初始化，需要初始化为大于amount的数字才行。不然小了。就直接取那个小的数了。显然不正确，因为会被覆盖了 dp[0][0]=0; // 状态转移：如果当前硬币面额可以取出，既可以取也可以不取，取两种方式的最优解 for (int i = 1; i \u003c= coins.length; i++) { for (int j = 0; j \u003c= amount; j++) { if (coins[i - 1] \u003c= j) dp[i][j] = Math.min(dp[i][j - coins[i - 1]] + 1, dp[i - 1][j]); else dp[i][j] = dp[i - 1][j]; } } // System.out.println(Arrays.deepToString(dp)); return dp[coins.length][amount]\u003eamount?-1:dp[coins.length][amount]; } } 优化DP class Solution { public int coinChange(int[] coins, int amount) { // dp[j]表示凑出金额j的最少硬币个数 int[] dp = new int[amount+1]; // 初始化 Arrays.fill(dp,amount+1); dp[0]=0; // 状态转移 for(int i=1;i\u003c=coins.length;i++){ for(int j=0;j\u003c=amount;j++){ if(j\u003e=coins[i-1]) dp[j] = Math.min(dp[j],dp[j-coins[i-1]]+1); } } // System.out.println(Arrays.deepToString(dp)); return dp[amount]\u003eamount?-1:dp[amount]; } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:104:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day104 377. 组合总和 Ⅳ 题目 给你一个由 不同 整数组成的数组 nums ，和一个目标整数 target 。请你从 nums 中找出并返回总和为 target 的元素组合的个数。 题目数据保证答案符合 32 位整数范围。 示例 1： 输入：nums = [1,2,3], target = 4 输出：7 解释： 所有可能的组合为： (1, 1, 1, 1) (1, 1, 2) (1, 2, 1) (1, 3) (2, 1, 1) (2, 2) (3, 1) 请注意，顺序不同的序列被视作不同的组合。 示例 2： 输入：nums = [9], target = 3 输出：0 提示： 1 \u003c= nums.length \u003c= 200 1 \u003c= nums[i] \u003c= 1000 nums 中的所有元素 互不相同 1 \u003c= target \u003c= 1000 **进阶：**如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？ 解法 方法一：记忆化搜索 方法二：DP https://leetcode.cn/problems/combination-sum-iv/solution/zu-he-zong-he-iv-by-leetcode-solution-q8zv/ ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:105:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day105 509. 斐波那契数 斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是： F(0) = 0，F(1) = 1 F(n) = F(n - 1) + F(n - 2)，其中 n \u003e 1 给定 n ，请计算 F(n) 。 示例 1： 输入：n = 2 输出：1 解释：F(2) = F(1) + F(0) = 1 + 0 = 1 示例 2： 输入：n = 3 输出：2 解释：F(3) = F(2) + F(1) = 1 + 1 = 2 示例 3： 输入：n = 4 输出：3 解释：F(4) = F(3) + F(2) = 2 + 1 = 3 提示： 0 \u003c= n \u003c= 30 解法 方法一：DFS暴搜 斐波那契数的定义很符合递归函数，因此比较容易写出递归函数写法 class Solution { public int fib(int n) { if(n\u003c=1) return n; return fib(n-1)+fib(n-2); } } 方法二：DFS+记忆化搜索 方法一还可以改进一下。我们很容易知道：斐波那契数是不断往两个分支递归，这样会出现一些数字的重复计算。我们可以在递归的过程中将这些数据记录下来，下次要用时，直接拿出来用即可，避免多余的递归。 class Solution { public int fib(int n) { int[] history = new int[n]; return dfs(n,history,0); } public int dfs(int n,int[] history,int i){ if(n\u003c=1) return n; // 有记录，则直接拿 if(history[i]!=0) return history[i]; // 没有记录，需要计算 else { history[i] = fib(n-1)+fib(n-2); return history[i]; } } } 方法三：DP 这道题也容易想到动态规划的解法，因为题目的定义看着就很动态规划，状态转移方程已经很显然地给出了。 class Solution { public int fib(int n) { if(n\u003c=1) return n; // 状态表示：dp[i]表示第i个斐波那契数 int[] dp = new int[n+1]; // 初始化dp dp[0] = 0; dp[1] = 1; for(int i=2;i\u003c=n;i++){ dp[i] = dp[i-1] + dp[i-2]; } return dp[n]; } } // 由于当前状态只与前两个状态有关，所以可以利用滚动数组地思想优化为常数空间复杂度 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:106:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day106 746. 使用最小花费爬楼梯 题目 给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。 你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。 请你计算并返回达到楼梯顶部的最低花费。 示例 1： 输入：cost = [10,15,20] 输出：15 解释：你将从下标为 1 的台阶开始。 - 支付 15 ，向上爬两个台阶，到达楼梯顶部。 总花费为 15 。 示例 2： 输入：cost = [1,100,1,1,1,100,1,1,100,1] 输出：6 解释：你将从下标为 0 的台阶开始。 - 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。 - 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。 - 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。 - 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。 - 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。 - 支付 1 ，向上爬一个台阶，到达楼梯顶部。 总花费为 6 。 提示： 2 \u003c= cost.length \u003c= 1000 0 \u003c= cost[i] \u003c= 999 解法 方法一：DP https://leetcode.cn/problems/min-cost-climbing-stairs/solution/shi-yong-zui-xiao-hua-fei-pa-lou-ti-by-l-ncf8/ class Solution { public int minCostClimbingStairs(int[] cost) { // 状态定义：dp[i]表示爬到第i阶台阶的最低花费 int[] dp = new int[cost.length+1]; // 状态初始化：题目说可以直接不花费任何费用到达1或0 dp[0] = 0; dp[1] = 0; // 状态转移方程：dp[i]状态是由dp[i-1]或dp[i-2]转移过来，选择费用最低的方案即可 for(int i=2;i\u003cdp.length;i++){ dp[i] = Math.min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2]); } // System.out.println(Arrays.toString(dp)); return dp[cost.length]; } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:107:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day107 17. 电话号码的字母组合 题目 给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例 1： 输入：digits = \"23\" 输出：[\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"] 示例 2： 输入：digits = \"\" 输出：[] 示例 3： 输入：digits = \"2\" 输出：[\"a\",\"b\",\"c\"] 提示： 0 \u003c= digits.length \u003c= 4 digits[i] 是范围 ['2', '9'] 的一个数字。 解法 本题很容易想到DFS暴力搜索的方法，再加上题目给的数据集很小，所以DFS暴力搜索可以解决。依据题目输入digits字符串，找到其中每个数字字符匹配的一个字符之后再组合即是答案，于是，就可以不断地遍历digits，去搜索所有的字符情况，当然需要注意回溯。 class Solution { String[] ss; public List\u003cString\u003e letterCombinations(String digits) { ss = new String[]{\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"}; List\u003cString\u003e ls = new ArrayList\u003c\u003e(); if(digits.length()==0) { return ls; } dfs(digits,digits.length(),\"\",ls); return ls; } public void dfs(String digits,int step,String ans,List\u003cString\u003e ls){ // 结束条件 if(step==0){ // System.out.println(ans); ls.add(ans); return; } // 开始放第sIdx个位置 int sIdx = Integer.parseInt(Character.toString(digits.charAt(digits.length()-step)),10); for(int j=0;j\u003css[sIdx].length();j++){ // 先取第一个 ans+= ss[sIdx].charAt(j); dfs(digits,step-1,ans,ls); // 回溯到上一层 ans = ans.substring(0,ans.length()-1); } } } func letterCombinations(digits string) []string { if len(digits) == 0 { return []string{} } table:=[]string{\"\",\"\",\"abc\",\"def\",\"ghi\",\"jkl\",\"mno\",\"pqrs\",\"tuv\",\"wxyz\"} return dfs(table,digits,0,\"\") } func dfs(table []string, digits string, step int, cur string) []string { if step == len(digits){ return []string{cur} } ans := []string{} // 依次取号 didx,_:=strconv.Atoi(string(digits[step])) // 遍历号对应所有字符 for i:=0;i\u003clen(table[didx]);i++{ cur+=string(table[didx][i]) ans = append(ans,dfs(table,digits,step+1,cur)...) cur = string(cur[:len(cur)-1]) } return ans } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:108:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day108 22. 括号生成 题目 数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。 示例 1： 输入：n = 3 输出：[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"] 示例 2： 输入：n = 1 输出：[\"()\"] 提示： 1 \u003c= n \u003c= 8 解法 官方解法：暴力与回溯 我这里的解法是暴力回溯。其实这个问题也是属于组合问题，但是组合是有条件限制的。必须满足括号匹配原则的组合才能追加到最后的结果里。那么我们怎样判断呢？ 可以通过栈这种数据结构来实现括号匹配：当栈空的时候就往里面加括号，如果非空，就看栈顶的括号与即将加入的括号是否配对，配对就pop掉栈顶的括号，否则就加入到栈中。最后如果栈空了，就表明括号匹配，否则不能追加到结果里。 当然，其实这个过程可以优化一下：没必要等到所有括号处理完毕再判断，其实中间过程就可以提前判断出来，终止继续深度递归了，可以在一定程度优化时间复杂度。 // 先dfs放下所有组合，然后用栈来判断dfs的过程是否合理 class Solution { String[] table; public Solution(){ table = new String[]{\"(\",\")\"}; } public List\u003cString\u003e generateParenthesis(int n) { List\u003cString\u003e list = new ArrayList\u003c\u003e(); Stack\u003cString\u003e st = new Stack\u003c\u003e(); dfs(list,0,n,\"\",st); return list; } public void dfs(List\u003cString\u003e list,int step,int n,String ans,Stack\u003cString\u003e st){ if(step==2*n){ if(st.empty()) list.add(ans); return; } for(int i=0;i\u003c2;i++){ // 在放括号之前，需要保证括号配对 // 下面的变量用来记录当前深度的值，方便回溯 boolean op=false; String tmp =\"\"; if(st.empty()){ st.push(table[i]); }else{ if(table[i]==\")\"\u0026\u0026st.peek()==\"(\"){ tmp = st.pop(); op = true; }else{ st.push(table[i]); } } ans+=table[i]; dfs(list,step+1,n,ans,st); // 注意：这里借助栈来判断是否括号配对的同时也是dfs，所以需要注意回溯 ans = ans.substring(0,ans.length()-1); if(!op){ st.pop(); }else{ st.push(tmp); } } } } func generateParenthesis(n int) []string { stack :=[]byte{} return dfs(stack,\"\",0,n) } func dfs(stack []byte,cur string,step int,n int) []string{ if step==2*n { if len(stack)==0{ return []string{cur} }else{ return []string{} } } ans := []string{} for i:=0;i\u003c2;i++{ next:=byte('(') if i==1{ next = ')' } flag:=false last :=byte(' ') if len(stack)!=0\u0026\u0026next==')'\u0026\u0026stack[len(stack)-1]=='('{ last = stack[len(stack)-1] stack = stack[:len(stack)-1] }else{ stack = append(stack,next) flag = true } ans = append(ans,dfs(stack,cur+string(next),step+1,n)...) // 回溯 栈 if flag{ stack = stack[:len(stack)-1] }else{ stack = append(stack,last) } } return ans } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:109:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day109 39. 组合总和 题目 给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。 candidates 中的 同一个 数字可以 无限制重复被选取 。如果至少一个数字的被选数量不同，则两种组合是不同的。 对于给定的输入，保证和为 target 的不同组合数少于 150 个。 示例 1： 输入：candidates = [2,3,6,7], target = 7 输出：[[2,2,3],[7]] 解释： 2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。 7 也是一个候选， 7 = 7 。 仅有这两种组合。 示例 2： 输入: candidates = [2,3,5], target = 8 输出: [[2,2,2,2],[2,3,3],[3,5]] 示例 3： 输入: candidates = [2], target = 1 输出: [] 提示： 1 \u003c= candidates.length \u003c= 30 2 \u003c= candidates[i] \u003c= 40 candidates 的所有元素 互不相同 1 \u003c= target \u003c= 40 解法 题解 import java.util.ArrayDeque; import java.util.ArrayList; import java.util.Deque; import java.util.List; public class Solution { public List\u003cList\u003cInteger\u003e\u003e combinationSum(int[] candidates, int target) { int len = candidates.length; List\u003cList\u003cInteger\u003e\u003e res = new ArrayList\u003c\u003e(); if (len == 0) { return res; } Deque\u003cInteger\u003e path = new ArrayDeque\u003c\u003e(); dfs(candidates, 0, len, target, path, res); return res; } /** * @param candidates 候选数组 * @param begin 搜索起点 * @param len 冗余变量，是 candidates 里的属性，可以不传 * @param target 每减去一个元素，目标值变小 * @param path 从根结点到叶子结点的路径，是一个栈 * @param res 结果集列表 */ private void dfs(int[] candidates, int begin, int len, int target, Deque\u003cInteger\u003e path, List\u003cList\u003cInteger\u003e\u003e res) { // target 为负数和 0 的时候不再产生新的孩子结点 if (target \u003c 0) { return; } if (target == 0) { res.add(new ArrayList\u003c\u003e(path)); return; } // 重点理解这里从 begin 开始搜索的语意 for (int i = begin; i \u003c len; i++) { path.addLast(candidates[i]); // 注意：由于每一个元素可以重复使用，下一轮搜索的起点依然是i，这里非常容易弄错 dfs(candidates, i, len, target - candidates[i], path, res); // 状态重置 path.removeLast(); } } } // 剪枝优化版 import java.util.ArrayDeque; import java.util.ArrayList; import java.util.Arrays; import java.util.Deque; import java.util.List; public class Solution { public List\u003cList\u003cInteger\u003e\u003e combinationSum(int[] candidates, int target) { int len = candidates.length; List\u003cList\u003cInteger\u003e\u003e res = new ArrayList\u003c\u003e(); if (len == 0) { return res; } // 排序是剪枝的前提 Arrays.sort(candidat","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:110:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day110 78. 子集 题目 给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。 解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。 示例 1： 输入：nums = [1,2,3] 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] 示例 2： 输入：nums = [0] 输出：[[],[0]] 提示： 1 \u003c= nums.length \u003c= 10 -10 \u003c= nums[i] \u003c= 10 nums 中的所有元素 互不相同 解法 DFS class Solution { public List\u003cList\u003cInteger\u003e\u003e subsets(int[] nums) { List\u003cList\u003cInteger\u003e\u003e lls = new ArrayList\u003c\u003e(); List\u003cInteger\u003e ls = new ArrayList\u003c\u003e(); dfs(lls,ls,nums,0); return lls; } public void dfs(List\u003cList\u003cInteger\u003e\u003e lls,List\u003cInteger\u003e ls,int[] nums,int step){ if(step==nums.length){ lls.add(new ArrayList\u003c\u003e(ls)); return; } // System.out.println(ls.toString()); ls.add(ls.size(),nums[step]); // System.out.println(\"递归前：\"+ls.toString()); // 取下一个数 dfs(lls,ls,nums,step+1); // System.out.println(\"递归后：\"+ls.toString()); // 回溯 ls.remove(ls.size()-1); // 直接取下一个数，不取当前数 dfs(lls,ls,nums,step+1); } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:111:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day111 343. 整数拆分 题目 给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k \u003e= 2 ），并使这些整数的乘积最大化。 返回 你可以获得的最大乘积 。 示例 1: 输入: n = 2 输出: 1 解释: 2 = 1 + 1, 1 × 1 = 1。 示例 2: 输入: n = 10 输出: 36 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。 提示: 2 \u003c= n \u003c= 58 解法 代码随想录–dp 官方题解 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:112:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day112 96. 不同的二叉搜索树 题目 给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。 示例 1： 输入：n = 3 输出：5 示例 2： 输入：n = 1 输出：1 提示： 1 \u003c= n \u003c= 19 解法 相比官方更容易看懂得解法 官方题解 func numTrees(n int) int { if n==0 || n==1{ return 1 } if c,ok:=m[n];ok{ return c } count:=0 for i:=1;i\u003c=n;i++{ l:=numTrees(i-1) r:=numTrees(n-i) count += l*r } m[n]=count return count } // 记忆化 var m = map[int]int{} ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:113:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day113 518. 零钱兑换 II 题目 给你一个整数数组 coins 表示不同面额的硬币，另给一个整数 amount 表示总金额。 请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 0 。 假设每一种面额的硬币有无限个。 题目数据保证结果符合 32 位带符号整数。 示例 1： 输入：amount = 5, coins = [1, 2, 5] 输出：4 解释：有四种方式可以凑成总金额： 5=5 5=2+2+1 5=2+1+1+1 5=1+1+1+1+1 示例 2： 输入：amount = 3, coins = [2] 输出：0 解释：只用面额 2 的硬币不能凑成总金额 3 。 示例 3： 输入：amount = 10, coins = [10] 输出：1 提示： 1 \u003c= coins.length \u003c= 300 1 \u003c= coins[i] \u003c= 5000 coins 中的所有值 互不相同 0 \u003c= amount \u003c= 5000 解法 二维DP 典型的完全背包问题，需要注意：这里的背包容量需要正序遍历，因为状态转移方程是不断地去拿左上角的值，我们要确保这个值肯定要被算过（这样才符合完全背包的定义）。所以需要正序遍历背包容量。 状态转移方程也有不同 class Solution { public int change(int amount, int[] coins) { // 状态定义：dp[i][j]表示取1-i种硬币时，可以凑出面额为j的方法有多少种 int[][] dp = new int[coins.length+1][amount+1]; // 初始化：没有拿硬币时，可以凑出0的面额，方法有1种，就是什么都不做 dp[0][0] = 1; // 状态转移 for(int i=1;i\u003c=coins.length;i++){ for(int j=0;j\u003c=amount;j++){ if(j\u003e=coins[i-1]) dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]]; else dp[i][j] = dp[i-1][j]; } } // System.out.println(Arrays.deepToString(dp)); return dp[coins.length][amount]; } } 滚动数组优化为一维DP class Solution { public int change(int amount, int[] coins) { // 状态定义：dp[i]可以凑出面额为i的方法有多少种 int[] dp = new int[amount+1]; // 初始化：没有拿硬币时，可以凑出0的面额，方法有1种，就是什么都不做 dp[0] = 1; // 状态转移 for(int i=1;i\u003c=coins.length;i++){ for(int j=coins[i-1];j\u003c=amount;j++){// 枚举背包容量，当然最小肯定就是cons[i-1]了 if(j\u003e=coins[i-1]) dp[j] = dp[j] + dp[j-coins[i-1]]; } } // System.out.println(Arrays.roString(dp)); return dp[amount]; } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:114:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day114 多重背包 题目 有N种物品和一个容量为V 的背包。第i种物品最多有Mi件可用，每件耗费的空间是Ci ，价值是Wi 。求解将哪些物品装入背包可使这些物品的耗费的空间 总和不超过背包容量，且价值总和最大。 解法 多重背包和01背包是非常像的， 为什么和01背包像呢？ 每件物品最多有Mi件可用，把Mi件摊开，其实就是一个01背包问题了。 例如： 背包最大重量为10。 物品为： 重量 价值 数量 物品0 1 15 2 物品1 3 20 3 物品2 4 30 2 问背包能背的物品最大价值是多少？ 和如下情况有区别么？ 重量 价值 数量 物品0 1 15 1 物品0 1 15 1 物品1 3 20 1 物品1 3 20 1 物品1 3 20 1 物品2 4 30 1 物品2 4 30 1 毫无区别，这就转成了一个01背包问题了，且每个物品只用一次。 时间复杂度：O(m × n × k)，m：物品种类个数，n背包容量，k单类物品数量 也有另一种实现方式，就是把每种商品遍历的个数放在01背包里面在遍历一遍。 毫无区别，这就转成了一个01背包问题了，且每个物品只用一次。 时间复杂度：O(m × n × k)，m：物品种类个数，n背包容量，k单类物品数量 从代码里可以看出是01背包里面在加一个for循环遍历一个每种商品的数量。 和01背包还是如出一辙的。 当然还有那种二进制优化的方法，其实就是把每种物品的数量，打包成一个个独立的包。 和以上在循环遍历上有所不同，因为是分拆为各个包最后可以组成一个完整背包，具体原理我就不做过多解释了，大家了解一下就行，面试的话基本不会考完这个深度了，感兴趣可以自己深入研究一波。 public void testMultiPack1(){ // 版本一：改变物品数量为01背包格式 List\u003cInteger\u003e weight = new ArrayList\u003c\u003e(Arrays.asList(1, 3, 4)); List\u003cInteger\u003e value = new ArrayList\u003c\u003e(Arrays.asList(15, 20, 30)); List\u003cInteger\u003e nums = new ArrayList\u003c\u003e(Arrays.asList(2, 3, 2)); int bagWeight = 10; for (int i = 0; i \u003c nums.size(); i++) { while (nums.get(i) \u003e 1) { // 把物品展开为i weight.add(weight.get(i)); value.add(value.get(i)); nums.set(i, nums.get(i) - 1); } } int[] dp = new int[bagWeight + 1]; for(int i = 0; i \u003c weight.size(); i++) { // 遍历物品 for(int j = bagWeight; j \u003e= weight.get(i); j--) { // 遍历背包容量 dp[j] = Math.max(dp[j], dp[j - weight.get(i)] + value.get(i)); } System.out.println(Arrays.toString(dp)); } } public void testMultiPack2(){ // 版本二：改变遍历个数 int[] weight = new int[] {1, 3, 4}; int[] value = new int[] {15, 20, 30}; int[] nums = new int[] {2, 3, 2}; int bagWeight = 10; int[] dp = new int[bagWeight + 1]; for(int i = 0; i \u003c weight.length; i++) { // 遍历物品 for(int j = bagWeight; j \u003e= weight[i]; j--) { // 遍历背包容量 // 以上为01背包，然后加一个遍历个数 for (int k = 1; k \u003c= nums[i] \u0026\u0026 (j - k * weight[i]) \u003e= 0; k++) { // 遍历个数 dp[j] = Math.max(dp[j], dp[j - k * weight[i]] + k * value[i]); } System.out.println(Arrays.toString(dp)); } } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:115:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day115 198. 打家劫舍 题目 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1： 输入：[1,2,3,1] 输出：4 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2： 输入：[2,7,9,3,1] 输出：12 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 提示： 1 \u003c= nums.length \u003c= 100 0 \u003c= nums[i] \u003c= 400 解法 dp class Solution { public int rob(int[] nums) { // dp[i]表示偷窃前i个房屋，得到的最高金额为多少 int[] dp = new int[nums.length+1]; // 初始化 dp[0] = 0; dp[1] = nums[0]; for(int i=2;i\u003c=nums.length;i++){ dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i-1]); } //System.out.println(Arrays.toString(dp)); return dp[nums.length]; } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:116:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day116 213. 打家劫舍 II 题目 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。 给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。 示例 1： 输入：nums = [2,3,2] 输出：3 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。 示例 2： 输入：nums = [1,2,3,1] 输出：4 解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 3： 输入：nums = [1,2,3] 输出：3 提示： 1 \u003c= nums.length \u003c= 100 0 \u003c= nums[i] \u003c= 1000 解法 dp 这道题目和198.打家劫舍 (opens new window)是差不多的，唯一区别就是成环了。 对于一个数组，成环的话主要有如下三种情况： 情况一：考虑不包含首尾元素 情况二：考虑包含首元素，不包含尾元素 情况三：考虑包含尾元素，不包含首元素 注意我这里用的是\"考虑\"，例如情况三，虽然是考虑包含尾元素，但不一定要选尾部元素！ 对于情况三，取nums[1] 和 nums[3]就是最大的。 而情况二 和 情况三 都包含了情况一了，所以只考虑情况二和情况三就可以了。 分析到这里，本题其实比较简单了。 剩下的和198.打家劫舍 (opens new window)就是一样的了。 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:117:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day117 337. 打家劫舍 III 题目 小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为 root 。 除了 root 之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。 给定二叉树的 root 。返回 在不触动警报的情况下 ，小偷能够盗取的最高金额 。 示例 1: 输入: root = [3,2,3,null,3,null,1] 输出: 7 解释: 小偷一晚能够盗取的最高金额 3 + 3 + 1 = 7 示例 2: 输入: root = [3,4,5,1,3,null,1] 输出: 9 解释: 小偷一晚能够盗取的最高金额 4 + 5 = 9 提示： 树的节点数在 [1, 104] 范围内 0 \u003c= Node.val \u003c= 104 解法 树形dp ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:118:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day118 188. 买卖股票的最佳时机 IV 题目 给定一个整数数组 prices ，它的第 i 个元素 prices[i] 是一支给定的股票在第 i 天的价格，和一个整型 k 。 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易。也就是说，你最多可以买 k 次，卖 k 次。 **注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1： 输入：k = 2, prices = [2,4,1] 输出：2 解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。 示例 2： 输入：k = 2, prices = [3,2,6,5,0,3] 输出：7 解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。 随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。 提示： 0 \u003c= k \u003c= 100 0 \u003c= prices.length \u003c= 1000 0 \u003c= prices[i] \u003c= 1000 解法 dp 思路是\"买卖股票最大利润Ⅲ\"的变形思维。在原来基础上，由5个状态变为2*k+1个状态，遵循先买后卖原则，找到最大利润 class Solution { public int maxProfit(int k, int[] prices) { int[][] dp = new int[prices.length+1][2*k+1]; // 初始化 dp[0][0] = 0; dp[0][2] =0; for(int i=0;i\u003c2*k+1;i++){ if(i%2==1) dp[0][i] = -prices[0]; } for(int i=1;i\u003c=prices.length;i++){ for(int j=0;j\u003c2*k;j++){ dp[i][1+j] = Math.max(dp[i-1][j]+(int)Math.pow(-1,j+1)*prices[i-1],dp[i-1][1+j]); } } return dp[prices.length][2*k]; } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:119:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day119 300. 最长递增子序列 题目 给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。 子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。 示例 1： 输入：nums = [10,9,2,5,3,7,101,18] 输出：4 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。 示例 2： 输入：nums = [0,1,0,3,2,3] 输出：4 示例 3： 输入：nums = [7,7,7,7,7,7,7] 输出：1 提示： 1 \u003c= nums.length \u003c= 2500 -104 \u003c= nums[i] \u003c= 104 进阶： 你能将算法的时间复杂度降低到 O(n log(n)) 吗? 解法 官方题解 比较容易想的应该是【贪心+二分搜索】 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:120:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day120 309. 最佳买卖股票时机含冷冻期 题目 给定一个整数数组prices，其中第 prices[i] 表示第 *i* 天的股票价格 。 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 **注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1: 输入: prices = [1,2,3,0,2] 输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] 示例 2: 输入: prices = [1] 输出: 0 提示： 1 \u003c= prices.length \u003c= 5000 0 \u003c= prices[i] \u003c= 1000 解法 dp ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:121:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day121 516. 最长回文子序列 题目 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。 子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。 示例 1： 输入：s = \"bbbab\" 输出：4 解释：一个可能的最长回文子序列为 \"bbbb\" 。 示例 2： 输入：s = \"cbbd\" 输出：2 解释：一个可能的最长回文子序列为 \"bb\" 。 提示： 1 \u003c= s.length \u003c= 1000 s 仅由小写英文字母组成 解法 dp 这题的难点主要在于定义状态和找到状态转移方程。 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:122:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day122 583. 两个字符串的删除操作 题目 给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。 一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。 例如，\"ace\" 是 \"abcde\" 的子序列，但 \"aec\" 不是 \"abcde\" 的子序列。 两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。 示例 1： 输入：text1 = \"abcde\", text2 = \"ace\" 输出：3 解释：最长公共子序列是 \"ace\" ，它的长度为 3 。 示例 2： 输入：text1 = \"abc\", text2 = \"abc\" 输出：3 解释：最长公共子序列是 \"abc\" ，它的长度为 3 。 示例 3： 输入：text1 = \"abc\", text2 = \"def\" 输出：0 解释：两个字符串没有公共子序列，返回 0 。 提示： 1 \u003c= text1.length, text2.length \u003c= 1000 text1 和 text2 仅由小写英文字符组成。 题解 可以将问题转化为求解【最长公共子序列问题】. dp class Solution { public int minDistance(String word1, String word2) { int m = word1.length(), n = word2.length(); int[][] dp = new int[m + 1][n + 1]; for (int i = 1; i \u003c= m; i++) { char c1 = word1.charAt(i - 1); for (int j = 1; j \u003c= n; j++) { char c2 = word2.charAt(j - 1); if (c1 == c2) { dp[i][j] = dp[i - 1][j - 1] + 1; } else { dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]); } } } return word1.length()+word2.length()-2*dp[m][n]; } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:123:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day123 1143. 最长公共子序列 题目 给定两个单词 word1 和 word2 ，返回使得 word1 和 word2 相同所需的最小步数。 每步 可以删除任意一个字符串中的一个字符。 示例 1： 输入: word1 = \"sea\", word2 = \"eat\" 输出: 2 解释: 第一步将 \"sea\" 变为 \"ea\" ，第二步将 \"eat \"变为 \"ea\" 示例 2: 输入：word1 = \"leetcode\", word2 = \"etco\" 输出：4 提示： 1 \u003c= word1.length, word2.length \u003c= 500 word1 和 word2 只包含小写英文字母 题解 dp ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:124:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day124 647. 回文子串 题目 给你一个字符串 s ，请你统计并返回这个字符串中 回文子串 的数目。 回文字符串 是正着读和倒过来读一样的字符串。 子字符串 是字符串中的由连续字符组成的一个序列。 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。 示例 1： 输入：s = \"abc\" 输出：3 解释：三个回文子串: \"a\", \"b\", \"c\" 示例 2： 输入：s = \"aaa\" 输出：6 解释：6个回文子串: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\" 提示： 1 \u003c= s.length \u003c= 1000 s 由小写英文字母组成 解法 dp+中心拓展 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:125:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day125 674. 最长连续递增序列 问题 给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。 连续递增的子序列 可以由两个下标 l 和 r（l \u003c r）确定，如果对于每个 l \u003c= i \u003c r，都有 nums[i] \u003c nums[i + 1] ，那么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。 示例 1： 输入：nums = [1,3,5,4,7] 输出：3 解释：最长连续递增序列是 [1,3,5], 长度为3。 尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。 示例 2： 输入：nums = [2,2,2,2,2] 输出：1 解释：最长连续递增序列是 [2], 长度为1。 提示： 1 \u003c= nums.length \u003c= 104 -109 \u003c= nums[i] \u003c= 109 解法 解法一：双指针 不断地寻找连续递增子序列的长度，取最长。 class Solution { public int findLengthOfLCIS(int[] nums) { if(nums.length\u003c=1) return nums.length; int ans = 1; int tmp = 1; for(int l=0,r=1;l\u003cnums.length\u0026\u0026r\u003cnums.length;){ if(nums[r]\u003enums[l]){ l++;r++; tmp++; }else{ tmp = Math.max(tmp,ans); ans = tmp; tmp = 1; l = r; r++; } } // 额外检验递增序列 return tmp\u003eans?tmp:ans; } } 解法二：贪心 下面的算法其实和双指针本质上是一个东西。 贪心 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:126:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day126 714. 买卖股票的最佳时机含手续费 题目 给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格 ；整数 fee 代表了交易股票的手续费用。 你可以无限次地完成交易，但是你每笔交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。 返回获得利润的最大值。 **注意：**这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费。 示例 1： 输入：prices = [1, 3, 2, 8, 4, 9], fee = 2 输出：8 解释：能够达到的最大利润: 在此处买入 prices[0] = 1 在此处卖出 prices[3] = 8 在此处买入 prices[4] = 4 在此处卖出 prices[5] = 9 总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8 示例 2： 输入：prices = [1,3,7,5,10,3], fee = 3 输出：6 提示： 1 \u003c= prices.length \u003c= 5 * 104 1 \u003c= prices[i] \u003c 5 * 104 0 \u003c= fee \u003c 5 * 104 解法 解法一：dp 本题只是在【188. 买卖股票的最佳时机 IV】的基础上再附加手续费。所以，我们直接在原来的动态规划转移方程上再加上“如果是买入股票，无需处理；如果是卖出股票，需增加手续费”。 class Solution { public int maxProfit(int[] prices, int fee) { // dp[i][j]表示第i天（从1开始），第j个状态的最大利润 int[][] dp = new int[prices.length+1][2*prices.length+1]; // 初始化 for(int i=0;i\u003c2*prices.length+1;i++){ if(i%2==1) dp[0][i] = - prices[0]; } int s = 0; int fuhao = 0; for(int i=1;i\u003c=prices.length;i++){ for(int j=0;j\u003c2*prices.length;j++){ fuhao = (int)Math.pow(-1,j+1); if (fuhao==1 ){ s = fee; }else { s = 0; } dp[i][j+1] = Math.max(dp[i-1][j]+fuhao*prices[i-1] - s ,dp[i-1][j+1]); } } return dp[prices.length][2*prices.length]; } } 上面的解法中，定义的状态太多，有较高的空间复杂度。leetcode提交中，显示“内存超出限制”。 解法二：优化dp 优化dp ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:127:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day127 208. 实现 Trie (前缀树) 题目 Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。 请你实现 Trie 类： Trie() 初始化前缀树对象。 void insert(String word) 向前缀树中插入字符串 word 。 boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。 boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。 示例： 输入 [\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"] [[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]] 输出 [null, null, true, false, true, null, true] 解释 Trie trie = new Trie(); trie.insert(\"apple\"); trie.search(\"apple\"); // 返回 True trie.search(\"app\"); // 返回 False trie.startsWith(\"app\"); // 返回 True trie.insert(\"app\"); trie.search(\"app\"); // 返回 True 提示： 1 \u003c= word.length, prefix.length \u003c= 2000 word 和 prefix 仅由小写英文字母组成 insert、search 和 startsWith 调用次数 总计 不超过 3 * 104 次 解法 解法一：模拟 就是不断地去匹配寻找Trie树的下一个节点 class Trie { boolean isWord; // 单词是否以当前字符结尾 Trie[] nextNode; public Trie() { nextNode = new Trie[26]; } public void insert(String word) { Trie root = this; for(int i=0;i\u003cword.length();i++){ int idx = word.charAt(i)-'a'; if(root.nextNode[idx]==null){ Trie n = new Trie(); root.nextNode[idx] = n; } root = root.nextNode[idx]; } root.isWord = true; return; } public boolean search(String word) { Trie root = this; for(int i=0;i\u003cword.length();i++){ int idx = word.charAt(i)-'a'; if(root.nextNode[idx]==null){ return false; } root = root.nextNode[idx]; } return root.isWord; } public boolean startsWith(String prefix) { Trie root = this; for(int i=0;i\u003cprefix.length();i++){ int idx = prefix.charAt(i)-'a'; if(root.nextNode[idx]==null){ return false; } root = root.nextNode[idx]; } return true; } } /** * Your Trie object will be instantiated and called as such: * Trie obj = new Trie(); * obj.insert(word); * boolean param_2 = obj.search(word); * boolean param_3 = obj.startsWith(prefix); */ ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:128:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day128 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:129:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"718. 最长重复子数组 题目 给两个整数数组 nums1 和 nums2 ，返回 两个数组中 公共的 、长度最长的子数组的长度 。 示例 1： 输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7] 输出：3 解释：长度最长的公共子数组是 [3,2,1] 。 示例 2： 输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0] 输出：5 提示： 1 \u003c= nums1.length, nums2.length \u003c= 1000 0 \u003c= nums1[i], nums2[i] \u003c= 100 代码 解法一：暴力算法 class Solution { public int findLength(int[] nums1, int[] nums2) { int maxLen = 0; for(int i=0;i\u003cnums1.length;i++){ for(int j=0;j\u003cnums2.length;j++){ int k=0; while(i+k\u003cnums1.length\u0026\u0026j+k\u003cnums2.length\u0026\u0026nums1[i+k]==nums2[j+k]){ k+=1; } if(maxLen\u003ck) maxLen = k; } } return maxLen; } } 解法二：动态规划 思路及算法 暴力解法的过程中，我们发现最坏情况下对于任意 i 与 j ，A[i] 与 B[j] 比较了 min⁡(i+1,j+1) 次。这也是导致了该暴力解法时间复杂度过高的根本原因。 不妨设 A 数组为 [1, 2, 3]，B 两数组为为 [1, 2, 4] ，那么在暴力解法中 A[2] 与 B[2] 被比较了三次。这三次比较分别是我们计算 A[0:] 与 B[0:] 最长公共前缀、 A[1:] 与 B[1:] 最长公共前缀以及 A[2:] 与 B[2:] 最长公共前缀时产生的。 我们希望优化这一过程，使得任意一对 A[i] 和 B[j] 都只被比较一次。这样我们自然而然想到利用这一次的比较结果。如果 A[i] == B[j]，那么我们知道 A[i:] 与 B[j:] 的最长公共前缀为 A[i + 1:] 与 B[j + 1:] 的最长公共前缀的长度加一，否则我们知道 A[i:] 与 B[j:] 的最长公共前缀为零。 这样我们就可以提出动态规划的解法：令 dp[i][j] 表示 A[i:] 和 B[j:] 的最长公共前缀，那么答案即为所有 dp[i][j] 中的最大值。如果 A[i] == B[j]，那么 dp[i][j] = dp[i + 1][j + 1] + 1，否则 dp[i][j] = 0。 这里借用了 Python 表示数组的方法，A[i:] 表示数组 A 中索引 i 到数组末尾的范围对应的子数组。 考虑到这里 dp[i][j] 的值从 dp[i + 1][j + 1] 转移得到，所以我们需要倒过来，首先计算 dp[len(A) - 1][len(B) - 1]，最后计算 dp[0][0]。 class Solution { public int findLength(int[] nums1, int[] nums2) { // dp[i][j]表示nums1[i:]和nums2[j:]的最长公共前缀长度 int[][] dp = new int[nums1.length+1][nums2.length+1]; int max =0; for(int i=nums1.length-1;i\u003e=0;i--){ for(int j= nums2.length-1;j\u003e=0;j--){ if(nums1[i]==nums2[j]){ dp[i][j] = dp[i+1][j+1]+1; } max = Math.max(dp[i][j],max); } } return max; } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:129:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day129 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:130:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"1035. 不相交的线 题目 在两条独立的水平线上按给定的顺序写下 nums1 和 nums2 中的整数。 现在，可以绘制一些连接两个数字 nums1[i] 和 nums2[j] 的直线，这些直线需要同时满足满足： nums1[i] == nums2[j] 且绘制的直线不与任何其他连线（非水平线）相交。 请注意，连线即使在端点也不能相交：每个数字只能属于一条连线。 以这种方法绘制线条，并返回可以绘制的最大连线数。 示例 1： 输入：nums1 = [1,4,2], nums2 = [1,2,4] 输出：2 解释：可以画出两条不交叉的线，如上图所示。 但无法画出第三条不相交的直线，因为从 nums1[1]=4 到 nums2[2]=4 的直线将与从 nums1[2]=2 到 nums2[1]=2 的直线相交。 示例 2： 输入：nums1 = [2,5,1,2,5], nums2 = [10,5,2,1,5,2] 输出：3 示例 3： 输入：nums1 = [1,3,7,1,7,5], nums2 = [1,9,2,5,1] 输出：2 提示： 1 \u003c= nums1.length, nums2.length \u003c= 500 1 \u003c= nums1[i], nums2[j] \u003c= 2000 解法 解法一：动态规划 其实这个问题本质上就是求解最长公共子序列问题 class Solution { public int maxUncrossedLines(int[] nums1, int[] nums2) { // dp[i][j]表示nums1[:i]与nums2[:j]中最长公共子序列的长度 int[][] dp = new int[nums1.length+1][nums2.length+1]; // 初始状态 dp[0][0] = 0; for(int i=1;i\u003c=nums1.length;i++){ for(int j=1;j\u003c=nums2.length;j++){ if(nums1[i-1]==nums2[j-1]){ dp[i][j] = dp[i-1][j-1]+1; }else{ dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]); } } } return dp[nums1.length][nums2.length]; } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:130:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day130 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:131:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"1646. 获取生成数组中的最大值 题目 给你一个整数 n 。按下述规则生成一个长度为 n + 1 的数组 nums ： nums[0] = 0 nums[1] = 1 当 2 \u003c= 2 * i \u003c= n 时，nums[2 * i] = nums[i] 当 2 \u003c= 2 * i + 1 \u003c= n 时，nums[2 * i + 1] = nums[i] + nums[i + 1] 返回生成数组 nums 中的 最大 值。 示例 1： 输入：n = 7 输出：3 解释：根据规则： nums[0] = 0 nums[1] = 1 nums[(1 * 2) = 2] = nums[1] = 1 nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2 nums[(2 * 2) = 4] = nums[2] = 1 nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3 nums[(3 * 2) = 6] = nums[3] = 2 nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3 因此，nums = [0,1,1,2,1,3,2,3]，最大值 3 示例 2： 输入：n = 2 输出：1 解释：根据规则，nums[0]、nums[1] 和 nums[2] 之中的最大值是 1 示例 3： 输入：n = 3 输出：2 解释：根据规则，nums[0]、nums[1]、nums[2] 和 nums[3] 之中的最大值是 2 提示： 0 \u003c= n \u003c= 100 解法 解法一：模拟 class Solution { public int getMaximumGenerated(int n) { if(n\u003c=0) return 0; int max = 1; int[] nums = new int[n+1]; nums[1] = 1; for(int i=2;i\u003c=n;i++){ if(i%2==0){ nums[i] = nums[i/2]; }else{ nums[i] = nums[(i-1)/2] + nums[(i+1)/2]; } max = Math.max(max,nums[i]); } // System.out.println(Arrays.toString(nums)); return max; } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:131:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day131 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:132:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"79. 单词搜索 题目 解法 解法一：二进制法和dfs法 官方解法 解法二：暴力dfs 思路比较简单，对每一个位置进行四个方向的dfs，找到即可结束dfs了。 结束条件：当前i处字符相等，且是word最后一个字符，可以return true了 class Solution { public boolean exist(char[][] board, String word) { boolean ok =false; boolean[][] v = new boolean[board.length][board[0].length]; for(int i=0;i\u003cboard.length;i++){ for(int j=0;j\u003cboard[0].length;j++){ ok = dfs(board,word,i,j,0,v); if(ok) return true; // System.out.println(ok); } } return false; } public boolean dfs(char[][] board,String word,int nextI,int nextJ,int i,boolean[][] v){ if(word.charAt(i)!=board[nextI][nextJ]){ return false; }else if (i == word.length() - 1) { return true; } // System.out.println(board[nextI][nextJ]); v[nextI][nextJ] = true; boolean ok = false; // 四个方向dfs if(ok_(board,nextI+1,nextJ)\u0026\u0026!v[nextI+1][nextJ]){// 右 ok = ok||dfs(board,word,nextI+1,nextJ,i+1,v); } if(ok_(board,nextI-1,nextJ)\u0026\u0026!v[nextI-1][nextJ]){// 左 ok = ok||dfs(board,word,nextI-1,nextJ,i+1,v); } if(ok_(board,nextI,nextJ+1)\u0026\u0026!v[nextI][nextJ+1]){// 下 ok = ok||dfs(board,word,nextI,nextJ+1,i+1,v); } if(ok_(board,nextI,nextJ-1)\u0026\u0026!v[nextI][nextJ-1]){// 上 ok = ok||dfs(board,word,nextI,nextJ-1,i+1,v); } v[nextI][nextJ] = false; return ok; } public boolean ok_(char[][] board,int newi,int newj){ return newi \u003e= 0 \u0026\u0026 newi \u003c board.length \u0026\u0026 newj \u003e= 0 \u0026\u0026 newj \u003c board[0].length; } } func exist(board [][]byte, word string) bool { var dfs func(step,row,col int) v := make([][]bool,len(board)) m:=len(board) n:=len(board[0]) for i:=0;i\u003clen(board);i++{ v[i]=make([]bool,len(board[0])) } check:=func(i,j int)bool{ return i\u003e=0\u0026\u0026i\u003cm\u0026\u0026j\u003e=0\u0026\u0026j\u003cn } ans:=false dfs = func(step,row,col int){ if board[row][col]!=word[step]{ return } if step==len(word)-1{ ans = true return } // fmt.Println(string(board[row][col]),string(word[step])) v[row][col]=true dir:=[][]int{{-1,0},{1,0},{0,1},{0,-1}} for i:=0;i\u003c4;i++{ newrow:=row+dir[i][0] newcol:=col+dir[i][1] if check(newrow,newcol)\u0026\u0026!v[newrow][newcol]{ dfs(step+1,newrow,newcol) } } v[row][col]=false } for i:=0;i\u003cm;i++{ for j:=0;j\u003cn;j+","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:132:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day132 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:133:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"36. 有效的数独 题目 请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图） 注意： 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 空白格用 '.' 表示。 示例 1： 输入：board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"] ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"] ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"] ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"] ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"] ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"] ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"] ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"] ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]] 输出：true 示例 2： 输入：board = [[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"] ,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"] ,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"] ,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"] ,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"] ,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"] ,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"] ,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"] ,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]] 输出：false 解释：除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。 提示： board.length == 9 board[i].length == 9 board[i][j] 是一位数字（1-9）或者 '.' 解法 数组哈希法 class Solution { public boolean isValidSudoku(char[][] board) { int[][] rows = new int[9][9]; int[][] columns = new int[9][9]; int[][][] subboxes = new int[3][3][9]; for (int i = 0; i \u003c 9; i++) { for (int j = 0; j \u003c 9; j++) { char c = board[i][j]; if (c != '.') { int index = c - '0' - 1; rows[i][index]++; columns[j][index]++; subboxes[i / 3][j / 3][index]++; if (rows[i][index] \u003e 1 || columns[j][index] \u003e 1 || subboxes[i / 3][j / 3][index] \u003e 1) { return false; } } } } return true; } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:133:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day133 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:134:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"37. 解数独 题目 编写一个程序，通过填充空格来解决数独问题。 数独的解法需 遵循如下规则： 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图） 数独部分空格内已填入了数字，空白格用 '.' 表示。 示例 1： 输入：board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]] 输出：[[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]] 解释：输入的数独如上图所示，唯一有效的解决方案如下所示： 提示： board.length == 9 board[i].length == 9 board[i][j] 是一位数字或者 '.' 题目数据 保证 输入数独仅有一个解 解法 解法一：dfs+回溯 其实题目的解法很明显，dfs暴搜，主要是回溯的过程和以往的题目不太一样：填数独并不是挨着格子填的，所以回溯的时候也不是挨着格子回溯，先记录这些空格子的位置，回溯的时候按照记录来回溯即可 class Solution { private boolean[][] line = new boolean[9][9]; private boolean[][] column = new boolean[9][9]; private boolean[][][] block = new boolean[3][3][9]; private boolean valid = false; private List\u003cint[]\u003e spaces = new ArrayList\u003cint[]\u003e(); public void solveSudoku(char[][] board) { for (int i = 0; i \u003c 9; ++i) { for (int j = 0; j \u003c 9; ++j) { if (board[i][j] == '.') { spaces.add(new int[]{i, j}); } else { int digit = board[i][j] - '0' - 1; line[i][digit] = column[j][digit] = block[i / 3][j / 3][digit] = true; } } } dfs(board, 0); } public void dfs(char[][] board, int pos) { if (pos == spaces.size()) { valid = true; return; } int[] space = spaces.get(pos); int i = space[0], j = space[1]; for (int digit = 0; digit \u003c 9 \u0026\u0026 !valid; ++digit) { if (!line[i][digit] \u0026\u0026 !column[j][digit] \u0026\u0026 !block[i / 3][j / 3][digit]) { line[i][digit] = column[j][digit] = block[i / 3][j / 3][digit] = true; board[i][j] = (char","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:134:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day134 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:135:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"51. N 皇后 题目 按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。 n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案。 每一种解法包含一个不同的 n 皇后问题 的棋子放置方案，该方案中 'Q' 和 '.' 分别代表了皇后和空位。 示例 1： 输入：n = 4 输出：[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]] 解释：如上图所示，4 皇后问题存在两个不同的解法。 示例 2： 输入：n = 1 输出：[[\"Q\"]] 提示： 1 \u003c= n \u003c= 9 解法 解法一：dfs+回溯 https://leetcode.cn/problems/n-queens/solutions/398929/nhuang-hou-by-leetcode-solution/ ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:135:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day135 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:136:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"52. N 皇后 II 题目 n 皇后问题 研究的是如何将 n 个皇后放置在 n × n 的棋盘上，并且使皇后彼此之间不能相互攻击。 给你一个整数 n ，返回 n 皇后问题 不同的解决方案的数量。 示例 1： 输入：n = 4 输出：2 解释：如上图所示，4 皇后问题存在两个不同的解法。 示例 2： 输入：n = 1 输出：1 提示： 1 \u003c= n \u003c= 9 解法 解法一：dfs+回溯 https://leetcode.cn/problems/n-queens-ii/solutions/449388/nhuang-hou-ii-by-leetcode-solution/ class Solution { int total = 0; public int totalNQueens(int n) { int[] queens = new int[n]; Arrays.fill(queens,-1); Set\u003cInteger\u003e column = new HashSet\u003c\u003e(); Set\u003cInteger\u003e l = new HashSet\u003c\u003e(); Set\u003cInteger\u003e r = new HashSet\u003c\u003e(); dfs(n,0,column,l,r); return total; } public void dfs(int n,int k,Set\u003cInteger\u003e column,Set\u003cInteger\u003e l,Set\u003cInteger\u003e r){ if(k==n){ total++; return; } for(int i=0;i\u003cn;i++){ if(column.contains(i)) continue; if(l.contains(k-i)) continue; if(r.contains(k+i)) continue; column.add(i); l.add(k-i); r.add(k+i); dfs(n,k+1,column,l,r); column.remove(i); l.remove(k-i); r.remove(k+i); } } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:136:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day136 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:137:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"191. 位1的个数 题目 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 ‘1’ 的个数（也被称为汉明重量）。 提示： 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的还是无符号的，其内部的二进制表示形式都是相同的。 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在 示例 3 中，输入表示有符号整数 -3。 示例 1： 输入：n = 00000000000000000000000000001011 输出：3 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。 示例 2： 输入：n = 00000000000000000000000010000000 输出：1 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。 示例 3： 输入：n = 11111111111111111111111111111101 输出：31 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。 提示： 输入必须是长度为 32 的 二进制串 。 进阶： 如果多次调用这个函数，你将如何优化你的算法？ 解法 解法一：位运算 public class Solution { // you need to treat n as an unsigned value public int hammingWeight(int n) { int cnt = 0; while(n!=0){ if(n\u003c0) { // 取最高位 if(((n\u003e\u003e31)\u00261)==1) cnt++; n\u003c\u003c=1; }else { // 取最低位 if((n\u00261)==1) cnt++; n\u003e\u003e=1; } } return cnt; } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:137:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day137 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:138:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"231. 2 的幂 题目 给你一个整数 n，请你判断该整数是否是 2 的幂次方。如果是，返回 true ；否则，返回 false 。 如果存在一个整数 x 使得 n == 2x ，则认为 n 是 2 的幂次方。 示例 1： 输入：n = 1 输出：true 解释：20 = 1 示例 2： 输入：n = 16 输出：true 解释：24 = 16 示例 3： 输入：n = 3 输出：false 示例 4： 输入：n = 4 输出：true 示例 5： 输入：n = 5 输出：false 提示： -231 \u003c= n \u003c= 231 - 1 **进阶：**你能够不使用循环/递归解决此问题吗？ 解法 解法一：位运算 32个bit位，最多只有一个bit位为1才是2的幂，否则不是。 class Solution { public boolean isPowerOfTwo(int n) { boolean ok =false; if(n\u003c=0) return false; int cnt =0; for(int i=0;i\u003c32;i++){ if((n\u0026(1\u003c\u003ci))!=0) { cnt++; if(cnt\u003e1) return false; } } return true; } } 进阶：O(1)实现 https://leetcode.cn/problems/power-of-two/solutions/796201/2de-mi-by-leetcode-solution-rny3/ // n \u0026 (n - 1)移除最低位的1，这样还剩1的话，说明不满足 class Solution { public boolean isPowerOfTwo(int n) { return n \u003e 0 \u0026\u0026 (n \u0026 (n - 1)) == 0; } } // n \u0026 -n 直接获取最低位1. 并且n\u003e0，n \u0026 -n = n。所以n为2的幂 class Solution { public boolean isPowerOfTwo(int n) { return n \u003e 0 \u0026\u0026 (n \u0026 -n) == n; } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:138:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day138 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:139:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"200. 岛屿数量 题目 解法 解法一：并查集 class Solution { public int numIslands(char[][] grid) { int m = grid.length,n = grid[0].length; int x = 0; for(int i=0;i\u003cm;i++){ for(int j=0;j\u003cn;j++){ if(grid[i][j]=='0') x++; } } Uf uf = new Uf(n*m); for(int i=0;i\u003cm;i++){ for(int j=0;j\u003cn;j++){ if(grid[i][j]=='1') { needUf(grid,i,j,m,n,uf); } } } return uf.count - x; } // 判断当前网格是否需要union. 是岛屿且与前面的连通 public void needUf(char[][] grid,int i,int j,int row,int col,Uf uf){ int[][] dirs = new int[][]{{0,-1},{0,1},{1,0},{-1,0}}; for(int[] dir:dirs){ int newi = i+dir[0],newj = j+dir[1]; if(newi\u003c0||newi\u003e=row||newj\u003c0||newj\u003e=col) continue; if(grid[newi][newj] == '1') { if(!uf.connected(newi*col+newj,i*col+j)){ uf.union(newi*col+newj,i*col+j); } } } return; } } class Uf{ int count; // 连通分量 int[] parents; // 存储每个节点的父节点 public Uf(int n){ count = n; parents = new int[n]; for(int i=0;i\u003cn;i++){ parents[i] = i; } } // 将两个点连通 public void union(int p,int q){ int rootp = find(p); int rootq = find(q); if(rootp==rootq) return; parents[rootp] = rootq; count--; } public boolean connected(int p,int q){ return find(p)==find(q); } // 查找x的根节点 public int find(int x){ if(x!=parents[x]){ x = find(parents[x]); } return parents[x]; } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:139:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day139 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:140:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"547. 省份数量 题目 有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。 省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。 给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。 返回矩阵中 省份 的数量。 示例 1： 输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]] 输出：2 示例 2： 输入：isConnected = [[1,0,0],[0,1,0],[0,0,1]] 输出：3 提示： 1 \u003c= n \u003c= 200 n == isConnected.length n == isConnected[i].length isConnected[i][j] 为 1 或 0 isConnected[i][i] == 1 isConnected[i][j] == isConnected[j][i] 解法 解法一：并查集 class Solution { public int findCircleNum(int[][] isConnected) { int n=isConnected.length; UF uf = new UF(n); for(int i=0;i\u003cn;i++){ for(int j=i+1;j\u003cn;j++){ // 剪枝：对称矩阵只需要对角线一半即可 if(isConnected[i][j]==1/*\u0026\u0026!uf.connected(i,j)*/){ uf.union(i,j); } } } return uf.cnt; } } class UF{ int cnt; // 连通分量个数 int[] parents; // 存储父节点 public UF(int n){ cnt = n; parents = new int[n]; for(int i=0;i\u003cn;i++) parents[i] = i; } public void union(int a,int b){ int ra = find(a); int rb = find(b); if(ra==rb) return; // 已经连通 parents[ra] = rb; // 没连通，就将其中一个根节点拼上去 // parents[rb] = ra; cnt--; } // 判断a和b是否连通（是否含有相同根节点） public boolean connected(int a, int b){ return find(a)==find(b); } // 寻找根节点 public int find(int x){ if(x!=parents[x]){ parents[x] = find(parents[x]); } return parents[x]; } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:140:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day140 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:141:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"2. 两数相加 题目 给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例 1： 输入：l1 = [2,4,3], l2 = [5,6,4] 输出：[7,0,8] 解释：342 + 465 = 807. 示例 2： 输入：l1 = [0], l2 = [0] 输出：[0] 示例 3： 输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] 输出：[8,9,9,9,0,0,0,1] 提示： 每个链表中的节点数在范围 [1, 100] 内 0 \u003c= Node.val \u003c= 9 题目数据保证列表表示的数字不含前导零 解法 解法一：模拟 模拟数学上两数相加法则：低位相加大于10，减10得进位1，模10得本位。 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode { jw := 0 l3 := \u0026ListNode{} tmp := l3 rs := 0 for l1!=nil\u0026\u0026l2!=nil { rs = l1.Val+l2.Val+jw; tmp.Val = rs%10 jw = rs/10 if(l1.Next!=nil||l2.Next!=nil){ tmp.Next = new(ListNode) tmp = tmp.Next } l1 = l1.Next l2 = l2.Next } for(l1!=nil){ rs = l1.Val+jw tmp.Val = rs%10 jw = rs/10 if(l1.Next!=nil){ tmp.Next = new(ListNode) tmp = tmp.Next } l1=l1.Next } for(l2!=nil){ rs = l2.Val+jw tmp.Val = rs%10 jw = rs/10 if(l2.Next!=nil) { tmp.Next = new(ListNode) tmp = tmp.Next } l2=l2.Next } if(jw!=0){ tmp.Next = new(ListNode) tmp.Next.Val = jw } return l3 } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:141:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day141 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:142:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"3. 无重复字符的最长子串 题目 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 输入: s = \"abcabcbb\" 输出: 3 解释: 因为无重复字符的最长子串是 \"abc\"，所以其长度为 3。 示例 2: 输入: s = \"bbbbb\" 输出: 1 解释: 因为无重复字符的最长子串是 \"b\"，所以其长度为 1。 示例 3: 输入: s = \"pwwkew\" 输出: 3 解释: 因为无重复字符的最长子串是 \"wke\"，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，\"pwke\" 是一个子序列，不是子串。 提示： 0 \u003c= s.length \u003c= 5 * 104 s 由英文字母、数字、符号和空格组成 解法 解法一：滑动窗口 https://leetcode.cn/problems/longest-substring-without-repeating-characters/solutions/227999/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2/ ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:142:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day142 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:143:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"4. 寻找两个正序数组的中位数 题目 给定两个大小分别为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。请你找出并返回这两个正序数组的 中位数 。 算法的时间复杂度应该为 O(log (m+n)) 。 示例 1： 输入：nums1 = [1,3], nums2 = [2] 输出：2.00000 解释：合并数组 = [1,2,3] ，中位数 2 示例 2： 输入：nums1 = [1,2], nums2 = [3,4] 输出：2.50000 解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5 提示： nums1.length == m nums2.length == n 0 \u003c= m \u003c= 1000 0 \u003c= n \u003c= 1000 1 \u003c= m + n \u003c= 2000 -106 \u003c= nums1[i], nums2[i] \u003c= 106 解法 解法一：双指针 这个问题最核心的就是合并两个有序数组。我们使用双指针算法：一个指针指向数组nums1首部，另一个指向数组nums2首部，然后比较大小，最小的放到新数组最前面，然后移动那个最小指针再和其他数组指针比较。如果某个数组元素提前结束，将这个数组的后面元素附加过来 func findMedianSortedArrays(nums1 []int, nums2 []int) float64 { // 合并 nums := make([]int,len(nums1)+len(nums2)) i1:=0 i2:=0 for i:=0;i\u003clen(nums);i++ { if i1\u003clen(nums1)\u0026\u0026i2\u003clen(nums2) { if nums1[i1]\u003cnums2[i2]{ nums[i] = nums1[i1] i1++ }else{ nums[i] = nums2[i2] i2++ } }else if i1\u003e=len(nums1) \u0026\u0026 i2 \u003clen(nums2) { nums[i] = nums2[i2] i2++ }else if i1\u003clen(nums1) \u0026\u0026 i2 \u003e=len(nums2){ nums[i] = nums1[i1] i1++ } } if len(nums)%2==1{ return float64(nums[len(nums)/2]) } return (0.0 + float64(nums[len(nums)/2]+nums[len(nums)/2-1])) / 2 } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:143:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day143 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:144:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"5. 最长回文子串 题目 给你一个字符串 s，找到 s 中最长的回文子串。 如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。 示例 1： 输入：s = \"babad\" 输出：\"bab\" 解释：\"aba\" 同样是符合题意的答案。 示例 2： 输入：s = \"cbbd\" 输出：\"bb\" 提示： 1 \u003c= s.length \u003c= 1000 s 仅由数字和英文字母组成 解法 解法一：动态规划 func longestPalindrome(s string) string { len:=len(s) if len\u003c2 { return s } maxlen:=1 begin:=0 dp := make([][]bool, len) // 初始化：长度为1的是回文串；长度为2的子串，但是两个字符相等的也是子串 for i := 0; i \u003c len; i++ { dp[i] = make([]bool, len) dp[i][i] = true if i\u003clen-1\u0026\u0026s[i]==s[i+1]{ dp[i][i+1] = true } } // 状态转移：P(i,j)=P(i+1,j−1)∧(Si==Sj) for L:=2;L\u003c=len;L++{ for i:=0;i\u003clen;i++{ j:=i+L-1 if j\u003e=len { break } if s[i] == s[j] \u0026\u0026 j-i+1\u003e2 { dp[i][j] = dp[i+1][j-1] } if dp[i][j] \u0026\u0026 maxlen\u003cj-i+1{ maxlen = j-i+1 begin = i } } } return s[begin:begin+maxlen] } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:144:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day144 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:145:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"10. 正则表达式匹配 题目 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 '.' 和 '*' 的正则表达式匹配。 '.' 匹配任意单个字符 '*' 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。 示例 1： 输入：s = \"aa\", p = \"a\" 输出：false 解释：\"a\" 无法匹配 \"aa\" 整个字符串。 示例 2: 输入：s = \"aa\", p = \"a*\" 输出：true 解释：因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 \"aa\" 可被视为 'a' 重复了一次。 示例 3： 输入：s = \"ab\", p = \".*\" 输出：true 解释：\".*\" 表示可匹配零个或多个（'*'）任意字符（'.'）。 提示： 1 \u003c= s.length \u003c= 20 1 \u003c= p.length \u003c= 20 s 只包含从 a-z 的小写字母。 p 只包含从 a-z 的小写字母，以及字符 . 和 *。 保证每次出现字符 * 时，前面都匹配到有效的字符 解法 解法一：动态规划 https://leetcode.cn/problems/regular-expression-matching/solutions/296114/shou-hui-tu-jie-wo-tai-nan-liao-by-hyj8/ func isMatch(s string, p string) bool { m, n := len(s), len(p) // if m==0||n==0 {return false} // dp[i][j]表示s[:i]是否与p[:j]匹配 dp := make([][]bool, m+1) for i:=0;i\u003c=m;i++{ dp[i] = make([]bool,n+1) } matched := func(i,j int) bool { return s[i]==p[j]||p[j]=='.' } dp[0][0] = true for j:=1;j\u003c=n;j++{ if p[j-1]=='*' { dp[0][j] = dp[0][j-2] } } for i:=1;i\u003cm+1;i++{ for j:=1;j\u003cn+1;j++{ if matched(i-1,j-1){ dp[i][j] = dp[i-1][j-1] }else{ if p[j-1]=='*'{ if matched(i-1,j-2){// 三种情况 dp[i][j] = dp[i-1][j-1]||dp[i][j-2]||dp[i-1][j] }else{ dp[i][j] = dp[i][j-2] } } } } } return dp[m][n] } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:145:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day145 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:146:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"21. 合并两个有序链表 题目 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例 1： 输入：l1 = [1,2,4], l2 = [1,3,4] 输出：[1,1,2,3,4,4] 示例 2： 输入：l1 = [], l2 = [] 输出：[] 示例 3： 输入：l1 = [], l2 = [0] 输出：[0] 提示： 两个链表的节点数目范围是 [0, 50] -100 \u003c= Node.val \u003c= 100 l1 和 l2 均按 非递减顺序 排列 解法 解法一：双指针 两个指针分别指向两个链表首部，依次比较首部大小，将小的从所在链表移除并移入到新的链表中，如果某个链表为空，则将另一个非空链表直接拿过来 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode { dummpy:=\u0026ListNode{} tmp:=dummpy for list1!=nil||list2!=nil { if list1!=nil\u0026\u0026list2!=nil{ if list1.Val\u003elist2.Val { tmp.Next = list2 tmp = tmp.Next list2 = list2.Next }else{ tmp.Next = list1 tmp = tmp.Next list1 = list1.Next } }else if list1==nil\u0026\u0026list2!=nil { tmp.Next = list2 list2 = nil }else if list1!=nil\u0026\u0026list2==nil{ tmp.Next = list1 list1 = nil } } return dummpy.Next } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:146:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day146 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:147:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"23. 合并 K 个升序链表 题目 给你一个链表数组，每个链表都已经按升序排列。 请你将所有链表合并到一个升序链表中，返回合并后的链表。 示例 1： 输入：lists = [[1,4,5],[1,3,4],[2,6]] 输出：[1,1,2,3,4,4,5,6] 解释：链表数组如下： [ 1-\u003e4-\u003e5, 1-\u003e3-\u003e4, 2-\u003e6 ] 将它们合并到一个有序链表中得到。 1-\u003e1-\u003e2-\u003e3-\u003e4-\u003e4-\u003e5-\u003e6 示例 2： 输入：lists = [] 输出：[] 示例 3： 输入：lists = [[]] 输出：[] 提示： k == lists.length 0 \u003c= k \u003c= 10^4 0 \u003c= lists[i].length \u003c= 500 -10^4 \u003c= lists[i][j] \u003c= 10^4 lists[i] 按 升序 排列 lists[i].length 的总和不超过 10^4 解法 解法一：顺序地两两合并 k个链表合并可以抽象出两个链表进行合并后再和第三个链表进行两两合并，如此往复 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeKLists(lists []*ListNode) *ListNode { if len(lists)==0{ return nil }else if len(lists)==1{ return lists[0] } var tmp *ListNode for i:=0;i\u003clen(lists);i++ { tmp = mergeTwoList(tmp,lists[i]) } return tmp } func mergeTwoList(l1,l2 *ListNode) *ListNode{ l:=\u0026ListNode{} head :=l for l1!=nil\u0026\u0026l2!=nil{ if l1.Val\u003cl2.Val{ l.Next = l1 l1 = l1.Next }else{ l.Next = l2 l2 = l2.Next } l = l.Next } for l1!=nil { l.Next = l1 l1 = nil } for l2!=nil{ l.Next = l2 l2 = nil } return head.Next } 解法二：分治法 不断将多个链表分成单个，然后两两配对合并 /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func mergeKLists(lists []*ListNode) *ListNode { return split(lists,0,len(lists)-1) } func split(lists []*ListNode,l,r int) *ListNode { if l==r{ return lists[l] } if l\u003er{ return nil } mid :=(l+r)/2 l1:= split(lists,l,mid) l2:= split(lists,mid+1,r) return mergeTwoList(l1,l2) } func mergeTwoList(l1,l2 *ListNode) *ListNode{ l:=\u0026ListNode{} head :=l for l1!=nil\u0026\u0026l2!=nil{ if l1.Val\u003cl2.Val{ l.Next = l1 l1 = l1.Next }else{ l.Next = l2 l2 = l2.Next } l = l.Next } for l1!=nil { l.Next = l1 l1 = nil } for l2!=nil{ l.Next = l2 l2 = nil } return head.Next } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:147:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day147 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:148:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"31. 下一个排列 题目 整数数组的一个 排列 就是将其所有成员以序列或线性顺序排列。 例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。 整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。 例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。 类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。 而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。 给你一个整数数组 nums ，找出 nums 的下一个排列。 必须** 原地 **修改，只允许使用额外常数空间。 示例 1： 输入：nums = [1,2,3] 输出：[1,3,2] 示例 2： 输入：nums = [3,2,1] 输出：[1,2,3] 示例 3： 输入：nums = [1,1,5] 输出：[1,5,1] 提示： 1 \u003c= nums.length \u003c= 100 0 \u003c= nums[i] \u003c= 100 解法 解法一：找数学规律 推导过程： 1,2,3-\u003e1,3,2 1,3,2-\u003e2,1,3 1,4,3,2-\u003e2,1,3,4 2,6,5,4,3,1-\u003e3,6,5,4,2,1-\u003e3,1,2,4,5,6-\u003e 2,6,7,5,4,1-\u003e2,7,1,4,5,6 3,7,5,4,1-\u003e4,7,5,3,1-\u003e4,1,3,7,5 6,5,4,1-\u003e1,4,5,6 1,3,2,4,5,6,9,10,11,15,14,19,16-\u003e1,3,2,4,5,6,9,10,11,15,16,14,19 从右往左看，碰到降序序列(两个就够了)，说明不需要修改降序序列前的顺序，只需要调整降序序列后，需要从后面的序列里挑出第一个大于当前降序序列首部的数字或没有也可以，然后再把后面的升序列反转。 func nextPermutation(nums []int) { if len(nums) \u003c= 1 { return } i := len(nums) - 2 j := len(nums) - 1 k := len(nums) - 1 // 找降序序列（从右往左） for i \u003e= 0 \u0026\u0026 j \u003e= 0 { if nums[i] \u003c nums[j] { break } i-- j-- } // i及其以后的序列是升序，i和j是降序（从右往左看） if i \u003e= 0 { // 不是最后一个排列 // find: A[i]\u003cA[k] for nums[i] \u003e= nums[k] { k-- } // swap A[i], A[k] nums[i], nums[k] = nums[k], nums[i] } // 反转 for i,j:=j,len(nums)-1;i\u003cj;i,j=i+1,j-1{ nums[i], nums[j] = nums[j], nums[i] } return } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:148:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day148 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:149:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"32. 最长有效括号 题目 给你一个只包含 '(' 和 ')' 的字符串，找出最长有效（格式正确且连续）括号子串的长度。 示例 1： 输入：s = \"(()\" 输出：2 解释：最长有效括号子串是 \"()\" 示例 2： 输入：s = \")()())\" 输出：4 解释：最长有效括号子串是 \"()()\" 示例 3： 输入：s = \"\" 输出：0 提示： 0 \u003c= s.length \u003c= 3 * 104 s[i] 为 '(' 或 ')' 解法 方法一：栈 这个与普通括号匹配有点不一样，求解子串长度，因此我们只需要在栈中存放下标即可。为了分开不同连续子串括号，我们需要预留)作为分界线。 https://leetcode.cn/problems/longest-valid-parentheses/solutions/314827/shou-hua-tu-jie-zhan-de-xiang-xi-si-lu-by-hyj8/ func longestValidParentheses(s string) int { stack := []int{-1} max:=0 for i:=0;i\u003clen(s);i++{ if s[i]=='( stack = append(stack,i) }else{ stack = stack[:len(stack)-1] if len(stack)==0 { stack = append(stack,i) }else { l := i-stack[len(stack)-1] if l\u003emax{ max = l } } } } return max } 方法二：动态规划 https://leetcode.cn/problems/longest-valid-parentheses/solutions/314683/zui-chang-you-xiao-gua-hao-by-leetcode-solution/ ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:149:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day149 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:150:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"42. 接雨水 题目 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。 示例 1： 输入：height = [0,1,0,2,1,0,1,3,2,1,2,1] 输出：6 解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 示例 2： 输入：height = [4,2,0,3,2,5] 输出：9 提示： n == height.length 1 \u003c= n \u003c= 2 * 104 0 \u003c= height[i] \u003c= 105 解法 官方三解法 https://leetcode.cn/problems/trapping-rain-water/solutions/692342/jie-yu-shui-by-leetcode-solution-tuvc/ func trap(height []int) int { n:=len(height) ans:=0 if n\u003c=1 { return ans } leftdp := make([]int,n) rightdp := make([]int,n) max := func(a,b int) int{ if a\u003eb{ return a } return b } min := func(a,b int) int{ if a\u003cb{ return a } return b } // 初始化 leftdp[0] = height[0] rightdp[n-1] = height[n-1] // 记录状态 for i:=1;i\u003cn;i++{ leftdp[i] = max(leftdp[i-1],height[i]) } for i:=n-2;i\u003e=0;i--{ rightdp[i] = max(rightdp[i+1],height[i]) } // 状态转移 for i:=0;i\u003cn;i++{ ans += min(leftdp[i],rightdp[i]) - height[i] } return ans } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:150:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day150 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:151:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"48. 旋转图像 题目 解法 解法一：找数学规律 func rotate(matrix [][]int) { reverseColFunc := func(matrix [][]int,j int){ n:=len(matrix) for i:=0;i\u003cn/2;i++{ matrix[i][j],matrix[n-i-1][j] = matrix[n-i-1][j],matrix[i][j] } } for j:=0;j\u003clen(matrix[0]);j++{ reverseColFunc(matrix,j) } n:=len(matrix) m:=len(matrix[0]) for i:=0;i\u003cn;i++{ for j:=i+1;j\u003cm;j++{ matrix[i][j],matrix[j][i] = matrix[j][i],matrix[i][j] } } return } // 先按照列，对每一个列都进行反转 // 再进行矩阵对称变换 反转还可以优化 反转只需要O(n) func rotate(matrix [][]int) { n := len(matrix) // 水平翻转 for i := 0; i \u003c n/2; i++ { matrix[i], matrix[n-1-i] = matrix[n-1-i], matrix[i] } // 主对角线翻转 for i := 0; i \u003c n; i++ { for j := 0; j \u003c i; j++ { matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] } } } 其他解法 https://leetcode.cn/problems/rotate-image/solutions/526980/xuan-zhuan-tu-xiang-by-leetcode-solution-vu3m/ ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:151:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day151 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:152:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"49. 字母异位词分组 题目 给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。 字母异位词 是由重新排列源单词的所有字母得到的一个新单词。 示例 1: 输入: strs = [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"] 输出: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]] 示例 2: 输入: strs = [\"\"] 输出: [[\"\"]] 示例 3: 输入: strs = [\"a\"] 输出: [[\"a\"]] 提示： 1 \u003c= strs.length \u003c= 104 0 \u003c= strs[i].length \u003c= 100 strs[i] 仅包含小写字母 解法 解法一：排序 题目的核心在于如何判断两个字母是“字母异位词”？其实“字母异位词”排序后是相同字母，因此，我们可以借用哈希表来存储并去重：将排序后具有相同字符串的序列合并在一起即可 func groupAnagrams(strs []string) [][]string { ans := [][]string{} m := make(map[string][]string,0) for i:=0;i\u003clen(strs);i++{ b:=[]byte(strs[i]) sort.Slice(b, func(i, j int) bool { return b[i] \u003c b[j] }) key:=string(b) m[key] = append(m[key],strs[i]) } for _,v:=range m{ ans = append(ans,v) } return ans } 解法二：计数 https://leetcode.cn/problems/group-anagrams/solutions/520469/zi-mu-yi-wei-ci-fen-zu-by-leetcode-solut-gyoc/ ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:152:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day152 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:153:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"53. 最大子数组和 题目 给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 子数组 是数组中的一个连续部分。 示例 1： 输入：nums = [-2,1,-3,4,-1,2,1,-5,4] 输出：6 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。 示例 2： 输入：nums = [1] 输出：1 示例 3： 输入：nums = [5,4,-1,7,8] 输出：23 提示： 1 \u003c= nums.length \u003c= 105 -104 \u003c= nums[i] \u003c= 104 **进阶：**如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的 分治法 求解。 解法 官方解法 func maxSubArray(nums []int) int { dp := make([]int,len(nums)) max := func(a,b int) int{ if a\u003eb { return a } return b } dp[0] = nums[0] ans := nums[0] for i:=1;i\u003clen(nums);i++{ dp[i] = max(dp[i-1]+nums[i],nums[i]) ans = max(dp[i],ans) } return ans } // dp[i]表示第i个数结尾的连续子数组的最大和 // dp[i] = max(nums[i],dp[i-1]+nums[i]) // 第i个数可以加入连续子序列，也可以不加入连续子序列，新开始一个新的子序列，主要依据是看谁最大 // 然后，找出所有连续子数组的最大和 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:153:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day153 ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:154:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"75. 颜色分类 题目 解法 解法一：排序 func sortColors(nums []int){ // 快速排序 // 分区 partition:=func(nums []int,start,end int)int{ pivot:=nums[end] left:=start right:=end for left\u003cright{ for left\u003cright\u0026\u0026nums[left]\u003c=pivot{ left++ } for left\u003cright\u0026\u0026nums[right]\u003e=pivot{ right-- } // 交换 nums[left],nums[right] = nums[right],nums[left] } nums[left],nums[end] = nums[end],nums[left] return left } var qsort func(nums []int,left ,right int) qsort=func(nums []int,left,right int){ if left\u003e=right{ return } p:=partition(nums,left,right) qsort(nums,left,p-1) qsort(nums,p+1,right) } qsort(nums,0,len(nums)-1) } 解法二：单指针 func swapColors(colors []int, target int) (countTarget int) { for i, c := range colors { if c == target { colors[i], colors[countTarget] = colors[countTarget], colors[i] countTarget++ } } return } func sortColors(nums []int) { count0 := swapColors(nums, 0) // 把 0 排到前面 swapColors(nums[count0:], 1) // nums[:count0] 全部是 0 了，对剩下的 nums[count0:] 把 1 排到前面 } 解法三：双指针 func sortColors(nums []int){ // 双指针 n0:=0 n1:=0 num:=0 for i:=0;i\u003clen(nums);i++{ num=nums[i] nums[i]=2 if num\u003c2{ nums[n1]=1 n1++ } if num\u003c1{ nums[n0]=0 n0++ } } } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:154:1","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["数据结构与算法"],"content":"day154 76. 最小覆盖子串 题目 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 \"\" 。 注意： 对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。 如果 s 中存在这样的子串，我们保证它是唯一的答案。 示例 1： 输入：s = \"ADOBECODEBANC\", t = \"ABC\" 输出：\"BANC\" 解释：最小覆盖子串 \"BANC\" 包含来自字符串 t 的 'A'、'B' 和 'C'。 示例 2： 输入：s = \"a\", t = \"a\" 输出：\"a\" 解释：整个字符串 s 是最小覆盖子串。 示例 3: 输入: s = \"a\", t = \"aa\" 输出: \"\" 解释: t 中两个字符 'a' 均应包含在 s 的子串中， 因此没有符合条件的子字符串，返回空字符串。 提示： m == s.length n == t.length 1 \u003c= m, n \u003c= 105 s 和 t 由英文字母组成 **进阶：**你能设计一个在 o(m+n) 时间内解决此问题的算法吗？ 解法 解法一：滑动窗口+哈希表 func minWindow(s string, t string) string { ori, cnt := map[byte]int{}, map[byte]int{} for i := 0; i \u003c len(t); i++ { ori[t[i]]++ } sLen := len(s) len := math.MaxInt32 ansL, ansR := -1, -1 check := func() bool { for k, v := range ori { if cnt[k] \u003c v { return false } } return true } for l, r := 0, 0; r \u003c sLen; r++ { if r \u003c sLen \u0026\u0026 ori[s[r]] \u003e 0 { cnt[s[r]]++ } // 查看窗口是否覆盖t，若覆盖再移动左指针缩小窗口，否则继续移动右指针扩大窗口 for check() \u0026\u0026 l \u003c= r { if (r - l + 1 \u003c len) { len = r - l + 1 ansL, ansR = l, l + len } if _, ok := ori[s[l]]; ok { cnt[s[l]] -= 1 } l++ } } if ansL == -1 { return \"\" } return s[ansL:ansR] } ","date":"2023-01-08","objectID":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/:155:0","tags":["leetcode"],"title":"Leetcode每日一题","uri":"/leecode%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"},{"categories":["golang"],"content":"sync.Pool使用及源码浅析 ","date":"2022-09-24","objectID":"/sync.pool%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:1:0","tags":["go编程技巧"],"title":"Sync.Pool的使用及源码分析","uri":"/sync.pool%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["golang"],"content":"sync.Pool使用 背景 “频繁创建对象，频繁销毁对象”是在项目开发里算比较常见。sync.Pool的出现就是为了解决这个问题。 Go语言从1.3版本开始提供了对象重用的机制，即sync.Pool。sync.Pool是可伸缩的，同时也是并发安全的，其大小仅受限于内存的大小。sync.Pool用于存储那些被分配了但是没有被使用，而未来可能会使用的值。这样就可以不用再次经过内存分配，可直接复用已有对象，减轻GC的压力，从而提升系统的性能。 sync.Pool的大小是可伸缩的，高负载时会动态扩容，存放在池中的对象如果不活跃了会被自动清理。 GC是一种自动内存管理机制，回收不再使用的对象的内存。 需要注意的是，sync.Pool 缓存的对象随时可能被无通知的清除，因此不能将 sync.Pool 用于存储持久对象的场景。 声明对象池 只需要实现New函数即可。对象池中没有对象时，将会调用New函数创建。 var machinePool = sync.Pool{ New: func() interface{} { return new(Machine) }, } Get\u0026Put m := machinePool.Get().(*Machine) json.Unmarshal(buf, m) machinePool.Put(m) Get() 用于从对象池中获取对象，因为返回值是 interface{}，因此需要类型转换。 Put() 则是在对象使用完毕后，返回对象池。 性能测试 struct反序列化 func BenchmarkUnmarshal(b *testing.B) { for n := 0; n \u003c b.N; n++ { m := \u0026Machine{} if err := json.Unmarshal([]byte(\"{\\\"A\\\":2}\"), m); err != nil { log.Println(err) return } } } func BenchmarkUnmarshalWithPool(b *testing.B) { for n := 0; n \u003c b.N; n++ { m := machinePool.Get().(*Machine) if err := json.Unmarshal([]byte(\"{\\\"A\\\":2}\"), m); err != nil { log.Println(err) return } machinePool.Put(m) } } 测试： $ go test -bench . -benchmem goos: windows goarch: amd64 pkg: demo cpu: Intel(R) Core(TM) i5-10210U CPU @ 1.60GHz BenchmarkUnmarshal-8 2188940 528.5 ns/op 232 B/op 6 allocs/op BenchmarkUnmarshalWithPool-8 2264995 518.5 ns/op 224 B/op 5 allocs/op PASS ok demo 3.805s 可以从结果看到：使用池化复用对象的方式要比不使用具有更好的性能。当然，本例之中的结构体比较小，没能凸显出较大区别。 bytes.Buffer var bufferPool = sync.Pool{ New: func() interface{} { return \u0026bytes.Buffer{} }, } var data = make([]byte, 10000) func BenchmarkBufferWithPool(b *testing.B) { for n := 0; n \u003c b.N; n++ { buf := bufferPool.Get().(*bytes.Buffer) buf.Write(data) buf.Reset() bufferPool.Put(buf) } } func BenchmarkBuffer(b *testing.B) { for n := 0; n \u003c b.N; n++ { var buf bytes.Buffer buf.Write(data) } } 测试： $ go test -bench . -benchmem goos: windows goarch: amd64 pkg: demo cpu: Intel(R) Core(TM) i5-10210U CPU @ 1.60GHz BenchmarkBufferWithPool-8 10175354 109.2 ns/op 0 B/op 0 allocs/op BenchmarkBuffer-8 750318 1669 ns/op 1024","date":"2022-09-24","objectID":"/sync.pool%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:1:1","tags":["go编程技巧"],"title":"Sync.Pool的使用及源码分析","uri":"/sync.pool%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["golang"],"content":"sync.Pool浅析 参考博客 -\u003e https://www.cyhone.com/articles/think-in-sync-pool/ // A Pool must not be copied after first use. type Pool struct { noCopy noCopy local unsafe.Pointer // local fixed-size per-P pool, actual type is [P]poolLocal localSize uintptr // size of the local array victim unsafe.Pointer // local from previous cycle victimSize uintptr // size of victims array // New optionally specifies a function to generate // a value when Get would otherwise return nil. // It may not be changed concurrently with calls to Get. New func() interface{} } no copy no copy的原因是为了安全，因为结构体对象中包含引用类型的话，直接赋值拷贝是浅拷贝，是不安全的。因为浅拷贝之后，就相当于有两个指针指向同一个地址上的对象，任意一个指针引起的更新删除等操作都会影响到另一个指针。 no copy的实现也很简单，只需要有实现sync.Locker接口，然后再把实现的类型嵌入目标结构体，就可以实现。这种实现不是直接禁掉复制这个功能，嵌入了no copy字段的程序依然可以正常执行。通过go vet分析，拷贝了嵌入no copy字段的类型时会报错，提示不能对当前类型进行值拷贝（goland也能在一定程度上提示，变黄）。 当然除了使用no copy字段来约束类型不能出现复制以外，还可以在代码逻辑层面实现（不是范式，不能总结）。 local \u0026 local size local 是个数组，长度为 P 的个数。其元素类型是 poolLocal。这里面存储着各个 P 对应的本地对象池。可以近似的看做 [P]poolLocal。（P，指的是GMP里的Processor） localSize。代表 local 数组的长度。因为 P 可以在运行时通过调用 runtime.GOMAXPROCS 进行修改, 因此我们还是得通过 localSize 来对应 local 数组的长度。 由于每个 P 都有自己的一个本地对象池 poolLocal，Get 和 Put 操作都会优先存取本地对象池。由于 P 的特性，操作本地对象池的时候整个并发问题就简化了很多，可以尽量避免并发冲突。 我们再看下本地对象池 poolLocal 的定义，如下： // 每个 P 都会有一个 poolLocal 的本地 type poolLocal struct { poolLocalInternal pad [128 - unsafe.Sizeof(poolLocalInternal{})%128]byte // 128 - unsafe.Sizeof(poolLocalInternal{})%128 + unsafe.Sizeof(poolLocalInternal{}) = n*128 } type poolLocalInternal struct { private interface{} shared poolChain } pad 变量的作用在下文会讲到，这里暂时不展开讨论。我们可以直接看 poolLocalInternal 的定义，其中每个本地对象池，都会包含两项： private 私有变量。Get 和 Put 操作都会优先存取 private 变量，如果 private 变量可以满足情况，则不再深入进行其他的复杂操作。 shared。其类型为 poolChain，这个是链表结构，这个就是 P 的本地对象池了。 Get方法 func (p *Pool) Get() interface{} { if race.Enabled { race.Disable() } // 禁掉M调度，固定住P，并拿到当前P的poolLocal数组 l, pid := p.pin() // 途径一：拿私有 x := l.private l.private = nil // 途径二：私有没有，就拿公共存储区shared双端队列缓存 if x == nil { x, _ = l.shared.popHead() if x == nil { // 途径三：还没有，在当前","date":"2022-09-24","objectID":"/sync.pool%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:1:2","tags":["go编程技巧"],"title":"Sync.Pool的使用及源码分析","uri":"/sync.pool%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["golang"],"content":"sync.Pool结构 ","date":"2022-09-24","objectID":"/sync.pool%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:1:3","tags":["go编程技巧"],"title":"Sync.Pool的使用及源码分析","uri":"/sync.pool%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"},{"categories":["git"],"content":"Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。 $ git commit -m \"hello world\" 上面代码的-m参数，就是用来指定 commit mesage 的。 如果一行不够，可以只执行git commit，就会跳出文本编辑器，让你写多行。 $ git commit 基本上，你写什么都行（这里，这里和这里）。 但是，一般来说，commit message 应该清晰明了，说明本次提交的目的。 目前，社区有多种 Commit message 的写法规范。本文介绍Angular 规范（见上图），这是目前使用最广的写法，比较合理和系统化，并且有配套的工具。 ","date":"2022-08-25","objectID":"/git%E4%B9%8Bcommit%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97/:0:0","tags":[],"title":"Git之commit规范指南","uri":"/git%E4%B9%8Bcommit%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97/"},{"categories":["git"],"content":"Commit message 的作用 格式化的Commit message，有几个好处。 （1）提供更多的历史信息，方便快速浏览。 比如，下面的命令显示上次发布后的变动，每个commit占据一行。你只看行首，就知道某次 commit 的目的。 $ git log \u003clast tag\u003e HEAD --pretty=format:%s （2）可以过滤某些commit（比如文档改动），便于快速查找信息。 比如，下面的命令仅仅显示本次发布新增加的功能。 $ git log \u003clast release\u003e HEAD --grep feature （3）可以直接从commit生成Change log。 Change Log 是发布新版本时，用来说明与上一个版本差异的文档，详见后文。 ","date":"2022-08-25","objectID":"/git%E4%B9%8Bcommit%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97/:1:0","tags":[],"title":"Git之commit规范指南","uri":"/git%E4%B9%8Bcommit%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97/"},{"categories":["git"],"content":"Commit message 的格式 每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。 \u003ctype\u003e(\u003cscope\u003e): \u003csubject\u003e // 空一行 \u003cbody\u003e // 空一行 \u003cfooter\u003e 其中，Header 是必需的，Body 和 Footer 可以省略。 不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。 ","date":"2022-08-25","objectID":"/git%E4%B9%8Bcommit%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97/:2:0","tags":[],"title":"Git之commit规范指南","uri":"/git%E4%B9%8Bcommit%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97/"},{"categories":["git"],"content":"Header Header部分只有一行，包括三个字段：type（必需）、scope（可选）和subject（必需）。 （1）type type用于说明 commit 的类别，只允许使用下面7个标识。 feat：新功能（feature） fix：修补bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改bug的代码变动） test：增加测试 chore：构建过程或辅助工具的变动 perf：性能优化 build：构建工具或外部依赖包的修改，比如更新依赖包的版本等 ci：持续集成的配置文件或脚本的修改 如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中。其他情况（docs、chore、style、refactor、test）由你决定，要不要放入 Change log，建议是不要。 （2）scope scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。 （3）subject subject是 commit 目的的简短描述，不超过50个字符。 以动词开头，使用第一人称现在时，比如change，而不是changed或changes 第一个字母小写 结尾不加句号（.） ","date":"2022-08-25","objectID":"/git%E4%B9%8Bcommit%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97/:2:1","tags":[],"title":"Git之commit规范指南","uri":"/git%E4%B9%8Bcommit%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97/"},{"categories":["git"],"content":"Body Body 部分是对本次 commit 的详细描述，可以分成多行。下面是一个范例。 More detailed explanatory text, if necessary. Wrap it to about 72 characters or so. Further paragraphs come after blank lines. - Bullet points are okay, too - Use a hanging indent 有两个注意点。 （1）使用第一人称现在时，比如使用change而不是changed或changes。 （2）应该说明代码变动的动机，以及与以前行为的对比。 ","date":"2022-08-25","objectID":"/git%E4%B9%8Bcommit%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97/:2:2","tags":[],"title":"Git之commit规范指南","uri":"/git%E4%B9%8Bcommit%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97/"},{"categories":["git"],"content":"Footer Footer 部分只用于两种情况。 （1）不兼容变动 如果当前代码与上一个版本不兼容，则 Footer 部分以BREAKING CHANGE开头，后面是对变动的描述、以及变动理由和迁移方法。 BREAKING CHANGE: isolate scope bindings definition has changed. To migrate the code follow the example below: Before: scope: { myAttr: 'attribute', } After: scope: { myAttr: '@', } The removed `inject` wasn't generaly useful for directives so there should be no code using it. （2）关闭 Issue 如果当前 commit 针对某个issue，那么可以在 Footer 部分关闭这个 issue 。 Closes #234 也可以一次关闭多个 issue 。 Closes #123, #245, #992 ","date":"2022-08-25","objectID":"/git%E4%B9%8Bcommit%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97/:2:3","tags":[],"title":"Git之commit规范指南","uri":"/git%E4%B9%8Bcommit%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97/"},{"categories":["git"],"content":"Revert 还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以revert:开头，后面跟着被撤销 Commit 的 Header。 revert: feat(pencil): add 'graphiteWidth' option This reverts commit 667ecc1654a317a13331b17617d973392f415f02. Body部分的格式是固定的，必须写成This reverts commit \u003chash\u003e.，其中的hash是被撤销 commit 的 SHA 标识符。 如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面。 ","date":"2022-08-25","objectID":"/git%E4%B9%8Bcommit%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97/:2:4","tags":[],"title":"Git之commit规范指南","uri":"/git%E4%B9%8Bcommit%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97/"},{"categories":["git"],"content":"Commit规范示例 https://github.com/go-redis/redis https://github.com/gomodule/redigo ","date":"2022-08-25","objectID":"/git%E4%B9%8Bcommit%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97/:3:0","tags":[],"title":"Git之commit规范指南","uri":"/git%E4%B9%8Bcommit%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97/"}]